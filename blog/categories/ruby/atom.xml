<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2018-06-24T17:29:47+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails And Conditional Validations In Models]]></title>
    <link href="https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models/"/>
    <updated>2018-06-24T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models</id>
    <content type="html"><![CDATA[<p>Adding consents for accepting Terms of Service/Privacy Policies must have been a top popular feature in the majority of the applications due to enforcement of <strong>GDPR</strong> in May ;). From the technical aspects that GDPR requires, there is a proof of consent for processing the personal information. In that case, you need to have some actual attributes in the database that would confirm the fact that some user has indeed accepted Terms of Service/Privacy Policy.</p>

<p>That makes a significant impact on how we approach this kind of features. However, in the past, such things were quite often not stored in a database at all &ndash; it just took some UI <strong>acceptance validation</strong> or maybe a <strong>validation of the virtual attribute</strong> on the backend to be on the safe side.</p>

<p>Let&rsquo;s focus on the latter case where we don&rsquo;t need to store anything in DB and see what the possible solutions to that problems are. As <strong>trivial</strong> as this problem initially sounds, it will get <strong>quite interesting</strong> ;).</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>We want to make sure a user accepts Terms of Service during the signup process and to be sure that it is indeed validated, even if JavaScript validation fails in UI, we want to validate that fact on the backend.</p>

<h2>Solution 1 &ndash; Just add a virtual attribute to the model and validate it</h2>

<p>It is probably the most straightforward approach to that problem and most likely the least elegant. That&rsquo;s how we could implement it:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Well, it does work, no doubt about that. But currently, the validation will always be triggered, even during updates, which doesn&rsquo;t make much sense. We need to find a better solution.</p>

<h2>Solution 2 &ndash; Add a virtual attribute to the model and validate it only during the creation of a user</h2>

<p>A minor improvement over the previous version, we make sure that the validation is not triggered by updates, but only when creating a user:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :create
end
```</p>

<p>Even if it solves the actual problem, there is a big issue about that &ndash; the validation will always be triggered during a creation, even when creating users from factories! What other options do we have?</p>

<h2>Solution 3 &ndash; Add a virtual attribute to the model and validate it only for a specific context</h2>

<p>What is interesting in ActiveModel validations is that <code>on</code> option is not limited to <code>:create</code> or <code>:update</code> contexts &ndash; those are merely the ones that ActiveRecord sets by default depending on the persistence status of the model. We can provide a custom context for both <code>valid?</code> and <code>save</code> methods:</p>

<p><code>rb
user.valid?(:registration)
user.save(context: :registration)
</code></p>

<p>In that case, we could replace <code>:create</code> context with <code>:registration</code> context for the acceptance validation:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :registration
end
```</p>

<p>However, this is still not ideal &ndash; a global model which is used in multiple contexts has some logic that only applies to just one use case, and what is even worse, it&rsquo;s for an UI concern.</p>

<p>Let&rsquo;s try to find a solution that doesn&rsquo;t add any unnecessary mess to a model.</p>

<h2>Solution 4 &ndash; Use form object</h2>

<p>Using form object is probably the cleanest solution to our problem &ndash; we don&rsquo;t introduce any additional concerns to a model which should not be there, and we handle everything in a dedicated object. The are multiple ways how to implement a form object: we could create another ActiveModel model and take advantage of <a href="https://github.com/Azdaroth/active_model_attributes">ActiveModel Attributes</a> to make it smoother. We could use <a href="http://dry-rb.org/gems/dry-validation/basics/working-with-schemas/">dry-validation</a> gem for that. Or we could use my favorite tool for that purpose: <a href="https://github.com/trailblazer/reform">reform</a> gem from <a href="http://trailblazer.to">Trailblazer</a> stack.</p>

<p>Explaining the entire API of <code>reform</code> gem is way beyond the scope of this article, but the following implementation should be quite self-explanatory:</p>

<p>``` rb</p>

<h1>app/forms/user/registration_form.rb</h1>

<p>require &ldquo;reform/form/coercion&rdquo;</p>

<p>class User::RegistrationForm &lt; Reform::Form
  # other property declarations and validations</p>

<p>  property :terms_of_service_accepted, virtual: :true, type: Types::Form::Boolean</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Besides handling other properties (most likely <code>email</code>, <code>password</code> and <code>password confirmation</code>), we are adding a virtual <code>terms_of_service_accepted</code> attribute with explicit type and adding acceptance validation using ActiveModel validator.</p>

<p>Even though using form objects is the cleanest approach, it requires some extra overhead, mostly with the setup, and sometimes it might be painful to add that setup, especially when extending third party&rsquo;s logic, e.g. <a href="https://github.com/scambra/devise_invitable">devise_invitable</a>. In such case, we would need some heavy customization which could potentially break when updating a gem and we would also need extra test coverage for the custom solution. It might still be worth introducing a form object, but it would be a good idea to consider other potential solutions. What option do we have left?</p>

<h2>Solution 5 &ndash; Extend user&rsquo;s instance with a custom logic</h2>

<p>Have you ever heard of DCI (Data Context Interaction) paradigm? If yes, you might have seen something like that:</p>

<p><code>rb
user = User.find(id)
user.extend(User::RegistrationContext)
</code></p>

<p>What this code does is adding extra functionality from <code>User::RegistrationContext</code> module to user&rsquo;s singleton class. Effectively, it means that we are not adding any additional logic to all User class instances, but only to that particular instance. Sounds like exactly what we need! That way, we can solve our problem achieving all the other goals as well &ndash; ease of extending the logic without too much overhead and without making a mess in the model.</p>

<p>Here is how our implementation of <code>User::RegistrationContext</code> context module could look like:</p>

<p>``` rb</p>

<h1>app/models/user/registration_context.rb</h1>

<p>module User::RegistrationContext
  def self.extended(model)</p>

<pre><code>class &lt;&lt; model
  validates :terms_of_service_accepted, acceptance: true
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :terms_of_service_accepted
end
```</p>

<p>The interesting thing about this implementation is that there is some singletons' inception going on there &ndash; first, we are using <code>extend</code> itself on the model, and then, in <code>extended</code> module hook we are opening singleton class of the model and declaring validation there. However, this is necessary since <code>validates</code> method is not defined in the context of that module, and we need to do that in the context of the model.</p>

<p>Let&rsquo;s try our fancy solution in action:</p>

<p><code>rb
user = User.new
user.extend(User::RegistrationContext)
user.terms_of_service_accepted = "0"
user.valid?
=&gt; false
user.errors.messages[:terms_of_service_accepted]
=&gt; ["must be accepted"]
</code></p>

<p>Perfect, that&rsquo;s exactly what we needed!</p>

<h2>Wrapping Up</h2>

<p>There are multiple ways in Rails (or Ruby in general) to handle <strong>conditional validation</strong>, and thanks to the flexibility of the framework and the language, we can pick whatever seems best for our particular problem &ndash; from adding additional validations in a model with <strong>extra ActiveModel context</strong>, through using <strong>form objects</strong>, ending with arcane DCI-style object&rsquo;s extensions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Case for before_validation callback: complex state normalization]]></title>
    <link href="https://karolgalanciak.com/blog/2018/05/27/the-case-for-before-validation-callback-complex-state-normalization/"/>
    <updated>2018-05-27T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/05/27/the-case-for-before-validation-callback-complex-state-normalization</id>
    <content type="html"><![CDATA[<p>Few months ago I wrote a <a href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/">blog post</a> about <strong>ActiveRecord</strong> <code>before_validation</code> callback and how it is used for  <strong>wrong reasons</strong> and concluded that in most cases this is not something we should be using routinely. However, I missed one <strong>appropriate use case</strong> for it which might be quite common in Rails apps, so this might be an excellent opportunity to get back to  <strong>before_validation callback</strong> and show its other side.</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Imagine that we have a <code>Payment</code> model where we need to store <code>amount</code> and <code>currency</code>. However, for statistical purposes, we also want to store normalized amount in USD currency with exchange rate applied at the time of payment&rsquo;s creation. As this is a significant part of our domain, we want to add validation for <code>amount_in_usd</code> attribute. Our Payment model looks like this at the moment:</p>

<p><code>rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true
end
</code></p>

<p>The question is: where do we get <code>amount_in_usd</code> from and how can we assign it?</p>

<h2>The Solution</h2>

<p>One way of solving that problem would be a direct assignment when populating all the attributes. In that case, it would look a bit like this:</p>

<p><code>rb
Payment.new(currency: currency, amount: amount, amount_in_usd: CurrencyExchanger.exchange(amount, from: currency, to: "USD"))
</code></p>

<p>The problem with that solution is that this logic would need to be repeated in every place where payment gets initialized. We could implement a factory class that would be reused in all scenarios to keep it DRY, but that&rsquo;s some extra overhead that is not popular in a Rails world. Also, this sounds like a responsibility of the Payment model itself as it is about managing its internal state.</p>

<p>Here, we can&rsquo;t solve this by overriding writers as I suggested <a href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/">before</a> as <code>amount_in_usd</code> depends on two attributes: <code>currency</code> and <code>amount</code>, and we don&rsquo;t know in which sequence the attributes will be assigned.</p>

<p>And this is exactly the case where <code>before_validation</code> is useful: for complex state normalization where multiple attributes are involved. With that callback, a solution looks quite elegant and just simpler:</p>

<p>``` rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true</p>

<p>  before_validation :assign_amount_in_usd</p>

<p>  private</p>

<p>  def assign_amount_in_usd</p>

<pre><code>if currency &amp;&amp; amount
  self.amount_in_usd = CurrencyExchanger.exchange(amount, from: currency, to: "USD")
end
</code></pre>

<p>  end
end
```</p>

<h2>Alternative Solution</h2>

<p>In the first paragraph, I mentioned that this solution could work especially well in Rails apps. What I meant by that is the fact that usually, the &ldquo;primitive&rdquo; attributes coming from HTTP params are mass-assigned to the model. Of course in Ruby, everything is an object, but to keep things simpler, let&rsquo;s treat numeric types and strings as primitives.</p>

<p>What would be a non-primitive value though? In our case, we have something that is widely used as a typical example of a value object: <strong>Money</strong> object that is composed of <code>amount</code> and <code>currency</code>.  If the attributes before the assignment were mapped to some more domain-oriented objects, we would have an even simpler solution for our problem:</p>

<p><code>rb
money = Money.new(amount, currency)
Payment.new(money: money)
</code></p>

<p>and the model would look like this:</p>

<p>``` rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true</p>

<p>  def money=(money_object)</p>

<pre><code>self.amount = money_object.amount
self.currency = money_object.currency
self.amount_in_usd = CurrencyExchanger.exchange_money(money_object, to: "USD")
</code></pre>

<p>  end
end
```</p>

<p>It might look like extra overhead that is not necessary. However, value objects tend to simplify and DRY a lot of things in the code, so for more complex apps, using value objects will be worth that extra overhead.</p>

<h2>Wrapping Up</h2>

<p>There are some cases where <code>before_validation</code> callback might be useful. However, in more complex apps, using value object might be an alternative worth looking into.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exotic Ruby: Module.class_exec, custom JSON And Liquid Drops In Action]]></title>
    <link href="https://karolgalanciak.com/blog/2018/03/27/exotic-ruby-module-dot-class-exec-and-liquid-drops-in-action/"/>
    <updated>2018-03-27T21:30:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/03/27/exotic-ruby-module-dot-class-exec-and-liquid-drops-in-action</id>
    <content type="html"><![CDATA[<p>Ruby has quite a lot of <strong>&ldquo;exotic&rdquo; features</strong> that are not used that often, but when you need to utilize some <strong>metaprogramming magic</strong>, you can easily take advantage of them. One of such features is <a href="http://ruby-doc.org/core-2.4.3/BasicObject.html#method-i-instance_exec">Object.instance_exec</a> which you might be familiar with if you&rsquo;ve ever built some more advanced DSL.</p>

<p>The great thing about <code>Object#instance_exec</code> is that it allows to execute code <strong>within the context of a given object</strong> but it also gives possibility to <strong>pass arguments from the current context</strong>. Thanks to that, we can build some nice DSLs and other features like this:</p>

<p><code>rb
role_filter = -&gt;(role) { where(role: role) }
role = "admin"
User.all.instance_exec(role, &amp;role_filter) # same as User.all.where(role: "admin")
</code></p>

<p>An interesting thing is that there is a <strong>class</strong> equivalent of <code>Object#instance_exec</code> &ndash; <a href="http://ruby-doc.org/core-2.4.3/Module.html#method-i-class_exec">Module.class_exec</a>. It would be easy to figure out some theoretical example how it can be used but what could be the real-world use case where this is the best approach to solve the problem?</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Imagine that you can have some custom JSON on every instance of some model and this JSON can have very different attributes on every instance depending on various conditions, like some category this model belongs to. To make it more complex, let&rsquo;s assume that the schema is customizable by the user so we can never really predict what kind of attributes are going to end up there.</p>

<p>Our feature to implement is to provide some wrapper class for this custom JSON so that we don&rsquo;t need to operate on hashes but we can have some objects where we can access these attributes by invoking methods on this object.</p>

<p>Using <a href="http://ruby-doc.org/stdlib-2.4.3/libdoc/ostruct/rdoc/OpenStruct.html">OpenStructs</a> sounds like the quickest solution to the problem but this is not going to be that easy in our case &ndash; we will need to expose this class to be used with <a href="https://github.com/Shopify/liquid">Liquid</a> templates, so that means we will need to inherit from <a href="https://github.com/Shopify/liquid/blob/4-0-stable/lib/liquid/drop.rb">Liquid::Drop</a>.</p>

<p>How about creating some <code>Wrapper</code> class that would take the <code>payload</code> as an argument and use <a href="http://ruby-doc.org/core-2.4.3/Object.html#method-i-define_singleton_method">Object#define_singleton_method</a> in the constructor to define custom methods based on the keys and values in that payload? Defining singleton methods sounds like the right solution to the problem as indeed each instance might need different methods. Let&rsquo;s try that:</p>

<p>``` rb</p>

<h1>app/drops/wrapper.rb</h1>

<p>class Wrapper &lt; Liquid::Drop
  def initialize(payload)</p>

<pre><code>@payload = payload

payload.each do |key, value|
  define_singleton_method key do
    value
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Looks like it might be the answer to the problem:</p>

<p>``` ruby
payload =  { ruby: &ldquo;is freakin' awesome!&rdquo; }
wrapper = Wrapper.new(payload)
wrapper.ruby</p>

<h1>=> &ldquo;is freakin' awesome!&rdquo;</h1>

<p>```</p>

<p>There is a huge problem with this solution though. These singleton methods are not going to be included in <code>Wrapper.public_instance_methods</code> array:</p>

<p>``` rb
Wrapper.public_instance_methods.include?(:ruby)</p>

<h1>=> false</h1>

<p>```</p>

<p>It might not be a big issue in some cases, but it won&rsquo;t work with <a href="https://github.com/Shopify/liquid">Liquid</a> <a href="https://github.com/Shopify/liquid/blob/4-0-stable/lib/liquid/drop.rb#L64-L76">Drop</a>, which explicitly checks for <code>public_instance_methods</code>.</p>

<p>Do we have any alternative that would be the most robust solution to this problem?</p>

<h2>The Solution</h2>

<p>The answer is yes! Although, the solution is going to be more tricky than the previous one.</p>

<p>First, we will need to take advantage of using the constructor of <code>Class</code> itself and create anonymous classes inheriting from <code>Liquid::Drop</code>. The next step would be defining the required methods based on <code>payload</code>. But how can we do that if <code>payload</code> is not available in the context of this class? We will need to make it available somehow and execute the code within the context of this class.</p>

<p>Fortunately, Ruby has got our back, and we can take advantage of <a href="http://ruby-doc.org/core-2.4.3/Module.html#method-i-class_exec">Module.class_exec</a> method which does exactly what we need here.</p>

<p>Here is a potential implementation:</p>

<p>``` rb
payload =  { ruby: &ldquo;is freakin' awesome!&rdquo; }
magic_drop_class = Class.new(Liquid::Drop)
magic_drop_class.class_exec(payload) do |payload|
  payload.each do |key, value|</p>

<pre><code>define_method key do
  value
end
</code></pre>

<p>  end
end
example = magic_drop_class.new
example.ruby</p>

<h1>=> &ldquo;is freakin' awesome!&rdquo;</h1>

<p>```</p>

<p>And what about <code>public_instance_methods</code>?</p>

<p>``` ruby
magic_drop_class.public_instance_methods.include?(:ruby)</p>

<h1>=> true</h1>

<p>```</p>

<p>That means we&rsquo;ve managed to achieve our goal!</p>

<h2>Wrapping Up</h2>

<p>Ruby is widely known for <strong>being powerful</strong> and allowing to easily do all kinds of things to objects, including <strong>modifying them on fly</strong> and <strong>executing the code within their context</strong>.  Thanks to that and uncommon methods like <a href="http://ruby-doc.org/core-2.4.3/Module.html#method-i-class_exec">Module.class_exec</a>, we can solve some <strong>tricky and rare problems</strong> with a very <strong>elegant solutions</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The aesthetics of Ruby - Kernel#itself method]]></title>
    <link href="https://karolgalanciak.com/blog/2017/12/26/the-aesthetics-of-ruby-kernel-number-itself-method/"/>
    <updated>2017-12-26T20:30:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2017/12/26/the-aesthetics-of-ruby-kernel-number-itself-method</id>
    <content type="html"><![CDATA[<p>Recently, I&rsquo;ve had quite a popular problem to solve: count the occurences of the given item in a collection. There are few ways to solve this problem &ndash; starting from using <code>Enumerable#inject</code> or <code>Enumerable#each_with_object</code> with an empty hash as an accumulator value and writing a code looking like this:</p>

<p><code>rb
collection.each_with_object({}) { |item, accum| accum[item] = accum[item].to_i + 1 }
</code></p>

<p>through a bit smarter way and taking advantage of the default hash value:</p>

<p><code>rb
collection.each_with_object(Hash.new(0)) { |item, accum| accum[item] = accum[item] + 1 }
</code></p>

<p>All these solutions look quite nice; however, there is one that looks particularly beautiful.</p>

<!--more-->


<h2>The Aesthetics of Ruby</h2>

<p>An interesting way of solving this problem is by using <code>Enumerable#group_by</code> &ndash; we can simply group elements by themselves and count the occurences of each item. Here is one way to implement it:</p>

<p><code>rb
collection.group_by { |item| item }.map { |key, value| [key, value.count] }.to_h
</code></p>

<p>However, it doesn&rsquo;t look that great, especially for Ruby standard. We could do better. Ruby 2.4 adapted a very useful core extension from ActiveSupport: <a href="https://ruby-doc.org/core-2.4.0/Hash.html#method-i-transform_values" target="_blank"><code>Hash#transform_values</code></a>. Thanks to this addition, we could rewrite that to the following code:</p>

<p><code>rb
collection.group_by { |item| item }.transform_values(&amp;:count)
</code></p>

<p>Looks much better, but <code>group_by { |item| item }</code> could still be improved. Is there anything in Ruby that could help us in such case?</p>

<p>It turns out there is! One of the additions in Ruby 2.2 was <a href="https://ruby-doc.org/core-2.2.0/Object.html#method-i-itself" target="_blank"><code>Kernel#itself</code></a>, which simply returns self. It might sound like an odd idea to introduce such method, but this is exactly something that we need:</p>

<p><code>rb
collection.group_by(&amp;:itself).transform_values(&amp;:count)
</code></p>

<p>This code looks just beautiful.</p>

<h2>Wrapping up</h2>

<p>Ruby code is known for being particularly pleasant to read and I&rsquo;m still happy that after several years I still feel immense joy when I discover interesting little things like <a href="https://ruby-doc.org/core-2.2.0/Object.html#method-i-itself" target="_blank"><code>Kernel#itself</code></a> which add up to the overall aesthetics of the language.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Traps on Rails - Overriding boolean methods in models]]></title>
    <link href="https://karolgalanciak.com/blog/2017/11/26/traps-on-rails-overriding-boolean-methods-in-models/"/>
    <updated>2017-11-26T16:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2017/11/26/traps-on-rails-overriding-boolean-methods-in-models</id>
    <content type="html"><![CDATA[<p>One very <strong>useful</strong> feature of <strong>ActiveRecord</strong> is automatically defining attribute readers and writers for all the columns for given tables. For the ones with <strong>boolean</strong> type, however, there is one more addition &ndash; defining an <strong>alias</strong> of the method with a question mark. Sometimes it might be useful to override this method and add some extra requirements for a given condition. However, this might not be such a good idea.</p>

<!--more-->


<h2>Anatomy of the problem</h2>

<p>Imagine that you are developing some application, where users can be activated and deactivated from an admin panel. However, the application is not free, and every user that wants to access the application needs to buy a subscription. In that case, to check if the user is, in fact, active, you could override <code>User#active?</code> method and add some extra requirements regarding the subscription:</p>

<p>``` rb</p>

<h1>app/models/users.rb</h1>

<p>class User &lt; ApplicationRecord
  def active?</p>

<pre><code>super &amp;&amp; valid_subscription?
</code></pre>

<p>  end</p>

<p>  def valid_subscription?</p>

<pre><code># somehow check if the subscription is valid
</code></pre>

<p>  end
end
```</p>

<p>We are taking advantage of the fact that ActiveRecord defines the aliases for boolean columns which are the original column names' ending with a question mark, so for <code>active</code> boolean column we can expect that <code>active?</code> method will be defined, and it will work the same as <code>active</code> method.</p>

<p>Ok, cool, we have our feature working and to check if a user is fully active, we call <code>User#active?</code> here and there. Our next requirement is exposing users in the API. Nothing too hard, we can add <a href="https://github.com/fotinakis/jsonapi-serializers"><code>jsonapi-serializers</code></a> gem and implement fully JSONAPI-compliant serializers. It turns out that we need to expose info if a user is active and not. Here is how our serializer could look like:</p>

<p>``` rb</p>

<h1>app/serializers/user.rb</h1>

<p>class UserSerializer
  include JSONAPI::Serializer</p>

<p>  attribute :active
  # other attributes
end
```</p>

<p>It sounds like we are done here. But the truth is there is a nasty bug here! The serializer returns the value returned by <code>User#active</code>, not by <code>User#active?</code>!</p>

<h2>What exactly went wrong here?</h2>

<p>The primary thing that went wrongs here was being lazy about the naming and not introducing proper domain concepts. Somehow ActiveRecord made it even easier &ndash; there was already a method called <code>active?</code> defined based on the <code>active</code> column name, so the only thing that was necessary in that case to make our first feature work was overriding it and adding some extra condition because the idea of being &ldquo;active&rdquo; is kind of similar. But overriding boolean methods is never a good idea &ndash; it always implies that some concept is missing or is made implicit in the code.</p>

<h2>A solution to the problem</h2>

<p>A solution would be simply making this domain concept explicit. <code>User#active?</code> method doesn&rsquo;t check if the user is active is not, it rather checks if a user can access the application, so the better name for that method would be <code>User#can_access_application?</code></p>

<p>It is quite possible that we might later need to add some extra features that are related to this feature, like checking if the user is active but cannot access the app or just simply checking the <code>active</code> flag itself. Our final model could look like this in the end:</p>

<p>``` rb</p>

<h1>app/models/users.rb</h1>

<p>class User &lt; ApplicationRecord
  def can_access_application?</p>

<pre><code>active? &amp;&amp; valid_subscription?
</code></pre>

<p>  end</p>

<p>  def cannot_access_application?</p>

<pre><code>!can_access_application?
</code></pre>

<p>  end</p>

<p>  # other methods
end
```</p>

<p>We should also update the serializer:</p>

<p>``` rb</p>

<h1>app/serializers/user.rb</h1>

<p>class UserSerializer
  include JSONAPI::Serializer</p>

<p>  attribute :active do</p>

<pre><code>object.active
</code></pre>

<p>  end</p>

<p>  attribute :can_access_application do</p>

<pre><code>object.can_access_application?
</code></pre>

<p>  end</p>

<p>  attribute :cannot_access_application do</p>

<pre><code>object.cannot_access_application?
</code></pre>

<p>  end
end
```</p>

<p>One could argue that this fix was not necessary and it was a developer&rsquo;s fault, and he or she should have checked the model if this method has not been overridden and adjust the serializer. That is somehow true, but if such code is deployed to production, it probably means that the reviewer of the code was not aware that there is a potential issue in the code and such things are really hard to spot &ndash; ActiveRecord adds those aliases for every boolean column so it might sound like a fair assumption that <code>User#active</code> and <code>User#active?</code> will return the same result.</p>

<p>However, the truth is that not only did we minimize the risk of having the name collisions by those changes but we gained some extra flexibility, and it was quite straight-forward to differentiate between <code>User#active?</code>and <code>User#can_access_application?</code>. In a previous implementation, it was simply not possible with the question-mark methods.</p>

<h2>Wrapping up</h2>

<p>Naming is one of <a href="https://martinfowler.com/bliki/TwoHardThings.html" target="_blank">two hard problems in computer science</a> and it&rsquo;s a good idea to always make all the domain concepts properly named and explicit, even if it means adding more code &ndash; just because something is not explicit, doesn&rsquo;t mean it doesn&rsquo;t exist. When it comes to <strong>ActiveRecord</strong> models, an extra caution is more than recommended &ndash; such models mix both persistence and domain concepts and it&rsquo;s quite easy to hurt yourself in such case. Not overriding boolean methods generated by ActiveRecord and properly naming things sounds like a good rule of thumb to follow.</p>
]]></content>
  </entry>
  
</feed>
