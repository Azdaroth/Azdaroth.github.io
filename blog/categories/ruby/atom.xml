<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2019-01-27T18:32:19+01:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to tell the difference between a default and a provided value for optional arguments in Ruby?]]></title>
    <link href="https://karolgalanciak.com/blog/2019/01/27/how-to-tell-the-difference-between-a-default-and-provided-value-for-optional-arguments-in-ruby/"/>
    <updated>2019-01-27T20:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2019/01/27/how-to-tell-the-difference-between-a-default-and-provided-value-for-optional-arguments-in-ruby</id>
    <content type="html"><![CDATA[<p>It is sometimes required for the methods with optional arguments to be able to differentiate between its default value and the value passed from the caller. Passing <code>nil</code> might initially sound like a good idea since it represents &ldquo;nothingness&rdquo;. However, it might turn out that <code>nil</code> is a legit value and there might be cases where it is desirable for the caller to pass <code>nil</code>. In such a case, we cannot use it as a default value if we want to implement a special logic for the case of not providing that value.</p>

<p>Fortunately, there is an easy way to deal with it &ndash; use a special constant:</p>

<p>``` rb
class SomeClass
  NO_VALUE_PROVIDED = Object.new
  private_constant :NO_VALUE_PROVIDED</p>

<p>  def call(argument: NO_VALUE_PROVIDED)</p>

<pre><code>if argument == NO_VALUE_PROVIDED
  handle_scenario_for_no_value_provided
else
  do_something_with_argument(argument)
end
</code></pre>

<p>  end
end
```</p>

<p>In <code>call</code> method, we allow to pass an optional argument with a default of <code>NO_VALUE_PROVIDED</code>, which is a private constant defined in that class that is an instance of <code>Object</code>.</p>

<p>By depending on the instance of <code>Object</code> that is initialized inside that class, we can avoid cases where the equality check returns <code>true</code> even if this is not an expected outcome, which could happen if we used strings or symbols. We could use some symbol that would be very unlikely to be passed from the caller, like <code>:__no_value_provided__,</code> but it arguably looks more like a workaround than a dedicated solution for the problem.</p>

<p>Also, a private constant ensures it is not used anywhere outside the class, which minimizes the chances that the passed argument would the same as our placeholder for no-value-provided scenario even more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inheritance and define_method - how to make them work together]]></title>
    <link href="https://karolgalanciak.com/blog/2018/12/16/inheritance-and-define-method-how-to-make-them-work-together/"/>
    <updated>2018-12-16T20:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2018/12/16/inheritance-and-define-method-how-to-make-them-work-together</id>
    <content type="html"><![CDATA[<p>Imagine that you are implementing some form object because you are fed up with treating ActiveRecord models as such, and you need some extra flexibility. You start with a straightforward implementation for a base class of a form object where you can just whitelist attributes. That could look like this:</p>

<p>``` rb
class FormObject
  def self.attributes_registry</p>

<pre><code>@attributes_registry ||= []
</code></pre>

<p>  end</p>

<p>  def self.attribute(attribute_name)</p>

<pre><code>attributes_registry &lt;&lt; attribute_name

define_method(attribute_name) do
  instance_variable_get("@#{attribute_name}")
end

define_method("#{attribute_name}=") do |value|
  instance_variable_set("@#{attribute_name}", value)
end
</code></pre>

<p>  end
end
```</p>

<p>Since the base class is ready, you can create a first form object that would inherit from this class:</p>

<p><code>rb
class MyForm &lt; FormObject
  attribute :some_attribute
end
</code></p>

<p>Initially, it does the job, but then it turns out that you might need a default value if <code>some_attribute</code> turns out to be nil. So you try something like that:</p>

<p>``` rb
class MyFormWithDefaultValue &lt; FormObject
  attribute :some_attribute</p>

<p>  def some_attribute</p>

<pre><code>super || "Default"
</code></pre>

<p>  end
end
```</p>

<p>After checking if the default value works, this is what you get:</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValue.new.some_attribute
=> NoMethodError: super: no superclass method `some_attribute' for #&lt;MyFormWithDefaultValue:0x007f84a50ae8e0>
```</p></blockquote>

<p>Whoops! How did it happen? The method was defined in the superclass so it should be inheritable, right?</p>

<p>Well, this is not really true. However, the problem is easy to fix.</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>The primary question we should answer in the first place is: where are all those new methods defined using <code>define_method</code> in that particular way? Is it a superclass?</p>

<p><code>
 FormObject.instance_methods - Object.methods
 =&gt; []
</code></p>

<p>It&rsquo;s definitely not a superclass &ndash; there are no any instance methods defined there, there are only the ones inherited from <code>Object</code>. What about <code>MyFormWithDefaultValue</code>?</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValue.instance_methods &ndash; Object.methods
 => [:some_attribute, :some_attribute=]
```</p></blockquote>

<p>Now the error that we initially got makes way more sense. The entire issue is caused by the fact that the declaration of the attribute happens in <code>MyFormWithDefaultValue</code>, if it were defined in a base class, there would be no any issue. We can verify it with a simple example:</p>

<p>``` rb
class MyForm &lt; FormObject
  attribute :some_attribute
end</p>

<p>class MyFormWithDefaultValue &lt; MyForm
  def some_attribute</p>

<pre><code>super || "Default"
</code></pre>

<p>  end
end
```</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValueA.new.some_attribute
 => &ldquo;Default&rdquo;
```</p></blockquote>

<h2>Solution</h2>

<p>Now that we fully understand the problem let&rsquo;s think about the solution. Ideally, about the one, that doesn&rsquo;t require defining explicitly an intermediate class that we can inherit from.</p>

<p>How about defining a module instead? Modules are also included in the inheritance chain, and for using <code>super</code>, it doesn&rsquo;t matter if the method is defined in the class or a module.</p>

<p>The exact solution to the problem would be wrapping the definition of new methods that happens in <code>FormObject</code> inside some module, it could be even an anonymous one, and including it right away:</p>

<p>```
class FormObject
  def self.attributes_registry</p>

<pre><code>@attributes_registry ||= []
</code></pre>

<p>  end</p>

<p>  def self.attribute(attribute_name)</p>

<pre><code>attributes_registry &lt;&lt; attribute_name

wrapper = Module.new do
  define_method(attribute_name) do
    instance_variable_get("@#{attribute_name}")
  end

  define_method("#{attribute_name}=") do |value|
    instance_variable_set("@#{attribute_name}", value)
  end
end
include wrapper
</code></pre>

<p>  end
end
```</p>

<p>Let&rsquo;s verify if the new solution works:</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValue.new.some_attribute
 => &ldquo;Default&rdquo;</p></blockquote>

<p>```</p>

<p>Yay! It does exactly what we wanted to achieve.</p>

<h2>Wrapping Up</h2>

<p>Metaprogramming in Ruby is a powerful tool, however; it can lead to some issues that might not be obvious why they happen. Fortunately, with enough knowledge of the language, those problems can be solved elegantly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Problems With Validating ActiveRecord Models And Why State Validation Is a Bad Idea]]></title>
    <link href="https://karolgalanciak.com/blog/2018/09/30/the-problems-with-validating-activerecord-models-and-why-state-validation-is-a-bad-idea/"/>
    <updated>2018-09-30T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/09/30/the-problems-with-validating-activerecord-models-and-why-state-validation-is-a-bad-idea</id>
    <content type="html"><![CDATA[<p>In the typical <strong>Rails application</strong>, you can find the most of the validations in the <strong>ActiveRecord models</strong>, which is nothing surprising &ndash; ActiveRecord models are used for multiple things. Whether it is a good thing, or a bad thing (in most cases it&rsquo;s the latter) deserves a separate book or at least blog post-series as it&rsquo;s not a simple problem, there is one specific thing that can cause <strong>a lot of issues</strong> that are <strong>difficult to solve</strong> and go beyond <strong>design decisions</strong> and ease of maintenance of the application, something that impacts the behavior of the model &ndash; <strong>the validations</strong>.</p>

<p>Just to give you a real-world example of what validation in ActiveRecord model looks like (as impossible as it seems, it really did happen) &ndash; when updating the check-in time of the reservation, which is a simple attribute on Reservation model, the record turned out to be invalid because&hellip; the format of guest&rsquo;s phone didn&rsquo;t match some regexp.</p>

<p>There are multiple ways to bypass this problem: use <code>validate: false</code> flag with <code>save</code> method: <code>save(validate: false)</code> or use <code>update_columns</code> method, but this is definitely not something that can be applied in a &ldquo;normal&rdquo; use case. In a typical scenario, this will be the error message displayed in the UI/returned to API consumer, and it will be confusing.</p>

<p>However, this is the expected behavior of ActiveRecord (or in general, ActiveModel-style) validations, which is <strong>a validation of the state</strong> of the model. And judging from this example, it&rsquo;s evident that it leads to <strong>problematic scenarios</strong>. What kind of design then would be the most appropriate to <strong>prevent such issues</strong>?</p>

<!--more-->


<h2>Forget State Validation</h2>

<p>Based on the previous example, it&rsquo;s clear that the real problem is the idea of a model&rsquo;s state validation. And the more complex state of the models can be (especially if there are some cross-validations between several models, which is not uncommon in complex applications), the more problems you will get.</p>

<p>Just wanted to update some <code>notes</code> attribute to add some quick info about something? Forget it &ndash; you will get three different validation errors that will tell you that someone&rsquo;s email has an invalid format, description is too short, a discount amount of something is invalid.</p>

<p>Sadly, this is the typical Rails Way of handling validations. In the initial phase of the application, this is certainly convenient &ndash; adding new validations is super easy, there is no need to discuss the design of potential alternatives and how it fits the bigger picture, and there is very little overhead. Unless you are ok with such problems, at some point, you will probably need to migrate validations to some other solution. What would be the potential alternative for validations?</p>

<h2>Validate The Actual Use Case</h2>

<p>The answer to that question is straight-forward (although it doesn&rsquo;t mean that achieving it will be simple) &ndash; just validate the thing you are doing, the actual use case. If you want to update <code>description</code>, you should only be concerned with the description &ndash; if it&rsquo;s present or not, it&rsquo;s length, etc., whether <code>headline</code> is too short or not (this can happen when you change the validation rules and don&rsquo;t somehow migrate the data) is not the subject of that use case.</p>

<p>There are a lot of implications of such approach &ndash; indeed, it will result in different sets of validators per creation and per update, since for creation we usually need way more data, and for an update, we may merely want to update a single attribute. Effectively, it will result in different validation pipelines for create and update actions. For creating, we may always need to apply specific validators (e.g., presence validators for some attributes), but for updating it will make more sense to apply only the validators for what we are trying to do &ndash; when we want to update email, we apply the presence and format validation for an email, if we want to update a description, we apply presence and length validators for a description.</p>

<h2>Potential Implementation</h2>

<p>What would be the way to implement it? The specific design is out of the scope of this article as it might require building mini-framework for validations and consider some design implications on the entire application (especially if we are escaping the traditional Rails Way). However, one thing is sure here &ndash; there will be dedicated validator objects, probably different for create and update action, and the validations will need to be removed from ActiveRecord models.</p>

<p>A potential way of interacting with such objects could look like this:</p>

<p><code>rb
validation_result = Reservation::CreateValidator.call(params)
if validation_result.success?
  # handle happy path here
else
  puts validation_result.errors.messages # for convenience and familiarity, `errors` object could have a similar interface to ActiveModel::Errors
end
</code></p>

<p>What if we need the model itself in the validator due to some complex business rules, like cross-model validation? We could either reuse <code>id</code> from <code>params</code> or just provide <code>model</code> as an argument:</p>

<p><code>rb
validation_result = Reservation::CreateValidator.call(record, params)
</code></p>

<h2>Side-Effects Of Such Design</h2>

<p>The implications of such design go far deeper than just moving things from one place to another to prevent some edge cases (and naturally increasing the complexity of the design, but it seems to be a fair price to pay for what we get as a result). Since it would make the most sense to have validations per use case, then&hellip; maybe we can have use case as objects that would expose their constraints, and the validators would take the rules from those objects and apply some specific logic on top of it to achieve the desired result? Maybe we could even create value objects composed of a single or multiple attributes, e.g. <code>Client::Email</code> object that would enforce its constraints and also, move some logic specific to the email itself in the context of a hypothetical <code>Client</code> model? And if we can identify the use cases themselves, aren&rsquo;t they domain events? And how hard would it be to build event-based architecture, or even apply Event Sourcing?</p>

<p>These are not trivial questions, however, doing one change in the design opens
the door to a holistic architectural approach where all parts of the domain fit together and the interaction between them is way more intentional comparing to ad hoc duct-tape-like solutions.</p>

<h2>Wrapping Up</h2>

<p>Putting <strong>too much logic</strong> in <strong>ActiveRecord models</strong> has a lot of disadvantages, most of them being problematic on the <strong>design level</strong>. However, things like validations can result in some nasty issues that go beyond the maintenance and cause actual business problems. Fortunately, by keeping that in mind and putting the <strong>validation logic</strong> in a <strong>separate object(s)</strong>, we can easily avoid such issues and as a nice side-effect, have a design that is way more flexible, extendible and eventually simpler to maintain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trolling In Ruby - Implementing JavaScript-like Maths With Implicit Conversion Hijacking]]></title>
    <link href="https://karolgalanciak.com/blog/2018/07/29/trolling-in-ruby-implementing-javascript-like-maths-with-implicit-conversion-hijacking/"/>
    <updated>2018-07-29T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/07/29/trolling-in-ruby-implementing-javascript-like-maths-with-implicit-conversion-hijacking</id>
    <content type="html"><![CDATA[<p>If you&rsquo;ve ever worked with <strong>JavaScript</strong>, especially in <strong>pre-SPA/pre-frameworks</strong> era with just <strong>jQuery</strong>, you probably had a chance to see an &ldquo;exotic&rdquo; maths in action that looks similar to this:</p>

<p><code>javascript
"3" + 4
// =&gt; "34"
</code></p>

<p>That kind of behavior usually comes as a <strong>big surprise</strong> and due to that fact, JavaScript has gotten some <strong>bad reputation</strong> (even though there is a <a href="https://karolgalanciak.com/blog/2017/01/22/javascript-the-surprising-parts/">rationale</a> behind it). If we tried that in <strong>Ruby</strong>, we would get an obvious <code>TypeError</code>:</p>

<p>``` ruby
&ldquo;3&rdquo; + 4</p>

<h1>=> TypeError (no implicit conversion of Integer into String)</h1>

<p>```</p>

<p>Would it be possible though to obtain the same result somehow in Ruby?</p>

<!--more-->


<h2>Explicit Conversion vs. Implicit Conversion</h2>

<p>The answer is yes! But before we get to the actual implementation of that concept, let&rsquo;s make sure that we understand some essential concepts in Ruby that will lead us there: <strong>explicit conversion</strong> and <strong>implicit conversion</strong>.</p>

<p>You&rsquo;ve probably used methods like <code>to_s</code>, <code>to_i</code>, <code>to_d</code>, <code>to_a</code> etc. for <em>explicit</em> typecasting. That way, we can get the closest representation of a given object in a different type.</p>

<p>However, there is also a second type of conversion in Ruby, which is <strong>implicit conversion</strong>.  Those are the methods like <code>to_str</code>, <code>to_int</code>, <code>to_hash</code>, <code>to_ary</code>. In most cases, you should not use those methods unless you are implementing an object that kind of behaves like some type, so, e.g., all numeric objects could (and they actually do!) implement <code>to_int</code> method as they are kind of the same type. For the same reason, if we were implementing some type of collection, we could implement <code>to_ary</code> method that would just return the same result as <code>to_a</code>  which would be an instance of Array, but that we way put extra emphasis on the fact that this object behaves like an array.</p>

<p>We could also take advantage of implicit conversion to put some extra boundaries on the collaborating objects.  Implicit conversion is widely used in Ruby for that purpose. When you are adding a string to a string like this:</p>

<p><code>rb
"3" + "4"
</code></p>

<p>Ruby under the hood calls &ldquo;4&rdquo;.to_str to get the string representation of that object (which is already a string) to make <code>+</code> method more flexible, but at the same time, it makes sure that only string-like objects are permitted as arguments.</p>

<h2>Hijacking Implicit Conversion</h2>

<p>Let&rsquo;s get back to the original problem which was: how to get the following result in Ruby?</p>

<p>``` ruby
&ldquo;3&rdquo; + 4</p>

<h1>=> &ldquo;34&rdquo;</h1>

<p><code>``
Based on what we've just learned about implicit conversion, we just need to make sure that integers become somehow string-like objects. Let's monkey patch</code>Integer<code>class and add</code>to_str<code>method that would be an alias to</code>to_s`:</p>

<p>```
class Integer
  def to_str</p>

<pre><code>to_s
</code></pre>

<p>  end
end
```</p>

<p>Let&rsquo;s try out crazy maths again:</p>

<p><code>ruby
"3" + 4
=&gt; "34"
</code></p>

<p>Try the same for JavaScript and compare the results, it should be exactly the same.</p>

<h2>Wrapping up</h2>

<p><strong>Ruby</strong> is an extremely <strong>flexible</strong> language which makes is it easy to do crazy things, just like it is the case with some operations in <strong>JavaScript</strong> ;).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails And Conditional Validations In Models]]></title>
    <link href="https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models/"/>
    <updated>2018-06-24T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models</id>
    <content type="html"><![CDATA[<p>Adding consents for accepting Terms of Service/Privacy Policies must have been a top popular feature in the majority of the applications due to enforcement of <strong>GDPR</strong> in May ;). From the technical aspects that GDPR requires, there is a proof of consent for processing the personal information. In that case, you need to have some actual attributes in the database that would confirm the fact that some user has indeed accepted Terms of Service/Privacy Policy.</p>

<p>That makes a significant impact on how we approach this kind of features. However, in the past, such things were quite often not stored in a database at all &ndash; it just took some UI <strong>acceptance validation</strong> or maybe a <strong>validation of the virtual attribute</strong> on the backend to be on the safe side.</p>

<p>Let&rsquo;s focus on the latter case where we don&rsquo;t need to store anything in DB and see what the possible solutions to that problems are. As <strong>trivial</strong> as this problem initially sounds, it will get <strong>quite interesting</strong> ;).</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>We want to make sure a user accepts Terms of Service during the signup process and to be sure that it is indeed validated, even if JavaScript validation fails in UI, we want to validate that fact on the backend.</p>

<h2>Solution 1 &ndash; Just add a virtual attribute to the model and validate it</h2>

<p>It is probably the most straightforward approach to that problem and most likely the least elegant. That&rsquo;s how we could implement it:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Well, it does work, no doubt about that. But currently, the validation will always be triggered, even during updates, which doesn&rsquo;t make much sense. We need to find a better solution.</p>

<h2>Solution 2 &ndash; Add a virtual attribute to the model and validate it only during the creation of a user</h2>

<p>A minor improvement over the previous version, we make sure that the validation is not triggered by updates, but only when creating a user:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :create
end
```</p>

<p>Even if it solves the actual problem, there is a big issue about that &ndash; the validation will always be triggered during a creation, even when creating users from factories! What other options do we have?</p>

<h2>Solution 3 &ndash; Add a virtual attribute to the model and validate it only for a specific context</h2>

<p>What is interesting in ActiveModel validations is that <code>on</code> option is not limited to <code>:create</code> or <code>:update</code> contexts &ndash; those are merely the ones that ActiveRecord sets by default depending on the persistence status of the model. We can provide a custom context for both <code>valid?</code> and <code>save</code> methods:</p>

<p><code>rb
user.valid?(:registration)
user.save(context: :registration)
</code></p>

<p>In that case, we could replace <code>:create</code> context with <code>:registration</code> context for the acceptance validation:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :registration
end
```</p>

<p>However, this is still not ideal &ndash; a global model which is used in multiple contexts has some logic that only applies to just one use case, and what is even worse, it&rsquo;s for an UI concern.</p>

<p>Let&rsquo;s try to find a solution that doesn&rsquo;t add any unnecessary mess to a model.</p>

<h2>Solution 4 &ndash; Use form object</h2>

<p>Using form object is probably the cleanest solution to our problem &ndash; we don&rsquo;t introduce any additional concerns to a model which should not be there, and we handle everything in a dedicated object. The are multiple ways how to implement a form object: we could create another ActiveModel model and take advantage of <a href="https://github.com/Azdaroth/active_model_attributes">ActiveModel Attributes</a> to make it smoother. We could use <a href="http://dry-rb.org/gems/dry-validation/basics/working-with-schemas/">dry-validation</a> gem for that. Or we could use my favorite tool for that purpose: <a href="https://github.com/trailblazer/reform">reform</a> gem from <a href="http://trailblazer.to">Trailblazer</a> stack.</p>

<p>Explaining the entire API of <code>reform</code> gem is way beyond the scope of this article, but the following implementation should be quite self-explanatory:</p>

<p>``` rb</p>

<h1>app/forms/user/registration_form.rb</h1>

<p>require &ldquo;reform/form/coercion&rdquo;</p>

<p>class User::RegistrationForm &lt; Reform::Form
  # other property declarations and validations</p>

<p>  property :terms_of_service_accepted, virtual: :true, type: Types::Form::Boolean</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Besides handling other properties (most likely <code>email</code>, <code>password</code> and <code>password confirmation</code>), we are adding a virtual <code>terms_of_service_accepted</code> attribute with explicit type and adding acceptance validation using ActiveModel validator.</p>

<p>Even though using form objects is the cleanest approach, it requires some extra overhead, mostly with the setup, and sometimes it might be painful to add that setup, especially when extending third party&rsquo;s logic, e.g. <a href="https://github.com/scambra/devise_invitable">devise_invitable</a>. In such case, we would need some heavy customization which could potentially break when updating a gem and we would also need extra test coverage for the custom solution. It might still be worth introducing a form object, but it would be a good idea to consider other potential solutions. What option do we have left?</p>

<h2>Solution 5 &ndash; Extend user&rsquo;s instance with a custom logic</h2>

<p>Have you ever heard of DCI (Data Context Interaction) paradigm? If yes, you might have seen something like that:</p>

<p><code>rb
user = User.find(id)
user.extend(User::RegistrationContext)
</code></p>

<p>What this code does is adding extra functionality from <code>User::RegistrationContext</code> module to user&rsquo;s singleton class. Effectively, it means that we are not adding any additional logic to all User class instances, but only to that particular instance. Sounds like exactly what we need! That way, we can solve our problem achieving all the other goals as well &ndash; ease of extending the logic without too much overhead and without making a mess in the model.</p>

<p>Here is how our implementation of <code>User::RegistrationContext</code> context module could look like:</p>

<p>``` rb</p>

<h1>app/models/user/registration_context.rb</h1>

<p>module User::RegistrationContext
  def self.extended(model)</p>

<pre><code>class &lt;&lt; model
  validates :terms_of_service_accepted, acceptance: true
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :terms_of_service_accepted
end
```</p>

<p>The interesting thing about this implementation is that there is some singletons' inception going on there &ndash; first, we are using <code>extend</code> itself on the model, and then, in <code>extended</code> module hook we are opening singleton class of the model and declaring validation there. However, this is necessary since <code>validates</code> method is not defined in the context of that module, and we need to do that in the context of the model.</p>

<p>Let&rsquo;s try our fancy solution in action:</p>

<p><code>rb
user = User.new
user.extend(User::RegistrationContext)
user.terms_of_service_accepted = "0"
user.valid?
=&gt; false
user.errors.messages[:terms_of_service_accepted]
=&gt; ["must be accepted"]
</code></p>

<p>Perfect, that&rsquo;s exactly what we needed!</p>

<h2>Wrapping Up</h2>

<p>There are multiple ways in Rails (or Ruby in general) to handle <strong>conditional validation</strong>, and thanks to the flexibility of the framework and the language, we can pick whatever seems best for our particular problem &ndash; from adding additional validations in a model with <strong>extra ActiveModel context</strong>, through using <strong>form objects</strong>, ending with arcane DCI-style object&rsquo;s extensions.</p>
]]></content>
  </entry>
  
</feed>
