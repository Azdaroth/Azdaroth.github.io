<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Capistrano | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/capistrano/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2019-05-03T15:11:55+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails applications deployment with Capistrano and after deployment setup]]></title>
    <link href="https://karolgalanciak.com/blog/2013/08/02/app-deployment-with-capistrano-and-after-deployment-setup/"/>
    <updated>2013-08-02T14:15:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2013/08/02/app-deployment-with-capistrano-and-after-deployment-setup</id>
    <content type="html"><![CDATA[<p>You've just setup your production server, but still haven't deployed your app? Then this the right place for you. You are going to learn how to deploy your app to remote server, deal with some config files, create staging environment and setup monitoring tools.</p>




<!--more-->


<p></p>

<h2>Introducing Capistrano</h2>




<p>Capistrano is an excellent tool to automate your deployment process using Rake DSL. It allows you to deploy applications using various source control management systems like Git, run migrations on remote server, restart application and many more.</p>




<h2>Application setup</h2>




<p>Let's start with creating Rails application: </p>


<p><code>bash
rails new dummy_app
</code></p>

<p>add <code>capistrano</code>, <code>capistrano-ext</code>, <code>rvm-capistrano</code> (for RVM integration) and <code>pg</code> gems(for Postgres database) to your Gemfile:</p>


<p><code>ruby Gemfile
gem 'pg'
gem 'capistrano'
gem 'rvm-capistrano'
gem 'capistrano-ext'
</code></p>

<p><b>NOTE:</b> When writing this article, the current Capistrano version was 2.15.5 which I believe is buggy as I had some problems with authentication while deploying. If you have the same problem, use 2.15.3 version instead.</p>




<p>You should also uncomment this line: </p>


<p><code>ruby Gemfile
gem 'therubyracer', platforms: :ruby
</code></p>

<p>And run bundle install.</p>




<h2>Is my app secure?</h2>




<p>Well, it depends. If you are the only person working on it, then you are safe. But if you aren't, then your session secret is available to other people, which makes your app vulnerable to <a href="http://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/" target="_blank">carefully crafted attacks</a> and you should exclude it from your code repository. Initialize git repository in your application:</p>


<p><code>bash
git init
</code></p>

<p>And add to your <code>.gitignore</code> file the following line:</p>


<p><code>bash .gitignore
/config/initializers/secret_token.rb
</code></p>

<h2>Database and staging environment config</h2>




<p>Now, edit database configuration file (<code>config/database.yml</code>), so it looks similar to this:</p>


<p>``` yaml config/database.yml
development:
  adapter: postgresql
  host: localhost
  database: dummy_app_test
  username: dummy_app_user
  password: my-secret-password</p>

<p>test:
  adapter: postgresql
  host: localhost
  database: dummy_app_test
  username: dummy_app_user
  password: my-secret-password</p>

<p>production:
  adapter: postgresql
  host: localhost
  database: dummy_app_production
  username: dummy_app_user
  password: my-secret-password</p>

<p>staging:
  adapter: postgresql
  host: localhost
  database: dummy_app_production
  username: dummy_app_user
  password: my-secret-password
```</p>

<p>There is one extra thing in this config: the staging environment. We are going to use pre-production environment for testing purposes. If you want to share the same database between production and staging, then leave this config as it is.</p>




<p>You should also exclude <code>database.yml</code> from your code repository, not only for keeping your passwords secret, but also to prevent overriding local configuration when fetching code from repository - add to <code>.gitignore</code> file:</p>


<p><code>bash
/config/database.yml
</code></p>

<p>Staging environment should be close to production as much as possible, so copy the production.rb file and rename it to staging.rb: </p>


<p><code>bash
cp config/environments/production.rb config/environments/staging.rb
</code></p>

<h2>Capistrano configuration</h2>




<p>To create configuration files, run</p>


<p><code>bash
capify .
</code></p>

<p>It will create two files: <code>config/deploy.rb</code> and <code>Capfile</code>. Start with editing <code>Capfile</code> and uncomment this line:</p>


<p><code>ruby Capfile
load 'deploy/assets'
</code></p>

<p>Next, open the <code>deploy.rb</code> remove the default content, copy & paste the script below and adjust it according to the comments.</p>


<p>``` ruby config/deploy.rb
require &ldquo;bundler/capistrano&rdquo;
require &lsquo;capistrano/ext/multistage&rsquo;
require &ldquo;rvm/capistrano&rdquo;</p>

<h1>General</h1>

<p>set :keep_releases, 5 # or any other number of releases you would like to keep
ssh_options[:port] = 12345 # if you haven&rsquo;t changed anything in SSH config, set it to 22
ssh_options[:forward_agent] = true # forward ssh keys
default_run_options[:pty] = true # set for the password prommpt</p>

<p>set :application, &ldquo;dummy_app&rdquo; # set the name of you application here
set :user, &ldquo;deploy&rdquo; # and the server user name</p>

<p>set :stages, [&ldquo;staging&rdquo;, &ldquo;production&rdquo;] # Set staging and production environment
set :default_stage, &ldquo;staging&rdquo; # Use staging environment as the default one to prevent accidentally deploying to production</p>

<p>set :deploy_via, :remote_cache # it will only fetch from the repository on server, not clone the entire repository from scratch</p>

<p>set :use_sudo, false # do not use sudo</p>

<h1>Git</h1>

<p>set :scm, :git # set git as a Source Code Manager
set :repository,  &ldquo;ssh://deploy@your.ip.goes.here:port/home/#{user}/repos/#{application}.git&rdquo; # point your repository here</p>

<p>set :branch, &ldquo;master&rdquo; # set git branch here</p>

<h1>Server</h1>

<p>role :web, &ldquo;server.ip.goes.here&rdquo; # HTTP Server
role :app, &ldquo;server.ip.goes.here&rdquo; # server with your app
role :db,  &ldquo;server.ip.goes.here&rdquo;, :primary => true # database server
role :db,  &ldquo;server.ip.goes.here&rdquo;</p>

<h1>Passenger</h1>

<p>namespace :deploy do
 task :start do ; end
 task :stop do ; end
 task :restart, :roles => :app do # restart your app after finalizing deployment
   run &ldquo;touch #{current_path}/tmp/restart.txt&rdquo;
 end
end</p>

<h1>Symlinking</h1>

<p>namespace :deploy do
  task :symlink_db, :roles => :app do</p>

<pre><code>run "ln -nfs #{deploy_to}/shared/config/database.yml #{release_path}/config/database.yml" # This file is not included repository, so we will create a symlink 
</code></pre>

<p>  end
  task :symlink_secret_token, :roles => :app do</p>

<pre><code>run "ln -nfs #{deploy_to}/shared/config/initializers/secret_token.rb #{release_path}/config/initializers/secret_token.rb" # This file is not included repository, so we will create a symlink 
</code></pre>

<p>  end
end</p>

<p>before &lsquo;deploy:assets:precompile&rsquo;, &lsquo;deploy:symlink_db&rsquo; # callback: run this task before deploy:assets:precompile
before &lsquo;deploy:assets:precompile&rsquo;, &lsquo;deploy:symlink_secret_token&rsquo; # # callback: run this task before deploy:assets:precompile
after &ldquo;deploy&rdquo;, &ldquo;deploy:cleanup&rdquo; # delete old releases
```</p>

<p>Now, create <code>deploy</code> directory in <code>config</code> directory and add <code>production.rb</code> and <code>staging.rb</code> files there. You have to specify paths, where the production and staging app instance will be deployed. Let's edit the <code>production.rb</code> file:</p>


<p><code>ruby config/deploy/production.rb
set :deploy_to, "/home/deploy/rails_projects/dummy_app"
</code></p>

<p>and <code>staging.rb</code>:</p>


<p><code>ruby config/deploy/production.rb
set :deploy_to, "/home/deploy/rails_projects/dummy_app_staging"
</code></p>

<p>That's a basic configuration that should be sufficient in most cases. But Capistrano is a really sophisticated tool, you can specify diffrent servers for staging and production environment, diffrent git branches, diffrent repositories and many more. Just specify different settings in <code>production.rb</code> and <code>staging.rb</code> if you need to.</p>




<h2>Deployment</h2>




<p>Before deploying your app, you have to setup git repository. We will create just an empty repo in <code>/home/deploy/repos</code> directory on remote server: </p>


<p><code>bash
ssh your-server "mkdir /home/deploy/repos &amp;&amp; mkdir /home/deploy/repos/dummy_app.git  &amp;&amp; git init --bare /home/deploy/repos/dummy_app.git"
</code></p>

<p>Keeping the Git repositories on deploy user might not be the best idea, especially when you want to give other people access to the repo, but it sufficient for demonstration purposes. In other cases, you should rather create seperate git user with a limited shell (git-shell) or use some sophisticated tools like Gitolite if you need to.</p>




<p>Now we can commit all changes and deploy our application:</p>


<p><code>bash
git add --all
git commit -am "Setup deployment configuration"
git remote add origin ssh://deploy@your.ip.goes.here:port/home/deploy/repos/dummy_app.git
git push origin master
</code></p>

<p>You are ready to deploy our application, but before that you need to setup databases and http server configuration. If you have any problem, check <a href="http://karolgalanciak.com/blog/2013/07/19/centos-6-4-server-setup-with-ruby-on-rails-nginx-and-postgresql/" target="_blank">this one</a> out (remember about specifying appropriate rails_env). Firstly, let the Capistrano deal with creating all the neccessary directories in both staging and production environments:</p>


<p><code>bash
cap deploy:setup
cap production deploy:setup
</code></p>

<p>Then check if directory permissions, utilities and other dependencies are correct:</p>


<p><code>bash
cap deploy:check
cap production deploy:check
</code></p>

<p>In both cases you should have output ending with: <i>You appear to have all necessary dependencies installed.</i></p>




<p>The last thing before deployment: we haven't included <code>secret_token.rb</code> and <code>database.yml</code> files in repo, so we have to copy them on remote server:</p>


<p><code>bash
scp config/database.yml you-server:/home/deploy &amp;&amp; scp config/initializers/secret_token.rb your-server:/home/deploy
ssh your_server "mkdir /home/deploy/rails_projects/dummy_app/shared/config &amp;&amp; mkdir /home/deploy/rails_projects/dummy_app_staging/shared/config"
ssh your_server "mkdir /home/deploy/rails_projects/dummy_app/shared/config/initializers &amp;&amp; mkdir /home/deploy/rails_projects/dummy_app_staging/shared/config/initializers"
ssh you_server "cp /home/deploy/database.yml /home/deploy/rails_projects/dummy_app/shared/config/database.yml &amp;&amp; mv /home/deploy/database.yml /home/deploy/rails_projects/dummy_app_staging/shared/config/database.yml"
ssh you_server "cp /home/deploy/secret_token.rb /home/deploy/rails_projects/dummy_app/shared/config/initializers/secret_token.rb &amp;&amp; mv /home/deploy/secret_token.rb /home/deploy/rails_projects/dummy_app_staging/shared/config/initializers/secret_token.rb"
</code></p>

<p>And you can deploy your application. Instead of <code>cap deploy</code>, use <code>cap deploy:cold</code> and <code>cap production deploy:cold</code> - it will deploy the app, run all migrations and run deploy start instead of <code>cap:restart</code>.</p>


<p><code>bash
cap deploy:cold
cap production deploy:cold
</code></p>

<p>Done! You have just deployed your application. Next time use cap deploy or <code>cap deploy:migrations</code> to run migrations.</p>




<h2>Monitoring with Monit</h2>




<p>How do you know if everything is running correctly after deployment? Well, you don't know, unless you install a monitoring tool. Monit is a great and easy to configure utility for managing and monitoring processes. Let's start with installing Monit on remote server (I use CentOS Linux, there are some differences between distros, so the location of the files might be diffrent, e.g. on Debian, the configuration file is in <code>/etc/monit/monit.rc</code>):</p>


<p><code>bash
sudo yum install monit
</code></p>

<p>and edit the configuration file:</p>


<p><code>bash
sudo vi /etc/monit.conf
</code></p>

<p>Read carefully all the comments to get familiar with Monit. Then specify your configuration, e.g.:</p>


<p>``` bash</p>

<h1>check services every minute</h1>

<p>set daemon 60</p>

<h1>monitor nginx</h1>

<p>check process nginx with pidfile /opt/nginx/logs/nginx.pid
  start program = &ldquo;/etc/init.d/nginx start&rdquo;
  stop program  = &ldquo;/etc/init.d/nginx stop&rdquo;</p>

<h1>monitor postgres</h1>

<p>check process postgres with pidfile /var/lib/pgsql/9.2/data/postmaster.pid
  start program = &ldquo;/etc/init.d/postgresql start&rdquo;
  stop  program = &ldquo;/etc/init.d/postgresql stop&rdquo;</p>

<h1>web interface setup</h1>

<p>set httpd port 2812 and
  use address localhost
  allow username:&ldquo;password&rdquo; # specify username and password for http basic authentication
  allow localhost
  allow @monit
```</p>

<p>There are a lot of available Monit recipies, e.g. <a href="http://mmonit.com/wiki/Monit/ConfigurationExamples" target="_blank">here</a>, so it is quite easy to setup. When you finish, restart Monit:</p>


<p><code>bash
sudo monit reload
</code></p>

<p>Or if you haven't started it yet:</p>


<p><code>bash
sudo monit
</code></p>

<p>To check status of processes being monitored, run: </p>


<p><code>bash
sudo monit status
</code></p>

<p>You don't have to ssh on your server everytime you want to check the status, Monit comes with a very nice web interface. Here is a simple Nginx configuration, so that you will be able to access Monit via your-ip:1111/monit address:</p>


<p>``` bash
server {
  listen 1111;
  server_name localhost;</p>

<p>  location /monit/ {</p>

<pre><code>proxy_pass http://127.0.0.1:2812/; # pass query to backend, replace /monit/ uri part to just /
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
</code></pre>

<p>  }
}
```</p>

<p>Use password and username specified in Monit configuration.</p>




<h2>Logrotate</h2>




<p>After some time your Rails app logs and especially Nginx logs might be really large, so it is a good idea to somehow manage them. Fortunately, you can use system-built utility called Logrotate. Just open <code>/etc/logrotate.conf</code> and paste the configuration below (remember about changing path to your application):</p>


<p>``` bash</p>

<p>/home/deploy/rails_projects/your_app_name/shared/log/*.log {
  daily
  rotate 30
  missingok
  compress
  notifempty
  delaycompress
  sharedscripts
  copytruncate
}
￼￼￼￼￼￼￼￼￼￼￼￼</p>

<p>/opt/nginx/logs/*.log {
  daily
  rotate 30
  compress
  missingok
  notifempty
  delaycompress
  sharedscripts</p>

<p>  postrotate</p>

<pre><code>[ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`
</code></pre>

<p>  endscript }</p>

<p>```</p>

<p>Here is the options explanation:</p>




<ul>
<li><b>daily</b> - rotate the logs every day</li>
<li><b>rotate 30</b> - rotate logs 30 times, after that delete the oldest</li>
<li><b>missingok</b> - ignore if the file doesn't exist</li>
<li><b>compress</b> - compress logs with gzip</li>
<li><b>notifempty</b> - leave file if the logs are empty</li>
<li><b>delaycompress</b> - postpone compression of the file to the next cycle</li>
<li><b>sharedscripts</b> - tell only once that the logs have been rotated, not several times for every group</a></li>
<li><b>copytruncate</b> - copy the log file and and truncate the original one</li>
<li><b>postrotate [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid` endscript</b> - tell Nginx that the logs have been rotated and use the new ones.</li>
</ul>




<p>And that's is it! Cron by default runs logrotate every day.</p>



]]></content>
  </entry>
  
</feed>
