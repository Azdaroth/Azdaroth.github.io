<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: quick tips | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/quick-tips/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2019-06-23T18:13:53+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Inheritance and define_method - how to make them work together]]></title>
    <link href="https://karolgalanciak.com/blog/2018/12/16/inheritance-and-define-method-how-to-make-them-work-together/"/>
    <updated>2018-12-16T20:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2018/12/16/inheritance-and-define-method-how-to-make-them-work-together</id>
    <content type="html"><![CDATA[<p>Imagine that you are implementing some form object because you are fed up with treating ActiveRecord models as such, and you need some extra flexibility. You start with a straightforward implementation for a base class of a form object where you can just whitelist attributes. That could look like this:</p>

<p>``` rb
class FormObject
  def self.attributes_registry</p>

<pre><code>@attributes_registry ||= []
</code></pre>

<p>  end</p>

<p>  def self.attribute(attribute_name)</p>

<pre><code>attributes_registry &lt;&lt; attribute_name

define_method(attribute_name) do
  instance_variable_get("@#{attribute_name}")
end

define_method("#{attribute_name}=") do |value|
  instance_variable_set("@#{attribute_name}", value)
end
</code></pre>

<p>  end
end
```</p>

<p>Since the base class is ready, you can create a first form object that would inherit from this class:</p>

<p><code>rb
class MyForm &lt; FormObject
  attribute :some_attribute
end
</code></p>

<p>Initially, it does the job, but then it turns out that you might need a default value if <code>some_attribute</code> turns out to be nil. So you try something like that:</p>

<p>``` rb
class MyFormWithDefaultValue &lt; FormObject
  attribute :some_attribute</p>

<p>  def some_attribute</p>

<pre><code>super || "Default"
</code></pre>

<p>  end
end
```</p>

<p>After checking if the default value works, this is what you get:</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValue.new.some_attribute
=> NoMethodError: super: no superclass method `some_attribute' for #&lt;MyFormWithDefaultValue:0x007f84a50ae8e0>
```</p></blockquote>

<p>Whoops! How did it happen? The method was defined in the superclass so it should be inheritable, right?</p>

<p>Well, this is not really true. However, the problem is easy to fix.</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>The primary question we should answer in the first place is: where are all those new methods defined using <code>define_method</code> in that particular way? Is it a superclass?</p>

<p><code>
 FormObject.instance_methods - Object.methods
 =&gt; []
</code></p>

<p>It&rsquo;s definitely not a superclass &ndash; there are no any instance methods defined there, there are only the ones inherited from <code>Object</code>. What about <code>MyFormWithDefaultValue</code>?</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValue.instance_methods &ndash; Object.methods
 => [:some_attribute, :some_attribute=]
```</p></blockquote>

<p>Now the error that we initially got makes way more sense. The entire issue is caused by the fact that the declaration of the attribute happens in <code>MyFormWithDefaultValue</code>, if it were defined in a base class, there would be no any issue. We can verify it with a simple example:</p>

<p>``` rb
class MyForm &lt; FormObject
  attribute :some_attribute
end</p>

<p>class MyFormWithDefaultValue &lt; MyForm
  def some_attribute</p>

<pre><code>super || "Default"
</code></pre>

<p>  end
end
```</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValueA.new.some_attribute
 => &ldquo;Default&rdquo;
```</p></blockquote>

<h2>Solution</h2>

<p>Now that we fully understand the problem let&rsquo;s think about the solution. Ideally, about the one, that doesn&rsquo;t require defining explicitly an intermediate class that we can inherit from.</p>

<p>How about defining a module instead? Modules are also included in the inheritance chain, and for using <code>super</code>, it doesn&rsquo;t matter if the method is defined in the class or a module.</p>

<p>The exact solution to the problem would be wrapping the definition of new methods that happens in <code>FormObject</code> inside some module, it could be even an anonymous one, and including it right away:</p>

<p>```
class FormObject
  def self.attributes_registry</p>

<pre><code>@attributes_registry ||= []
</code></pre>

<p>  end</p>

<p>  def self.attribute(attribute_name)</p>

<pre><code>attributes_registry &lt;&lt; attribute_name

wrapper = Module.new do
  define_method(attribute_name) do
    instance_variable_get("@#{attribute_name}")
  end

  define_method("#{attribute_name}=") do |value|
    instance_variable_set("@#{attribute_name}", value)
  end
end
include wrapper
</code></pre>

<p>  end
end
```</p>

<p>Let&rsquo;s verify if the new solution works:</p>

<p>```</p>

<blockquote><p>MyFormWithDefaultValue.new.some_attribute
 => &ldquo;Default&rdquo;</p></blockquote>

<p>```</p>

<p>Yay! It does exactly what we wanted to achieve.</p>

<h2>Wrapping Up</h2>

<p>Metaprogramming in Ruby is a powerful tool, however; it can lead to some issues that might not be obvious why they happen. Fortunately, with enough knowledge of the language, those problems can be solved elegantly.</p>
]]></content>
  </entry>
  
</feed>
