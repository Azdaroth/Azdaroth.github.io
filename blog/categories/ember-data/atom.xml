<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ember Data | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/ember-data/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2018-12-09T19:46:51+01:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Ember Data Customization - Different Model Types in Ember App and API For The Same Resource]]></title>
    <link href="https://karolgalanciak.com/blog/2018/04/28/advanced-ember-data-customization-different-model-types-in-ember-app-and-api-for-the-same-resource/"/>
    <updated>2018-04-28T19:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/04/28/advanced-ember-data-customization-different-model-types-in-ember-app-and-api-for-the-same-resource</id>
    <content type="html"><![CDATA[<p>A <strong>great advantage</strong> of using <strong>Ember Data</strong> with <strong>JSONAPI-compliant</strong> adapters/serializers is that there is almost nothing extra needed to work with the <strong>data layer</strong> &ndash; just create the models with names matching the types of the resources returned by the <strong>API</strong> and you are good to go! However, sometimes you may need to customize the naming which means that the names of the models in the <strong>Ember application</strong> will be different than the ones expected by the API and their corresponding types. What are the steps required to make it work in <strong>Ember Data</strong>?</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Imagine that the API you work with has two resources: <code>User</code> and <code>Picture</code> and that a User can have many Pictures. However, in the Ember application, you want to have these resources named as <code>Photographer</code> and <code>Photo</code>. Here are the models and relationships between them:</p>

<p>``` js
// app/models/photographer.js
import Model from &lsquo;ember-data/model&rsquo;;
import { hasMany } from &lsquo;ember-data/relationships&rsquo;;</p>

<p>export default Model.extend(MessageSender, {
  photos: hasMany(&lsquo;photo&rsquo;)
});
```</p>

<p>``` js
// app/models/photo.js
import Model from &lsquo;ember-data/model&rsquo;;
import { belongsTo } from &lsquo;ember-data/relationships&rsquo;;</p>

<p>export default Model.extend({
  photographer: belongsTo(&lsquo;photographer&rsquo;)
});
```</p>

<h2>The Solution</h2>

<p>Unfortunately, models' names don&rsquo;t follow the naming expected by the API. There are a couple of things that we need to customize here:</p>

<ol>
<li>Endpoints for a given resource &ndash; by default, for <code>Photographer</code> model, all requests will be performed to <code>/photographers</code> endpoint. We need to make it work with <code>/users</code> endpoint. Same thing with <code>Photo</code> model.</li>
<li>Serialization of the models &ndash; for <code>Photographers</code> we will need to make sure that <code>users</code> type is present in the payload, not <code>photographers</code> and the same thing for <code>pictures</code> vs. <code>photos</code>.</li>
<li>Normalization of the payload from the API &ndash; we need to map <code>user</code> type to <code>photographer</code> and <code>picture</code> type to <code>photo</code>.</li>
<li>Handle the relationship between <code>Photographer</code> and <code>Photo</code> with proper types.</li>
</ol>


<p>Let&rsquo;s handle each case one by one.</p>

<p>The first one is quite straightforward &ndash; we need to adjust adapters for both models. According to the <a href="https://guides.emberjs.com/v3.0.0/models/customizing-adapters/#toc_path-customization">docs</a>, <code>pathForType</code> method is the one that we care about. Since we are just going to change the type, not the actual logic that happens to that type later, we can handle these adjustments the following way:</p>

<p>``` js
// app/adapters/application.js
import DS from &lsquo;ember-data&rsquo;;</p>

<p>export default DS.JSONAPIAdapter.extend();
```</p>

<p>``` js
// app/adapters/photographer.js
import ApplicationAdapter from &lsquo;./application&rsquo;;</p>

<p>export default ApplicationAdapter.extend({
  pathForType() {</p>

<pre><code>return this._super('user');
</code></pre>

<p>  }
});
```</p>

<p>``` js
// app/adapters/photo.js
import ApplicationAdapter from &lsquo;./application&rsquo;;</p>

<p>export default ApplicationAdapter.extend({
  pathForType() {</p>

<pre><code>return this._super('picture');
</code></pre>

<p>  }
});
```</p>

<p>The first part is done. Let&rsquo;s focus now on the serialization. After a bit of research of the docs and the source code, it looks like <code>payloadKeyFromModelName</code> needs to be customized. In this case, we just want to make sure that <code>photographer</code> type is mapped to <code>user</code>, and <code>photo</code> is mapped to <code>picture</code>. As this is arguably a less straightforward change than overriding <code>pathForType</code> in adapters, it might make sense to write some unit tests for that. Fortunately, it&rsquo;s nothing too complex &ndash; just comparing the serialization result with the expected one. Let&rsquo;s write a test for <code>ApplicationSerializer</code>:</p>

<p>``` js
// tests/unit/serializers/application-test.js
import { module, test } from &lsquo;qunit&rsquo;;
import { setupTest } from &lsquo;ember-qunit&rsquo;;
import { run } from &lsquo;@ember/runloop&rsquo;;</p>

<p>module(&lsquo;Unit | Serializer | application&rsquo;, function(hooks) {
  setupTest(hooks);</p>

<p>  module(&lsquo;serialize&rsquo;, function() {</p>

<pre><code>module('photographer', function() {
  test('it is serialized according to remapped naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');

    run(() =&gt; {
      let model = store.createRecord('photographer', {});
      let payload = model.serialize();

      assert.equal(payload.data.type, 'users');
    });
  });
});

module('photo', function() {
  test('it is serialized according to its naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');

    run(() =&gt; {
      let model = store.createRecord('photo', {});
      let payload = model.serialize();

      assert.equal(payload.data.type, 'pictures');
    });
  });
});
</code></pre>

<p>  });
});
```</p>

<p>Since we are interested only in a type remapping, we don&rsquo;t check the entire payload, only <code>type</code> attribute. Let&rsquo;s make these tests pass by either remapping types or using the default logic:</p>

<p>``` js
// app/serializers/application.js
import DS from &lsquo;ember-data&rsquo;;</p>

<p>const keysMappingForSerialization = {
  &lsquo;photographer&rsquo;: &lsquo;user&rsquo;,
  &lsquo;photo&rsquo;: &lsquo;picture&rsquo;
};</p>

<p>export default DS.JSONAPISerializer.extend({
  payloadKeyFromModelName(key) {</p>

<pre><code>if (keysMappingForSerialization[key]) {
  return this._super(keysMappingForSerialization[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>Awesome, we are almost there.</p>

<p>Both third and fourth points are actually about normalization, so we are going to handle them together. Again, after some research, it looks like we need to customize <code>modelNameFromPayloadKey</code> to map types returned by API to corresponding types in our app and also override <code>keyForRelationship</code> method to handle relationships in the payload correctly. Again, let&rsquo;s start with some tests. The simplest way to test such things is checking the result of <a href="https://emberjs.com/api/ember-data/3.0/classes/DS.JSONAPISerializer/methods/normalizeResponse?anchor=normalizeResponse">normalizeResponse</a> for some request type, e.g., for &lsquo;findAll&rsquo;. Let&rsquo;s write a test for a more complex scenario including relationships and sideloading as well:</p>

<p>``` js
// tests/unit/serializers/application-test.js
import { module, test } from &lsquo;qunit&rsquo;;
import { setupTest } from &lsquo;ember-qunit&rsquo;;
import { run } from &lsquo;@ember/runloop&rsquo;;</p>

<p>module(&lsquo;Unit | Serializer | application&rsquo;, function(hooks) {
  setupTest(hooks);</p>

<p>  module(&lsquo;serialize&rsquo;, function() {</p>

<pre><code>// previous tests
</code></pre>

<p>  });</p>

<p>  module(&lsquo;normalizeResponse&rsquo;, function() {</p>

<pre><code>module('photographer', function() {
  test('it is normalized according to remapped naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');
    let serializer = store.serializerFor('photographer');

    run(() =&gt; {
      let payload = {
        'data': {
          'type': 'users',
          'id': '1',
          'attributes': {},
          'relationships': {
            'pictures': {
              'links': {
                'self': 'https://host.test/api/v1/users/1/relationships/pictures',
                'related': 'https://host.test/api/v1/users/1/pictures'
              },
              'data': [{ 'type': 'pictures', 'id': '10' }]
            }
          }
        },
        'included': [
          {
            'type': 'pictures',
            'id': '10',
            'attributes': {},
            'links': {
              'self': 'https://host.test/api/v1/pictures/10'
            }
          }
        ]
      };

      let normalizedPayload = serializer.normalizeResponse(store, store.modelFor('photographer'),
        payload, 1, 'findAll');
      let expectedPayload = {
        'data': {
          'attributes': {},
          'id': '1',
          'relationships': {
            'emails': {
              'data': [
                { 'id': '10', 'type': 'photos' }
              ],
              'links': {
                'self': 'https://host.test/api/v1/users/1/relationships/pictures',
                'related': 'https://host.test/api/v1/users/1/pictures'
              }
            }
          },
          'type': 'photographer'
        },
        'included': [
          {
            'attributes': {},
            'id': '10',
            'relationships': {},
            'type': 'photo'
          }
        ]
      };

      assert.deepEqual(normalizedPayload, expectedPayload);
    });
  });
});

module('photo', function() {
  test('it is normalized according to remapped naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');
    let serializer = store.serializerFor('photo');

    run(() =&gt; {
      let payload = {
        'data': {
          'type': 'pictures',
          'id': '1',
          'attributes': {},
          'relationships': {
            'user': {
              'links': {
                'self': 'https://host.test/api/v1/pictures/1/relationships/user',
                'related': 'https://host.test/api/v1/pictures/1/user'
              },
              'data': { 'type': 'users', 'id': '10' }
            }
          }
        },
        'included': [
          {
            'type': 'users',
            'id': '10',
            'attributes': {},
            'links': {
              'self': 'https://host.test/api/v1/users/10'
            }
          }
        ]
      };

      let normalizedPayload = serializer.normalizeResponse(store, store.modelFor('photo'),
        payload, 1, 'findAll');
      let expectedPayload = {
        'data': {
          'attributes': {},
          'id': '1',
          'relationships': {
            'photographer': {
              'data': { 'id': '10', 'type': 'photographer' },
              'links': {
                'related': 'https://host.test/api/v1/pictures/1/user',
                'self': 'https://host.test/api/v1/pictures/1/relationships/user'
              }
            }
          },
          'type': 'photo'
        },
        'included': [
          {
            'attributes': {},
            'id': '10',
            'relationships': {},
            'type': 'photographer'
          }
        ]
      };

      assert.deepEqual(normalizedPayload, expectedPayload);
    });
  });
});
</code></pre>

<p>  });
});
```</p>

<p>First, let&rsquo;s make it work with nonrelationship-related part, i.e. <code>modelNameFromPayloadKey</code> customization:</p>

<p>``` js
// app/serializers/application.js
import DS from &lsquo;ember-data&rsquo;;</p>

<p>const keysMappingForSerialization = {
  &lsquo;photographer&rsquo;: &lsquo;user&rsquo;,
  &lsquo;photo&rsquo;: &lsquo;picture&rsquo;
};</p>

<p>const keysMappingForNormalization = {
  &lsquo;users&rsquo;: &lsquo;photographers&rsquo;,
  &lsquo;pictures&rsquo;: &lsquo;photos&rsquo;
};</p>

<p>export default DS.JSONAPISerializer.extend({});
  payloadKeyFromModelName(key) {</p>

<pre><code>if (keysMappingForSerialization[key]) {
  return this._super(keysMappingForSerialization[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  },</p>

<p>  modelNameFromPayloadKey(modelName) {</p>

<pre><code>if (keysMappingForNormalization[modelName]) {
  return this._super(keysMappingForNormalization[modelName]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>Again, the same pattern as before &ndash; for whitelisted types we want to remap them and apply the default logic for the rest of the types.</p>

<p>And to handle the relationships we can customize the serializers separately:</p>

<p>``` js
// app/serializers/photographer.js
import ApplicationSerializer from &lsquo;./application&rsquo;;</p>

<p>const keysForRelationshipsMapping = {
  &lsquo;photographer&rsquo;: &lsquo;user&rsquo;
};</p>

<p>export default ApplicationSerializer.extend({
  keyForRelationship(key) {</p>

<pre><code>if (keysForRelationshipsMapping[key]) {
  return this._super(keysForRelationshipsMapping[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>``` js
// app/serializers/photo.js
import ApplicationSerializer from &lsquo;./application&rsquo;;</p>

<p>const keysForRelationshipsMapping = {
  &lsquo;photo&rsquo;: &lsquo;picture&rsquo;
};</p>

<p>export default ApplicationSerializer.extend({
  keyForRelationship(key) {</p>

<pre><code>if (keysForRelationshipsMapping[key]) {
  return this._super(keysForRelationshipsMapping[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>And that&rsquo;s it! All our tests are green, and the models are going to work with the API!</p>

<h2>Wrapping Up</h2>

<p>Thanks to a <strong>solid design</strong> of <strong>Ember Data</strong>, it&rsquo;s quite simple to customize the <strong>data layer</strong> which in most cases requires merely overriding a couple of methods.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing non-RESTful actions with Ember Data]]></title>
    <link href="https://karolgalanciak.com/blog/2016/02/07/implementing-non-restful-actions-with-ember-data/"/>
    <updated>2016-02-07T10:45:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2016/02/07/implementing-non-restful-actions-with-ember-data</id>
    <content type="html"><![CDATA[<p>In my <a target="_blank" href="http://karolgalanciak.com/blog/2016/01/24/how-to-handle-non-crud-logic-in-your-api/">recent post</a> I mentioned some strategies of handling non-strictly <strong>CRUD</strong> / <strong>RESTful</strong> actions in <strong>API</strong>. One of them was adding extra actions beyond creating, updating and deleting resources. As it's not a standard solution and some data layers on client side (like <strong>Ember Data</strong>) don't handle it out-of-box, I was asked by some developers what's the best way to handle such actions. So let's see how can we hack into <strong>Ember Data</strong> and make it smooth.</p>




<!--more-->




<h2>Our use case: publishing articles</h2>




<p>Let's reuse the example from the previous blog post - the articles and publishing process. What we are going to do is to add <code>publish</code> function to our <code>Article</code> model, which simply sends <code>PATCH</code> request to <strong>API</strong> endpoint with <code>/api/articles/:id/publish</code> URL.</p>




<p>First thought about implementation could be using <code>Ember.$.ajax</code> call with manually passing URL and all the data. But that's not really a great solution. For simple cases it may work, but what about sending some custom headers, using namespaces and other options? For these reasons we should encapsulate all the logic within <strong>adapter</strong> - the layer that's responsible for communication with the API. So let's add <code>publish</code> function to our article adapter for executing the request and use this function from <code>article</code> model.</p>


<p>``` javascript
// app/adapters/article.js</p>

<p>import ApplicationAdapter from &lsquo;./application&rsquo;;</p>

<p>export default ApplicationAdapter.extend({
  publish(id) {</p>

<pre><code>return this.ajax(this.urlForPublishAction(id), 'PUT');
</code></pre>

<p>  },</p>

<p>  urlForPublishAction(id) {</p>

<pre><code>return `${this.buildURL('article', id)}/publish`;
</code></pre>

<p>  }
});
```</p>

<p>There are some interesting things going on here: the first one is that we use <code>ajax</code> function defined in adapter, which is also utilized when peforming all other requests in <strong>Ember Data</strong>. It takes care of setting up options like headers, proper success and error handling etc., so we should always use this function instead of simple <code>Ember.$.ajax</code>. Another thing is <code>buildURL</code> function, which builds, well, URL for given resource represented by model name (with given id if present) considering adapter options like <code>host</code> or <code>namespace</code>. By using these functions we ensure the consistency between all <strong>API</strong> calls.</p>




<p>To make it work we just need to find proper adapter for <code>article</code> model and call <code>publish</code> function on this adapter from the model:</p>


<p>``` javascript
// app/models/article.js</p>

<p>import Ember from &lsquo;ember&rsquo;;
import DS from &lsquo;ember-data&rsquo;;</p>

<p>export default DS.Model.extend({
  publish() {</p>

<pre><code>let modelName = this.constructor.modelName;
let adapter = this.store.adapterFor(modelName);
return adapter.publish(this.get('id'));
</code></pre>

<p>  }
});
```</p>

<p>To avoid hardcoding model name we take it from the <code>constructor</code>, then use it as a name of adapter we want to fetch from <code>owner</code> (or <code>container</code> in Ember versions prior to 2.3) and finally call the proper method on adapter with id as argument.</p>




<p>What if we needed to pass the serialized attributes as well? The third argument of <code>ajax</code> function in adapter is a hash, so we would need to pass the serialized article as <code>data</code> param there. Here's a quick example, starting from the model:</p>


<p>``` javascript
// app/models/article.js</p>

<p>import Ember from &lsquo;ember&rsquo;;
import DS from &lsquo;ember-data&rsquo;;</p>

<p>export default DS.Model.extend({
  publish() {</p>

<pre><code>let modelName = this.constructor.modelName;
let adapter = this.store.adapterFor(modelName);
return adapter.publish(this.get('id'), this.serialize());
</code></pre>

<p>  }
});
```</p>

<p>and here's the adapter:</p>


<p>``` javascript
// app/adapters/article.js</p>

<p>import ApplicationAdapter from &lsquo;./application&rsquo;;</p>

<p>export default ApplicationAdapter.extend({
  publish(id, serializedData) {</p>

<pre><code>return this.ajax(this.urlForPublishAction(id), 'PUT', { data: serializedData });
</code></pre>

<p>  },</p>

<p>  urlForPublishAction(id) {</p>

<pre><code>return `${this.buildURL('article', id)}/publish`;
</code></pre>

<p>  }
});
```</p>

<p>And that's it!</p>




<h2>Wrapping up</h2>




<p>Non-RESTful actions are not supported out of the box by <strong>Ember Data</strong>, but they are not that hard to implement when using adapters.</p>




<p class="meta small-p">Edit: Thanks to <a href="https://karolgalanciak.com/blog/2016/02/07/implementing-non-restful-actions-with-ember-data/#comment-2500931825" target="_blank">Wesley Workman</a> for mentioning <code>adapterFor</code> and suggesting using it in favour of <code>owner</code> / <code>container</code> API.</p>

]]></content>
  </entry>
  
</feed>
