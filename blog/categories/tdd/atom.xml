<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TDD | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2018-06-12T17:32:38+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Test Driven Ember - Testing Holding a Button]]></title>
    <link href="https://karolgalanciak.com/blog/2017/03/26/test-driven-ember-testing-holding-button/"/>
    <updated>2017-03-26T23:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2017/03/26/test-driven-ember-testing-holding-button</id>
    <content type="html"><![CDATA[<p>Thanks to the awesome tools in <strong>Ember ecosystem</strong> such as <a href="http://github.com/samselikoff/ember-cli-mirage/" target="_blank">ember-cli-mirage</a>, <a href="https://github.com/emberjs/ember-test-helpers" target="_blank">ember-qunit</a> or <a href="https://github.com/emberjs/ember-test-helpers" target"_blank">ember-test-helpers</a> writing majority of the tests is pretty straight-forward. Nevertheless, there are quite a few cases where <strong>simulating user&rsquo;s interaction</strong> is not that simple. An example of such use case would be <strong>holding a button</strong> for particular period of time triggering some side effect.</p>

<!--more-->


<h2>Anatomy of The Problem</h2>

<p>Imagine you are implementing a feature of destroying some records in your application, e.g. the todo items from the list. It would be a bit unfortunate to destroy any item if a user <strong>accidentally clicked</strong> on the destroy button, so it might be a good idea to somehow make it harder to execute such an action. A simple approach would be displaying some alert <strong>asking user to confirm</strong> whether this item should be removed or not. This approach would get our job done, but it doesn&rsquo;t offer the best <strong>UX</strong>. What are the better options here?</p>

<p>A pretty cool solution to this problem would be making user <strong>hold a delete button</strong> for a particular period of time, e.g. for 3 seconds. Holding this button for less than 3 seconds wouldn&rsquo;t destroy the item, so it would be impossible to accidentally delete anything.</p>

<p>There is an addon which solves exactly this problem: <a href="https://www.npmjs.com/package/ember-hold-button" target="_blank">ember-hold-button</a>, so there is no need to reinvent the wheel. Let&rsquo;s add this to our application.</p>

<h2>Adding Destroy Action</h2>

<p>Let&rsquo;s start by installing <code>ember-hold-button</code> addon:</p>

<p><code>
ember install ember-hold-button
</code></p>

<p>and assume that we already have some component for displaying a single item with <code>destroy</code> action:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
&lt;button {{action "destroy"}} data-test="destroy-item-btn"&gt;Destroy&lt;/button&gt;
</code>
</p>

<p>and that the component was test-driven with the following test written before the actual implementation (TDD for FTW!):</p>

<p>
``` javascript tests/integration/components/display-todo-item-test.js
import Ember from &lsquo;ember&rsquo;;
import { moduleForComponent, test } from &lsquo;ember-qunit&rsquo;;
import hbs from &lsquo;htmlbars-inline-precompile&rsquo;;</p>

<p>const {
  set,
  RSVP,
} = Ember;</p>

<p>moduleForComponent(&lsquo;display-todo-item&rsquo;, &lsquo;Integration | Component | display todo item&rsquo;, {
  integration: true
});</p>

<p>test(&lsquo;item can be destroyed&rsquo;, function(assert) {
  assert.expect(1);</p>

<p>  const {</p>

<pre><code>$,
</code></pre>

<p>  } = this;</p>

<p>  const item = Ember.Object.extend({</p>

<pre><code>destroyRecord() {
  assert.ok(true, 'item should be destoyed');

  return RSVP.resolve(this);
},
</code></pre>

<p>  });</p>

<p>  set(this, &lsquo;item&rsquo;, item);</p>

<p>  this.render(hbs<code>{{display-todo-item item=item}}</code>);</p>

<p>  const $destroyBtn = $(&lsquo;[data-test=destroy-item-btn]&rsquo;);</p>

<p>  $destroyBtn.click();
});
```
</p>

<p>Basically this test verifies that the <code>destroyRecord</code> method will be called on item after clicking the button.</p>

<p>Let&rsquo;s add <code>hold-button</code> which will trigger <code>destroy</code> action after holding it for 3 seconds:</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
{{#hold-button type="rectangle" action="destroy" delay=3000 data-test="destroy-item-btn"}}
  Destroy
{{/hold-button}}
</code>
</p>

<p><code>delay</code> option will get the job done here to make it holdable for 3 seconds to trigger <code>destroy</code> action.</p>

<p>The button is working great, but our test obviously is failing now! How can we simulate holding action in our integration tests?</p>

<h2>Testing Holding Interaction</h2>

<p>To solve that problem we should break the problem down into the single events. On desktop, pressing a button simply means triggering <code>mouseDown</code> event and releasing means trigger <code>mouseUp</code> event. On mobile that would be <code>touchStart</code> and <code>touchEnd</code> events accordingly.</p>

<p>Based on how <code>hold-button</code> component works, we may suspect that there is some internal timer which starts counting time after triggering <code>mouseDown</code> (<code>touchStart</code>) event or a scheduler which executes the action if it was held for required period of time and cancels it if it was released before that period of time, which would mean cancelling timer on <code>mouseUp</code> event.</p>

<p>After checking <a href="https://github.com/AddJam/ember-hold-button/blob/master/addon/components/hold-button.js" target="_blank">the internals</a>, it turns out this is exactly the case! Let&rsquo;s rewrite our test by triggering these events. We will also need two extra things as we are dealing with asynchronous actions:</p>

<ul>
<li><p><code>async()</code> / <code>done()</code> &ndash; To make sure QUnit will wait for an asynchronous operation to be finished we need to use <code>async()</code> function. That way QUnit will wait until <code>done()</code> is called. We will call <code>done()</code> after triggering <code>mouseUp</code> event. But we also need to wait until the action is executed. We will need <code>wait()</code> helper for that.</p></li>
<li><p><code>wait()</code> &ndash; it forces run loop to process all the pending events. That way we ensure that the asynchronous operation have been executed (like calling <code>destroy</code> action after 3 seconds).</p></li>
</ul>


<p>Here&rsquo;s our new test:</p>

<p>
``` javascript tests/integration/components/display-todo-item-test.js
import Ember from &lsquo;ember&rsquo;;
import { moduleForComponent, test } from &lsquo;ember-qunit&rsquo;;
import hbs from &lsquo;htmlbars-inline-precompile&rsquo;;
import wait from &lsquo;ember-test-helpers/wait&rsquo;;</p>

<p>const {
  set,
  RSVP,
} = Ember;</p>

<p>moduleForComponent(&lsquo;display-todo-item&rsquo;, &lsquo;Integration | Component | display todo item&rsquo;, {
  integration: true
});</p>

<p>test(&lsquo;item can be destroyed&rsquo;, function (assert) {
  assert.expect(1);</p>

<p>  const {</p>

<pre><code>$,
</code></pre>

<p>  } = this;</p>

<p>  const item = Ember.Object.extend({</p>

<pre><code>destroyRecord() {
  assert.ok(true, 'item should be destoyed');

  return RSVP.resolve(this);
},
</code></pre>

<p>  });</p>

<p>  set(this, &lsquo;item&rsquo;, item);</p>

<p>  this.render(hbs<code>{{display-todo-item item=item}}</code>);</p>

<p>  const $destroyBtn = $(&lsquo;[data-test=destroy-item-btn]&rsquo;);</p>

<p>  $destroyBtn.mousedown();</p>

<p>  wait().then(() => {</p>

<pre><code>$destroyBtn.mouseup();
done();
</code></pre>

<p>  });
});
```
</p>

<p>Nice! Our test is passing again. However, there is one serious problem: this test is quite slow as it waits 3 second for the action to finish. Can we make it somehow faster?</p>

<h2>Making Our Test Faster</h2>

<p>The answer is: yes. We just need to provide a way to make <code>delay</code> configurable from the outside. This can be simply done by introducing <code>destroyActionDelay</code> property with default value equal <code>3000</code> and allowing it to be modified. Let&rsquo;s start with applying this little change to the test:</p>

<p>
<code>javascript tests/integration/components/display-todo-item-test.js
// the rest of the tests
this.render(hbs`{{display-todo-item item=item destroyActionDelay=0}}`);
</code>
</p>

<p>We don&rsquo;t care about waiting for 3 seconds in the tests, we just want to test if it works and to make it fast. <code>0</code> sounds like the most reasonable value in such case.</p>

<p>And let&rsquo;s change few things in our component:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  destroyActionDelay: 3000,</p>

<p>  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
{{#hold-button type="rectangle" action="destroy" delay=destroyActionDelay data-test="destroy-item-btn"}}
  Destroy
{{/hold-button}}
</code>
</p>

<p>And that&rsquo;s it! You can now enjoy the much faster test suite!</p>

<h2>Wrapping Up</h2>

<p>Testing holding a button for particular period of time doesn&rsquo;t sound like an obvious thing to do. Fortunately, with proper design and understanding the interaction from the <strong>browser&rsquo;s perspective</strong>, it isn&rsquo;t that hard to do and doesn&rsquo;t necessarily make your tests slower.</p>

<p>P.S. I&rsquo;ve just started <strong>writing a book</strong> about <strong>test-driving Ember</strong> applications. If you found this article useful, you are going to love it :). <strong>Subscribe</strong> to my newsletter to get updates and promotion code once it&rsquo;s released.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You don't (necessarily) need gem for that feature]]></title>
    <link href="https://karolgalanciak.com/blog/2014/04/27/you-dont-necessarily-need-gem-for-that-feature/"/>
    <updated>2014-04-27T17:02:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2014/04/27/you-dont-necessarily-need-gem-for-that-feature</id>
    <content type="html"><![CDATA[<p>You are working currently on that awesome app and just started thinking about implementing new feature, let's call it feature X. What's the first thing you do? Rolling your own solution or... maybe checking if there's a magical gem that can help you solve that problem? Ok, it turns out there's already a gem Y that does what you expect. Also, it does tons of other things and is really complex. After some time your app breaks, something is definitively not working and it seems that gem Y is responsible for that. So you read all the issues on Github, pull requests and even read the source code and finally find a little bug. You managed to do some monkeypatching first and then send pull request for a small fix and solved a problem, which took you a few hours. Looks like a problem is solved. And then, you try to update Rails to2 the current version. Seems like there's a dependency problem - gem Y depends on previous version of Rails...</p>




<!--more-->


<p></p>

<p>Does it sound somehow familiar to you, especially when updating Rails? If it's caused by "big" gem that solves a lot of problems and is still maintained, it's not that bad. How about these "small" gems, which come in handy and look quite complex but you could roll your own solution to that particular problem within half an hour?</p>




<p>I've seen this many times where first thing when implementing new feature is searching for a gem that solves this problem. We need really basic polymorphic tags? Let's use <a href="https://github.com/mbleigh/acts-as-taggable-on" target="_blank">acts-as-taggable-on</a>, we don't need half of the features provided and setting up a few migrations and associations would take 10 minutes anyway but there's no need to reinvent the wheel. Client asked for a simple admin panel with some CRUD stuff involving several models. Let's use <a href="https://github.com/gregbell/active_admin" target="_blank">active_admin</a> or <a href="https://github.com/sferik/rails_admin" target="_blank">rails_admin</a> for that! Simple searching / filtering where several fields in one model are involved? <a href="https://github.com/activerecord-hackery/ransack" target="_blank">Ransack</a> is an obvious choice!</p>




<p>More gems mean: slower boot time of your application, more dependencies (don't look only at Gemfile, Gemfile.lock is the real deal), more things that can break, more issues to take care of when updating Rails and the gem itself (reading changelogs, issues etc.).</p>




<h2>When to use third party gem when implementing feature X?</h2>




<ul>
  <li>Gem is actively being maintained, there were some commits not that long ago (basic prerequisite)</li>
  <li>Gem solves the exact problem you have and does only that</li>
  <li>Gem does plenty of other things but it deals with areas you are not really familiar involving security, encryption etc. (e.g. <a href="https://github.com/reidmorrison/symmetric-encryption" target="_blank">symmetric-encryption</a>)</li>
  <li>Gem does many other things and you need just a small part of it but rolling your own solution would take really a lot of time (e.g. <a href="https://github.com/plataformatec/devise" target="_blank">devise</a>)</li>
  <li>Gem deals with complex infrastructure things (e.g. <a href="https://github.com/carrierwaveuploader/carrierwave" target="_blank">carrierwave</a>)</li>
  <li>Gem has a nice integration with many other gems you already use</li>
</ul>




<p>Remember that using gem Y means also reading docs and it might be beneficial to read some parts of source code, just to get the general idea how it works. It also takes some time. Why not implement your own solution? It might look like reinventing the wheel but no gem will be that customizable to the extent you need. Or you will be using just a small part of it and the models / controllers will have tens of additional methods you don't need (and hundreds more with several gems).</p>




<h2>Writing own solution</h2>




<p>How much work does it really take to reimplement a gem? Let's take a look at something popular - <a href="https://github.com/drapergem/draper" target="_blank">draper</a> gem. Draper is a pretty good solution for decorators/presenters for your models in Rails apps. I've been using it for quite long a time, had some issues but managed to solve them rather quickly. Unfortunately, the source code looks quite complex, especially extracting view_context with a bit global-variable-like RequestStore. And there are some other complex parts that I don't really use. Let's write custom presenter and call it DecentPresenter. What kind of interface and conventions would I expect from it?</p>




<ul>
  <li>Include some module in controllers (ApplicationController) - I want to be explicit here, without including it automatically on Rails app boot. Also, I don't want to include it in models - model doesn't have to know that it can be presented in one way or another</li>
  <li>Establish naming convention: default presenter for User would be <code>UserPresenter</code></li>
  <li>Call <code>present(user)</code> in controller which would wrap user by <code>UserPresenter</code> and <code>present(User.all)</code> which would handle collections</li>
  <li>Ability to specify other presenter than the default one - <code>present(user, with: OtherPresenter)</code></li>
  <li>Have access to helpers within presenters</li>
  <li>Presenters will inherit from some base class (<code>DecentPresenter::Base</code>)</li>
</ul>




<p>Doesn't really look that hard. Getting access to Rails helpers might seem difficult but we can get it from <code>view_context</code> in controllers. Let's start with integration test for presenters. We want to include a module to a class (Controller), which would mix in <code>present</code> method. Let's call it DecentPresenter::Exposable:</p>


<p>``` ruby spec/decent_presenter/exposable_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>class DummyModelForExposableTest</p>

<p>  def name</p>

<pre><code>"name"
</code></pre>

<p>  end</p>

<p>end</p>

<p>class DummyModelForExposableTestPresenter &lt; DecentPresenter::Base</p>

<p>  def name</p>

<pre><code>"presented name"
</code></pre>

<p>  end</p>

<p>end</p>

<p>class DummyModelForExposableOtherPresenter &lt; DecentPresenter::Base</p>

<p>  def name</p>

<pre><code>"other presented name"
</code></pre>

<p>  end</p>

<p>end</p>

<p>class DummyObjectErrorPresenterExposable</p>

<p>  include DecentPresenter::Exposable</p>

<p>  def present_model(model)</p>

<pre><code>present(model)
</code></pre>

<p>  end</p>

<p>end</p>

<p>class DummyObjectPresenterExposable</p>

<p>  def view_context ; end</p>

<p>  include DecentPresenter::Exposable</p>

<p>  def present_model(model)</p>

<pre><code>present(model)
</code></pre>

<p>  end</p>

<p>  def present_model_with_options(model, options)</p>

<pre><code>present(model, options)
</code></pre>

<p>  end</p>

<p>  def present_collection(collection)</p>

<pre><code>present(collection)
</code></pre>

<p>  end</p>

<p>  def present_collection_with_options(collection, options)</p>

<pre><code>present(collection, options)
</code></pre>

<p>  end</p>

<p>end</p>

<p>describe DecentPresenter::Exposable do</p>

<p>  context &ldquo;view_context prerequisite&rdquo; do</p>

<pre><code>it "raises DoesNotImplementViewContextError if view_context method
  is not defined" do
  model = DummyModelForExposableTest.new
  expect do 
    DummyObjectErrorPresenterExposable.new.present_model(model)
  end.to raise_error DecentPresenter::Exposable::DoesNotImplementViewContextError,
    "Object must implement :view_context method to handle presentation"
end

it "doesn't raise DoesNotImplementViewContextError if view_context method
  is defined" do
  model = DummyModelForExposableTest.new
  expect do 
    DummyObjectPresenterExposable.new.present_model(model)
  end.not_to raise_error
end
</code></pre>

<p>  end</p>

<p>  context &ldquo;presentation&rdquo; do</p>

<pre><code>let(:model) { DummyModelForExposableTest.new }
let(:collection) { [model] }

subject { DummyObjectPresenterExposable.new }

it "presents model with default presenter" do
  expect(subject.present_model(model).name).to eq "presented name"
end

it "presents model with specified presenter" do
  expect(subject.present_model_with_options(
      model,
      with: DummyModelForExposableOtherPresenter
    ).name
  ).to eq "other presented name"
end

it "presents models collection with default presenter" do
  expect(subject.present_collection(collection).first.name).to eq "presented name"
end

it "presents models collection with specified presenter" do
  expect(subject.present_collection_with_options(
      collection,
      with: DummyModelForExposableOtherPresenter
    ).first.name
  ).to eq "other presented name"
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>What happens here? First off, we set up some dummy classes: DummyModel with <code>name</code> method, two presenters for testing with default presenter and other presenter and two classes, where we include <code>DecentPresenter::Exposable</code> module. Why two? Just to check that if the object implements <code>view_context</code> method. If the <code>view_context</code> method is not implemented, we provide descriptive error. Then we write some tests for a single model / collection and default / custom presenter to check if they are presented. Let's write some code:</p>


<p>``` ruby lib/decent_presenter/exposable.rb</p>

<p>module DecentPresenter
  module Exposable</p>

<pre><code>def present(presentable, options = {})
  if respond_to? :view_context, true
    # decorate the presentable object here
  else
    raise DecentPresenter::Exposable::DoesNotImplementViewContextError.new(
      "Object must implement :view_context method to handle presentation"
    )
  end
end

class DoesNotImplementViewContextError &lt; StandardError ; end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>And just define base class for presenters:</p>


<p>``` ruby lib/decent_presenter/base.rb
moduleDecentPresenter
  class Base</p>

<p>  end
end
```</p>

<p>Tests within presentation context still fail but they will be the last ones that will pass. Let's leave them for now and thing about base class - <code>DecentPresenter::Base</code> and it's subclasses, our presenters. We want to have access to helpers by <code>helpers</code> method and <code>h</code> for shorthand. We also need have access to presented object: by <code>object</code> and <code>model</code> methods. If the method isn't implemented by presenter, it should be delegated to presented model. Sounds like <code>method_missing</code>? That's one possibility. Let's try something different - <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/delegate/rdoc/SimpleDelegator.html" target="_blank">SimpleDelegator</a>. SimpleDelegator is a pretty cool core class with two public methods <code>__getobj__</code> and <code>__setobj__</code> - the first one exposes decorated object and the latter sets objects to which all method calls will be delegated. The object is set when we pass it to the constructor of <code>SimpleDelegator</code>. Looks like our <code>DecentPresenter::Base</code> class will inherit from <code>SimpleDelegator</code>. But we will need to override constructor to pass <code>view_context</code>. Also, it would be quite useful to be able to present other objects within our presenters. Let's write some tests:</p>


<p>``` ruby specs/decent_presenter/base_spec.rb
require &lsquo;spec_helper&rsquo;</p>

<p>class DummyModelForBaseClassTest</p>

<p>  def name</p>

<pre><code>"dummy_model_name"
</code></pre>

<p>  end</p>

<p>  def stuff</p>

<pre><code>"stuff"
</code></pre>

<p>  end</p>

<p>end</p>

<p>class DummyViewContext ; end</p>

<p>class DummyModelPresenter &lt; DecentPresenter::Base</p>

<p>  def name</p>

<pre><code>"presented #{model.name}"
</code></pre>

<p>  end</p>

<p>end</p>

<p>describe DecentPresenter::Base do</p>

<p>  let(:model) { DummyModelForBaseClassTest.new }
  let(:view_context) { DummyViewContext.new }</p>

<p>  context &ldquo;base&rdquo; do</p>

<pre><code>subject { DecentPresenter::Base.new(model, view_context) }

it "exposes model as model" do
  expect(subject.model).to eq model
end

it "exposes model as object" do
  expect(subject.object).to eq model
end

it "exposes view_context as h" do
  expect(subject.h).to eq view_context
end

it "exposes view_context as helpers" do
  expect(subject.helpers).to eq view_context
end
</code></pre>

<p>  end</p>

<p>  context &ldquo;subclass&rdquo; do</p>

<pre><code>subject { DummyModelPresenter.new(model, view_context) }

it "decorates model's methods" do
  expect(subject.name).to eq "presented dummy_model_name"
end

it "delegates method calls to model when the method is not defined
  within presenter" do
  expect(subject.stuff).to eq "stuff"
end

it "implements presentable interface" do
  expect(subject).to respond_to :present
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Like before, we setup some DummyClasses and write some tests for the requirements we've just discussed. Our base class implements <code>view_context</code> so it looks like we just need to include <code>DecentPresenter::Exposable</code> module and we will be able to decorate other objects within our presenters. We cover it be checking if the subclasses implement required interface. We also cover some delegation stuff in tests, <code>SimpleDelegator</code> ensures it will be delegated but it is a core functionality for presenters so it might be a good idea to test for it. Let's write the implementation:</p>


<p>``` ruby lib/decent_presenter/base.rb
module DecentPresenter
  class Base &lt; SimpleDelegator</p>

<pre><code>include DecentPresenter::Exposable

attr_reader :view_context
private :view_context

def initialize(object, view_context)
  super(object)
  @view_context = view_context
end

def model
  __getobj__
end

alias :object :model

def helpers
  view_context
end

alias :h :helpers    
</code></pre>

<p>  end
end
```</p>

<p>We need a main interface which would wrap our models within presenters. Sure, we could do it in present method but I don't really like the idea that the e.g. controller would know, how to present a model. Let's implement dedicated interface which is going to be used by <code>present</code> method. We have some integration tests for presenters, base class is already covered, so we will just need to check, if a model or collection is decorated by presenters:</p>


<p>``` ruby spec/decent_presenter/exposure_spec.rb
require &lsquo;spec_helper&rsquo;</p>

<p>class DummyModelForExposureTest ; end</p>

<p>class DummyModelForExposureTestPresenter &lt; DecentPresenter::Base ; end</p>

<p>class DummyModelForExposureTestOtherPresenter &lt; DecentPresenter::Base ; end</p>

<p>describe DecentPresenter::Exposure do</p>

<p>  let(:presenter_factory) { double(:presenter_factory) }
  let(:view_context) { double(:view_context) }</p>

<p>  let(:model) { DummyModelForExposureTest.new }
  let(:collection) { [model] }</p>

<p>  subject { DecentPresenter::Exposure.new(view_context, presenter_factory) }</p>

<p>  before(:each) do</p>

<pre><code>allow(presenter_factory).to receive(:presenter_for)
  .with(model) { DummyModelForExposureTestPresenter }
</code></pre>

<p>  end</p>

<p>  it &ldquo;presents model with default presenter&rdquo; do</p>

<pre><code>presented_model = subject.present(model)
expect(presented_model).to be_instance_of DummyModelForExposureTestPresenter
</code></pre>

<p>  end</p>

<p>  it &ldquo;presents model with specified presenter&rdquo; do</p>

<pre><code>presented_model = subject.present(model, with: DummyModelForExposureTestOtherPresenter)
expect(presented_model).to be_instance_of DummyModelForExposureTestOtherPresenter
</code></pre>

<p>  end</p>

<p>  it &ldquo;presents models in collection with default presenter&rdquo; do</p>

<pre><code>presented_collection = subject.present(collection)
expect(presented_collection.first).to be_instance_of DummyModelForExposureTestPresenter
</code></pre>

<p>  end</p>

<p>  it &ldquo;presents models in collection with specified presenter&rdquo; do</p>

<pre><code>presented_collection = subject.present(collection, with: DummyModelForExposureTestOtherPresenter)
expect(presented_collection.first).to be_instance_of DummyModelForExposureTestOtherPresenter
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The <code>Exposure</code> class is going to have one public method which takes model or collection as the first argument and the options hash, where we can specify presenter. If it's not specified the default presenter will be used. And how do we know what the default presenter is? Don't know yet, so let's introduce a collaborator, which takes model and returns default presenter for it. We will call it <code>presenter_factory</code>. We also need to remember about the <code>view_context</code> dependency. Let's write the implementation:</p>




<p>Note: again, the implementation is quite clean, but remember the TDD cycle: red, green, refactor, write minimal implementation for the first test, make it pass and repeat. This post is not about how to TDD properly and to focus on the core things I just give code after the refactoring phase. </p>


<p>``` ruby lib/decent_presenter/exposure.rb
module DecentPresenter
  class Exposure</p>

<pre><code>attr_reader :view_context, :presenter_factory
private :view_context, :presenter_factory

def initialize(view_context, presenter_factory)
  @view_context = view_context
  @presenter_factory = presenter_factory
end

def present(presentable, options = {})
  if presentable.respond_to?(:size)
    present_collection(presentable, options)
  else
    present_model(presentable, options)
  end
end

private

  def present_model(presentable, options = {})
    presenter = options.fetch(:with) do
      presenter_factory.presenter_for(presentable)
    end
    presenter.new(presentable, view_context)
  end

  def present_collection(collection, options = {})
    collection.map { |el| present_model(el, options) }        
  end      
</code></pre>

<p>  end
end
```</p>

<p>We need somehow to distinguish between collection and a single model. The collection will probably implement the <code>size</code> method. What if the model also implements size method? Looks like we need to make some paranoid check. Let's modify test for <code>DecentPresenter::Exposure</code> and add <code>size</code> method to DummyModel:</p>


<p>``` ruby spec/decent_presenter/exposure_spec.rb</p>

<h1>other code</h1>

<p>class DummyModelForExposureTest</p>

<p>  def size ; end</p>

<p>end</p>

<h1>other code</h1>

<p>```</p>

<p>Now the tests fail. How can we make sure the collection really is a collection? Besides <code>size</code>, it'll probably implement <code>to_a</code> and <code>first</code> methods. Let's update the implementation:</p>


<p>``` ruby lib/decent_presenter/exposure.rb
module DecentPresenter
  class Exposure</p>

<pre><code>attr_reader :view_context, :presenter_factory
private :view_context, :presenter_factory

def initialize(view_context, presenter_factory)
  @view_context = view_context
  @presenter_factory = presenter_factory
end

def present(presentable, options = {})
  if presentable_is_a_collection?(presentable)
    present_collection(presentable, options)
  else
    present_model(presentable, options)
  end
end

private

  def present_model(presentable, options = {})
    presenter = options.fetch(:with) do
      presenter_factory.presenter_for(presentable)
    end
    presenter.new(presentable, view_context)
  end

  def present_collection(collection, options = {})
    collection.map { |el| present_model(el, options) }        
  end      

  def presentable_is_a_collection?(presentable)
    [:size, :to_a, :first].all? { |method| presentable.respond_to? method }
  end
</code></pre>

<p>  end
end
```</p>

<p>Looks like we only have <code>DecentPresenter::Factory</code> left. The factory should return a default presenter (constant) based on model's class. What if it doesn't exist? We will provide descriptive error message. Let's write tests:</p>


<p>``` ruby spec/decent_presenter/factory_spec.rb
require &lsquo;spec_helper&rsquo;</p>

<p>class DummyModelForFactoryPresenter ; end
class DummyModelForFactory ; end
class OtherDummyModel ; end</p>

<p>describe DecentPresenter::Factory do</p>

<p>  subject { DecentPresenter::Factory }</p>

<p>  it &ldquo;implements DecentPresenter Factory interface&rdquo; do</p>

<pre><code>expect(subject).to respond_to :presenter_for
</code></pre>

<p>  end</p>

<p>  describe &ldquo;.presenter_for&rdquo; do</p>

<pre><code>it "gives presenter class based on object's class in convention: KlassPresenter" do
  model = DummyModelForFactory.new
  expect(subject.presenter_for(model)).to eq DummyModelForFactoryPresenter
end

it "raises PresenterForModelDoesNotExist error if presenter class is not defined" do
  model = OtherDummyModel.new
  expect do 
    subject.presenter_for(model) 
  end.to raise_error DecentPresenter::Factory::PresenterForModelDoesNotExist,
    "expected OtherDummyModelPresenter presenter to exist"
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>I also added test for covering factory interface to guard against changing interface which is used in <code>DecentPresenter::Exposure</code> - you can imagine the situation where the method name is changed and the tests still pass. We have integration tests for it (<code>DecentPresenter::Exposable</code>) but having these kind of tests underlines the fact that it shouldn't be changed. To extract the presenter's name from model we will ask model for it's class, add "Presenter" suffix and use <code>classify</code> method:</p>


<p>``` ruby lib/decent_presenter/factory.rb
module DecentPresenter
  module Factory</p>

<pre><code>extend self

def presenter_for(model)
  presenter_class_name = "#{model.class}Presenter"
  begin
    presenter_class_name.constantize
  rescue NameError
    raise PresenterForModelDoesNotExist.new(
      "expected #{presenter_class_name} presenter to exist"
    )
  end
end

class PresenterForModelDoesNotExist &lt; StandardError ; end
</code></pre>

<p>  end
end
```</p>

<p>The last thing is to make integration tests pass, let's finish the <code>present</code> method:</p>


<p>``` ruby lib/decent_presenter/exposable.rb
module DecentPresenter
  module Exposable</p>

<pre><code>def present(presentable, options = {})
  if respond_to? :view_context
    DecentPresenter::Exposure.new(
      view_context, DecentPresenter::Factory
    ).present(presentable, options)
  else
    raise DecentPresenter::Exposable::DoesNotImplementViewContextError.new(
      "Object must implement :view_context method to handle presentation"
    )
  end
end

class DoesNotImplementViewContextError &lt; StandardError ; end
</code></pre>

<p>  end
end
```</p>

<p>Seems like we are almost done. All tests pass but one common use case still won't work - pagination. We can use some array pagination but it's pretty inconvenient. We need somehow to keep a reference of the original collection, delegate some pagination methods to the original collection and other methods should be handled by presented collection. Sounds like a proxy? Let's write tests for <code>DecentPresenter::CollectionProxy</code>:</p>


<p>``` ruby spec/decent_presenter/collection_proxy_spec.rb</p>

<p>  require &lsquo;spec_helper&rsquo;</p>

<p>TEST_COLLECTION_PROXY_PAGINATION_METHODS = [
  :current_page, :total_pages,
  :limit_value, :model_name, :total_count,
  :total_entries, :per_page, :offset
]</p>

<p>class DummyOriginalForCollectionProxy</p>

<p>  TEST_COLLECTION_PROXY_PAGINATION_METHODS.each do |method|</p>

<pre><code>define_method method do 
  "original"
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>class DummyPresentedForCollectionProxy</p>

<p>  def presented_method</p>

<pre><code>"presented"
</code></pre>

<p>  end</p>

<p>  def other_presented_method</p>

<pre><code>"presented"
</code></pre>

<p>  end</p>

<p>end</p>

<p>describe DecentPresenter::CollectionProxy do</p>

<p>  subject { DecentPresenter::CollectionProxy.new(</p>

<pre><code>DummyOriginalForCollectionProxy.new, DummyPresentedForCollectionProxy.new
)
</code></pre>

<p>  }</p>

<p>  it &ldquo;delegates pagination-related methods to original collection&rdquo; do</p>

<pre><code>TEST_COLLECTION_PROXY_PAGINATION_METHODS.each do |pagination_method|
  expect(subject.send(pagination_method)).to eq "original"
end
</code></pre>

<p>  end</p>

<p>  it &ldquo;delegates other methods to presented collection&rdquo; do</p>

<pre><code>[:presented_method, :other_presented_method].each do |presented_method|
  expect(subject.send(presented_method)).to eq "presented"
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>I searched for some pagination-related methods and put them in <code>TEST_COLLECTION_PROXY_PAGINATION_METHODS</code>. I also introduced two dummy collection classes - one for pagination methods and the latter for handling other methods. To DRY out the implementation I use <code>define_method</code>. The tests verify that the method calls are properly delegated. Let's write the implementation with <code>method_missing</code>:</p>


<p>``` ruby lib/decent_presenter/collection_proxy.rb
module DecentPresenter
  class CollectionProxy</p>

<pre><code>delegate :current_page, :total_pages, :limit_value, :model_name, :total_count,
  :total_entries, :per_page, :offset, to: :original_collection

attr_reader :original_collection, :presented_collection
private :original_collection, :presented_collection

def initialize(original_collection, presented_collection)
  @original_collection = original_collection
  @presented_collection = presented_collection
end

def method_missing(method, *args, &amp;block)
  presented_collection.send(method, *args, &amp;block)
end
</code></pre>

<p>  end
end
```</p>

<p>The <code>delegate</code> method from <code>ActiveSupport</code> comes in handy for proxies. We need to modify <code>DecentPresenter::Exposure#present</code> and wrap the presented collection and the original collection in proxy. Let's add a test for that also:</p>


<p></p>

<p>``` ruby spec/decent_presenter/exposure_spec.rb
require &lsquo;spec_helper&rsquo;</p>

<p>describe DecentPresenter::Exposure do</p>

<p>  # other code</p>

<p>  it &ldquo;wraps collection in CollectionProxy&rdquo; do</p>

<pre><code>presented_collection = subject.present(collection)
expect(presented_collection).to be_instance_of DecentPresenter::CollectionProxy
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby lib/decent_presenter/exposure.rb
module DecentPresenter
  class Exposure</p>

<pre><code>attr_reader :view_context, :presenter_factory
private :view_context, :presenter_factory

def initialize(view_context, presenter_factory)
  @view_context = view_context
  @presenter_factory = presenter_factory
end

def present(presentable, options = {})
  if presentable_is_a_collection?(presentable)
    present_collection(presentable, options)
  else
    present_model(presentable, options)
  end
end

private

  def present_model(presentable, options = {})
    presenter = options.fetch(:with) do
      presenter_factory.presenter_for(presentable)
    end
    presenter.new(presentable, view_context)
  end

  def present_collection(collection, options = {})
    presented_collection = collection.map { |el| present_model(el, options) }
    DecentPresenter::CollectionProxy.new(collection, presented_collection)
  end      

  def presentable_is_a_collection?(presentable)
    [:size, :to_a, :first].all? { |method| presentable.respond_to? method }
  end
</code></pre>

<p>  end
end
```</p>

<p>And we are done! The test for verifying if the instance of <code>DecentPresenter::CollectionProxy</code> is returned when handling collection introduces some coupling but I'm pretty comfortable with it. It won't be handled by any other object than the CollectionProxy.</p>




<p>The DecentPresenter is much simpler than Draper, it offers most of the stuff I need in my presenters and writing it was pretty enjoyable :). It didn't take much time and I have a solution, which I'm familiar with and if something breaks I will know why. In fact, I like it so much that I'm going to release it as a gem :).</p>




<h2>Wrapping up</h2>




<p>Using third party gem isn't always the best solution, sometimes it's quite easy to write similar solution. Many gems are quite complex because they need to handle all possible use cases and that level of complexity and other dependencies might not be necessary for your app.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Driven Rails - Part 2]]></title>
    <link href="https://karolgalanciak.com/blog/2014/03/03/test-driven-rails-part-2/"/>
    <updated>2014-03-03T19:52:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2014/03/03/test-driven-rails-part-2</id>
    <content type="html"><![CDATA[<p>Last time, in <a href="http://karolgalanciak.com/blog/2014/01/04/test-driven-rails-part-1/" target="_blank">part 1</a>, I was giving some advice about testing - why to test at all, which tests are valuable and which are not, when to write acceptance tests and in what cases aim for the maximum code coverage. It brought about some serious discussion about testing ideas and if you haven't read it yet, you should probably check (<a href="http://karolgalanciak.com/blog/2014/01/04/test-driven-rails-part-1/#disqus_thread" target="_blank">it</a>) it out. Giving some general point of view about such broad topic like Test Driven Development / Behavior Driven Development is definetely not enough so I will try to apply these techniques by implementing a concrete feature. I wanted to choose some popular usecase so that most developers will have an opinion how they would approach it. In most applications you will probably need:</p>




<!--more-->


<p></p>

<h2>User Registration</h2>




<p>It is quite common feature and it can be approached in many ways. The most popular is to some authentication gem, like Devise, which is the probably the safest and the fastest way. However, Devise might be an overkill for some cases or maybe you need highly customizable solution. How would you write an implementation fot that usecase then?</p>




<p>Note: the implementation below doesn't aim to be the most secure approach for that feature, it's rather for demonstration purposes. I made some non-standard design decisions for the Rails application, you may want to read one of my <a href="http://karolgalanciak.com/blog/2013/10/06/structuring-rails-applications/" target="_blank">previous posts</a> to get more details why this way of designing code might be beneficial.</p>




<h2>Specification</h2>




<p>We know that we want to implent user registration. Let's say that we want user to confirm his/her account before signing in so we will need to send some confirmation instructions. Also, let's add some admin notifications about new user being registered to make it more interesting.</p>




<p>To make it even better, let's assume that we will create both <code>User</code> and <code>UserProfile</code> during registration: <code>User</code> will have just an <code>email</code> and <code>encrypted_password</code> attributes, <code>UserProfile</code> will have <code>country</code> and <code>age</code> attributes. User will also have to accept some policy to register. If we want to have confirmation, we will also need some attributes for <code>confirmation_token</code>, confirmation date (<code>confirmed_at</code>) and let's add <code>confirmation_instructions_sent_at</code> just to know, when the instructions were sent. These are just registration-specific attributes and we won't need them in most cases so let's extract them to <code>UserRegistrationProfile</code></p>




<p>Note: when writing the implementation and the tests, the following gems were used: <code>rails (4.0.3)</code>, <code>database_cleaner (1.2.0)</code>, <code>simple_form (3.0.1)</code> with <code>country_select (1.3.1)</code>, <code>reform (0.2.4)</code>, <code>bcrypt (3.1.6)</code>, <code>rspec-rails (3.0.0.beta1)</code>, <code>factory_girl_rails (4.3.0)</code> and <code>capybara (2.2.1)</code>.</p>




<h2>Start with acceptance tests</h2>




<p>When writing new feature we should start from acceptance tests - we will make sure that the feature works from the higher level: from the user perspective and some side effects like sending emails. So the good start will be covering user creation and sending emails to an admin and to the user. Let's write some Capybara tests:</p>


<p>``` ruby spec/features/user_registration_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>feature &ldquo;User Registration&rdquo; do</p>

<p>  context &ldquo;when visiting new user path&rdquo; do</p>

<pre><code>background do
  visit new_user_path
end

context "registering with valid data" do

  given(:email) { "myawesome@email.com" }

  background do
    fill_form_with_valid_data(email: email)
  end

  scenario "new user is created" do
    expect do
      register
    end.to change(User, :count).by(1)
  end

  context "notifications" do

    background do
      register
    end

    scenario "confirmation email is sent to the user" do
      expect(all_email_addresses).to include email
    end

    scenario "notification is sent to the admin" do
      expect(all_email_addresses).to include "admin@example.com"
    end

    scenario "2 emails are sent" do
      expect(all_emails.count).to eq 2
    end

  end

end
</code></pre>

<p>  end</p>

<p>end</p>

<p>def fill_form_with_valid_data(args={})
  email = args.fetch(:email, &ldquo;<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#101;&#x6d;&#x61;&#x69;&#x6c;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;">&#x65;&#x6d;&#97;&#x69;&#108;&#x40;&#101;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>&rdquo;)
  fill_in &ldquo;email&rdquo;, with: email
  fill_in &ldquo;user_password&rdquo;, with: &ldquo;my-super-secret-password&rdquo;
  fill_in &ldquo;user_password_confirmation&rdquo;, with: &ldquo;my-super-secret-password&rdquo;
  fill_in &ldquo;age&rdquo;, with: 22
  select &ldquo;Poland&rdquo;, from: &ldquo;country&rdquo;
  check &ldquo;policy&rdquo;
end</p>

<p>def register
  click_button &ldquo;Register&rdquo;
end</p>

<p>```</p>

<p>I like using some helper methods, especially in acceptance tests so I wrote <code>fill_form_with_valid_data</code> and <code>register</code> helpers - these are just some details and I don't need to know them when reading tests. There are also some helpers like <code>all_email_addresses</code> and <code>all_emails</code>, which come from the <code>MailerMacros</code>:</p>


<p>``` ruby spec/support/mailer_macros.rb
module MailerMacros</p>

<p>  def last_email</p>

<pre><code>ActionMailer::Base.deliveries.last
</code></pre>

<p>  end</p>

<p>  def last_email_address</p>

<pre><code>last_email.to.join
</code></pre>

<p>  end</p>

<p>  def reset_email</p>

<pre><code>ActionMailer::Base.deliveries = []
</code></pre>

<p>  end</p>

<p>  def reset_with_delayed_job_deliveries</p>

<pre><code>ActionMailer::Base.deliveries = []
</code></pre>

<p>  end</p>

<p>  def all_emails</p>

<pre><code>ActionMailer::Base.deliveries
</code></pre>

<p>  end</p>

<p>  def all_emails_sent_count</p>

<pre><code>ActionMailer::Base.deliveries.count
</code></pre>

<p>  end</p>

<p>  def all_email_addresses</p>

<pre><code>all_emails.map(&amp;:to).flatten
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>If you like it, just create <code>spec/support/mailer_macros.rb</code>, put the code there and in your <code>spec_helper.rb</code> insert the following lines:</p>


<p><code>ruby spec/spec_helper.rb
config.include(MailerMacros)
config.before(:each) { reset_email }
</code></p>

<p>Also, the select with country might be not clear - the collection with countries comes from <code>country_select</code> gem.</p>




<p>We have some failing acceptance tests, it will take some time to make them all green. Now we can write some migrations:</p>


<p><code>ruby
rails generate model User email encrypted_password
rails generate model UserProfile user_id:integer age:integer country
</code></p>

<p>We also need to add some database constraints, to ensure that users' emails are unique and fields are not null, the migrations would look like this:</p>


<p>``` ruby</p>

<p>class CreateUsers &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :users do |t|
  t.string :email, null: false
  t.string :encrypted_password, null: false

  t.timestamps
end

add_index :users, :email, unique: true
</code></pre>

<p>  end
end</p>

<p>class CreateUserProfiles &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :user_profiles do |t|
  t.integer :age
  t.string :country, null: false
  t.integer :user_id, null: false

  t.timestamps
end
add_index :user_profiles, :user_id
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Now we have to define some routes:</p>


<p>``` ruby config/routes.rb</p>

<p>root to: &ldquo;static_pages#home&rdquo;</p>

<p>resources :users do
end</p>

<p>```</p>

<p>For user registration, we have REST actions: <code>new</code> and <code>create</code>. Let's also add some root page, currently just to get rid of default Rails page:</p>


<p>``` ruby app/controllers/static_pages_controller.rb
class StaticPagesController &lt; ApplicationController</p>

<p>  def home</p>

<p>  end</p>

<p>end
```</p>

<p>But how to deal with <code>UsersController</code> and form for user registration? We have some fields that are not present in models (<code>password/password_confirmation</code> and <code>policy</code>). The popular solution would be using: <code>accepts_nested_attributes_for :profile</code> and some virtual attributes. I don't really like this solution, <code>accepts_nested_attributes_for</code> sometimes can really save a lot of time, especially with complex nested forms with <a href="https://github.com/ryanb/nested_form" target="_blank">nested_form</a> gem. But virtual attributes are quite ugly and they make models the interfaces for forms. Much better approach is to use form objects. There's a great gem for this kind of problems: <code>Reform</code> -  we will use it here.</p>


<p>``` ruby app/controllers/users_controller.rb
class UsersController &lt; ApplicationController</p>

<p>  def new</p>

<pre><code>@registration_form = registration_form
</code></pre>

<p>  end</p>

<p>  def create</p>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)   
end
</code></pre>

<p>end</p>

<p>```</p>

<p>That's it for <code>UsersController</code>, we will need some views and the actual form object:</p>


<p>``` ruby app/views/users/new.html.haml</p>

<p>%h1 User Registration</p>

<p>= simple_form_for @registration_form do |f|
  = f.input :email, label: &ldquo;email&rdquo;
  = f.input :country, label: &ldquo;country&rdquo;, as: :country
  = f.input :age, label: &ldquo;age&rdquo;
  = f.input :password, label: &ldquo;password&rdquo;
  = f.input :password_confirmation, label: &ldquo;password confirmation&rdquo;
  = f.input :policy, label: &ldquo;I accept the policy&rdquo;, as: :boolean
  = f.submit &ldquo;Register&rdquo;</p>

<p>```</p>

<p>And the actual <code>UserRegistrationForm</code>:</p>


<p>``` ruby app/forms/user_registration_form.rb</p>

<p>class UserRegistrationForm &lt; Reform::Form</p>

<p>  include Reform::Form::ActiveRecord
  include Composition</p>

<p>  property :email, on: :user
  property :password, on: :nil, empty: true
  property :password_confirmation, on: :nil, empty: true
  property :age, on: :profile
  property :country, on: :profile
  property :policy, on: :nil, empty: true</p>

<p>  validates :email, presence: true, email: true, uniqueness: { case_sensitive: false }
  validates :password, presence: true, confirmation: true
  validates :age, presence: true
  validates :country, presence: true
  validates :policy, acceptance: true, presence: true</p>

<p>  model :user</p>

<p>end</p>

<p>```</p>

<p>Reform is not (yet) that popular in the Rails community so some things require explanation (check also the <a href="https://github.com/apotonick/reform" target="_blank">docs</a> out). The <code>Reform::Form::ActiveRecord</code> module is for uniqueness validation and the <code>Composition</code> is for... composition - some properties are mapped to user and other to profile. There is also a mystical mapping with <code>on: :nil</code> - these are "virtual" properties like <code>password</code>, <code>password_confirmation</code> and <code>policy</code> - all properties must be mapped to a resource so just to satisfy Reform API I use <code>on: :nil</code> as a convention, also the <code>empty: true</code> option is for virtual attributes that won't be processed. And where does the email validation come from? From our custom validator, let's write some specs but before we should add /forms (and /usecases for business logic) directories to be autoloaded:</p>


<p><code>ruby config/application.rb
config.autoload_paths += %W(#{config.root}/app/usecases)
config.autoload_paths += %W(#{config.root}/app/forms)
</code></p>

<p>``` ruby spec/usecases/email_validator_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>class DummyModel</p>

<p>  include ActiveModel::Validations</p>

<p>  attr_accessor :email</p>

<p>  validates :email, email: true</p>

<p>end</p>

<p>describe EmailValidator do</p>

<p>  let(:model) { DummyModel.new }</p>

<p>  it &ldquo;validates email format&rdquo; do</p>

<pre><code>valid_emails = %w[email@example.com name.surname@email.com 
    e-mail@example.com]

valid_emails.each do |email|
  model.email = email
  expect(model).to be_valid
end

invalid_emails = %w[email @email.com email.example.com 
  email@example email@example.]

invalid_emails.each do |email|
  model.email = email
  expect(model).not_to be_valid
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>You can probably come up with some more examples to cover email validation but these are sufficient cases. I've introduced <code>DummyModel</code> here to have a generic object that can be validated so the <code>ActiveModel::Validations</code> module is needed and an accessor for an email. Let's implement the actual validation:</p>


<p>``` ruby usecases/email_validator.rb</p>

<p>class EmailValidator &lt; ActiveModel::EachValidator</p>

<p>  def validate_each(record, attribute, value)</p>

<pre><code>unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
  record.errors[attribute] &lt;&lt; (options[:message] || "is not a valid email format")
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The regexp for email validation comes from Rails guides:). It won't cover all the possibilities but the <a href="http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html" target="_blank">actual format</a> of the email is an overkill.</p>




<p>I don't fell the need to write tests for other validations and composition for <code>UserRegistrationForm</code>: it's just using very descriptive DSL, the validation are already tested in Rails.</p>




<p>We haven't set up the associations yet in models:</p>


<p>``` ruby app/models/user.rb
class User &lt; ActiveRecord::Base</p>

<p>  has_one :profile, class_name: &ldquo;UserProfile&rdquo;, inverse_of: :user</p>

<p>  validates :email, presence: true, uniqueness: { case_insensitive: false }, email: true
  validates :encrypted_password, presence: true</p>

<p>```</p>

<p>``` ruby app/models/user_profile.rb
class UserProfile &lt; ActiveRecord::Base</p>

<p>  belongs_to :user, inverse_of: :profile</p>

<p>  validates :user, :country, :age, presence: true</p>

<p>end</p>

<p>```</p>

<p>I added also validations in models. These may seem like a duplication because form object already implements them but these are validations always applicable do these models so it is a good idea to have them in models.</p>




<p>Let's concentrate on <code>UsersController</code> and <code>create</code> action. I don't really like testing controllers, especially for CRUD-like stuff, user creation still feels like CRUD but not that typical in Rails, especially when using dedicated form object. So let's test drive registration process: we are going to use <code>UserRegistrationForm</code> for data aggregation and validation - if the data is valid, the user will be created by <code>UserRegistration</code> service object with redirection to root path, otherwise it will render <code>new</code> template.</p>


<p>``` ruby spec/controllers/users_controller_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UsersController do</p>

<p>  describe &ldquo;#create&rdquo; do</p>

<pre><code>let(:registration_form) { instance_double(UserRegistrationForm) }

let(:user_params) { { "email" =&gt; "email@example.com" } }
let(:params) { { user: user_params } }

let(:user_registration) { instance_double(UserRegistration) }

before(:each) do
  allow(UserRegistrationForm).to receive(:new) { registration_form }
  allow(registration_form).to receive(:assign_attributes)
    .with(user_params) { registration_form }
  allow(user_registration).to receive(:register!)
    .with(registration_form) { true }
  allow(UserRegistration).to receive(:new) { user_registration }        
end

context "valid data" do

  before(:each) do
    expect(registration_form).to receive(:valid?) { true }
    post :create, params  
  end

  it "executes registration" do
    expect(user_registration).to have_received(:register!).with(registration_form)
  end

  it "redirects to root path" do
    expect(response).to redirect_to root_path
  end

end

context "invalid data" do

  before(:each) do
    expect(registration_form).to receive(:valid?) { false }
    post :create, params  
  end

  it "renders registration form" do
    expect(response).to render_template :new
  end

end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Well, it is not really clear, that's the problem with testing controllers and they should be as thin as possible. We need to implement the <code>assign_attributes</code>
 method in form object to fill models' attributes with params and implement the actual <code>UserRegistration</code> usecase. In tests I use <code>instance_double</code> 
 instead of simple <code>double</code> to make sure I'm not stubbing non-existent methods or with wrong number of arguments - that's a great feature introduced in RSpec 3, which comes from <a href="https://github.com/xaviershay/rspec-fire" target="_blank">rspec-fire</a> gem. Also, I'm stubbing responses so that I can spy on them using <code>have_received</code> method - It's much cleaner and easier to read. Compare these two examples:</p>


<p>``` ruby</p>

<p>before(:each) do
  expect(registration_form).to receive(:valid?) { true }
  post :create, params<br/>
end</p>

<p>it &ldquo;executes registration&rdquo; do
  expect(user_registration).to have_received(:register!).with(registration_form)
end</p>

<p>it &ldquo;redirects to root path&rdquo; do
  expect(response).to redirect_to root_path
end</p>

<p>```</p>

<p>and</p>


<p>``` ruby</p>

<p>before(:each) do
  expect(registration_form).to receive(:valid?) { true }
end</p>

<p>it &ldquo;executes registration&rdquo; do
  expect(user_registration).to receive(:register!).with(registration_form)
  post :create, params
end</p>

<p>it &ldquo;redirects to root path&rdquo; do
  post :create, params
  expect(response).to redirect_to root_path
end</p>

<p>```</p>

<p>I really encourage you to spy on a stubbed method, I will make your tests much more readable and DRY them up.</p>




<p> I made also some non-standard design decisions here: why not to implement the persistence logic in the form object and use it like:</p>


<p><code>ruby
if @registration_form.persist(user_params) # populate data, perform validation and persist data if is valid
  # happy paths
else
  # failure path
end
</code></p>

<p>For simple persistence logic I would probably go with that approach but we will also need to send some confirmation instructions, admin notifications etc., I'm not really comfortable with the idea of form object knowing something about sending notifications, persistence alone would be ok, it would be quite convenient to use but this is too complex, I would leave form object for data aggregation and validation. Let's write code for the controller:</p>


<p>``` ruby app/controllers/users_controller.rb</p>

<p>class UsersController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>@registration_form = registration_form.assign_attributes(params[:user])

if @registration_form.valid?
  UserRegistration.new.register!(@registration_form)
  redirect_to root_path, notice: "You have register. Please, check your email for confimartion instructions"
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)
end
</code></pre>

<p>end</p>

<p>```</p>

<p>We need to implement <code>assign_attributes</code> method (we have nice failure message thanks to <code>instance_double</code> that informs us about it):</p>


<p>``` ruby
Failure/Error: allow(registration_form).to receive(:assign_attributes)
  UserRegistrationForm does not implement:</p>

<pre><code>assign_attributes
</code></pre>

<p>```</p>

<p>and UserRegistration. Let's start from test for <code>assign_attributes</code> method. It looks like, besides assigning params, it should return itself:</p>


<p>``` ruby spec/forms/user_registration_form_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistrationForm do</p>

<p>  let(:user) { User.new }
  let(:profile) { UserProfile.new }</p>

<p>  subject { UserRegistrationForm.new(user: user, profile: profile) }</p>

<p>  describe &ldquo;#assign_attributes&rdquo; do</p>

<pre><code>it "populates models' attributes with params" do
  subject.assign_attributes("email" =&gt; "email@example.com", "country" =&gt; "Poland")
  expect(subject.user.email).to eq "email@example.com"
  expect(subject.profile.country).to eq "Poland"
end

it "assigns profile to user" do
  subject.assign_attributes({})
  expect(user.profile).to eq profile
end

it "returns self" do
  expect(subject.assign_attributes({})).to eq subject
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And the code for implementation:</p>


<p>``` ruby app/forms/user_registration_form.rb</p>

<p>def assign_attributes(params)
  from_hash(params)
  save_to_models
  self
end</p>

<p>```</p>

<p>It uses some Reform::Form private methods that I found in source code so this implementation might not be stable but fortunately we have it covered in tests so we will know breaking changes if it happens in next versions. And there's a gotcha here: The keys in hash must be stringified, symbols won't work (applies to 0.2.4 version of Reform).</p>




<p>Let's write some minimal implementation for <code>UserRegistration</code> to satisfy controller's specs:</p>


<p>``` ruby app/usecases/user_registration.rb
class UserRegistration</p>

<p>  def register!(aggregate)</p>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And what the <code>UserRegistration</code> should be responsible for? Let's start with persistence logic: user with it's profile must be created and the encrypted password should be assigned to the user. We will also need registration profile to be created.</p>


<p>``` ruby spec/usecases/user_registration_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistration do</p>

<p>  let(:user) { FactoryGirl.build_stubbed(:user) }
  let(:profile) { FactoryGirl.build_stubbed(:user_profile) }</p>

<p>  let(:form) { double(:form, user: user, profile: profile,</p>

<pre><code>password: "password") }
</code></pre>

<p>  subject { UserRegistration.new(encryption: encryption) }</p>

<p>  let(:encrypted_password) { &ldquo;encrypted_password&rdquo; }</p>

<p>  let(:encryption) { instance_double(Encryption,</p>

<pre><code> generate_password: encrypted_password) }
</code></pre>

<p>  context &ldquo;persistence is success&rdquo; do</p>

<pre><code>before(:each) do
  allow(user).to receive(:save!) { true }
  allow(profile).to receive(:save!) { true }
  allow(user).to receive(:create_registration_profile!) { true }
end

before(:each) do
  subject.register!(form)
end

specify "user gets encrypted password" do  
  expect(user.encrypted_password).to eq encrypted_password
end

it "saves user" do
  expect(user).to have_received(:save!)
end

it "creates profile for user" do
  expect(profile).to have_received(:save!)
end

it "create registration profile for user" do
  expect(user).to have_received(:create_registration_profile!)
end
</code></pre>

<p>  end</p>

<p>  context &ldquo;persistence fails&rdquo; do</p>

<pre><code>it "raises RegistrationFailed error" do
  allow(user).to receive(:save!) { raise_error ActiveRecord::RecordInvalid }
   expect do
    UserRegistration.new.register!(form)
  end.to raise_error UserRegistration::RegistrationFailed
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Note: keep in mind that you should write one test and then write minimal implementation to make it pass and then another test. I gave the several tests and the actual <code>UserRegistration</code> in advance, just to make it easier to read and follow.</p>




<p>It is quite clear from the tests what should be expected from this class: creation of user, profile, registration profile and assigning encrypted password. Data aggregate (<code>form</code>) is just a <code>double</code> with profile and user, we don't care what it actually is, it should just implement the stubbed interface. I also use FactoryGirl and <code>build_stubbed</code> method for initializing models - I find it more convenient than to use <code>instance_double</code> because instance doubles don't cover attributes from database tables.</p>




<p>The factories for User and profiles would look like that:</p>


<p>``` ruby spec/factories.rb</p>

<p>  FactoryGirl.define do</p>

<p>  factory :user do</p>

<pre><code>email "email@example.com"
# I'll explain that later, why it is that long
encrypted_password "$2a$10$bcMccS3q2egnNICPLYkptOoEyiUpbBI5Q.GAKe0or2QB7ij6yCeOa" 
</code></pre>

<p>  end</p>

<p>  factory :user_profile do</p>

<pre><code>age 22
country "Poland"
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And the actual implementation:</p>


<p>``` ruby app/usecases/user_registration.rb</p>

<p>class UserRegistration</p>

<p>  class RegistrationFailed &lt; StandardError ; end</p>

<p>  attr_reader :encryption
  private :encryption</p>

<p>  def initialize(options={})</p>

<pre><code>@encryption = options.fetch(:encryption, Encryption.new)
</code></pre>

<p>  end</p>

<p>  def register!(aggregate)</p>

<pre><code>user = aggregate.user
profile = aggregate.profile
user.encrypted_password = encrypted_password(aggregate.password)
ActiveRecord::Base.transaction do
  begin
    user.save!
    profile.save!
    user.create_registration_profile!
  rescue ::ActiveRecord::StatementInvalid, ::ActiveRecord::RecordInvalid =&gt; e
    raise_registration_error(e)
  end
end  
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def raise_registration_error(errors)
  message =  "Registration Failed due to the following errors: #{errors}"      
  raise UserRegistration::RegistrationFailed, message
end

def encrypted_password(password)
  encryption.generate_password(password)
end
</code></pre>

<p>end</p>

<p>```</p>

<p>Let's discuss some design decisions: the constructor accepts options hash so that we can inject dependencies like <code>encryption</code> and to provide defaults if it's injected. The persistence logic is wrapped in transaction block so that e.g. user won't be created if profile creation fails. If it fails, <code>RegistrationFailed</code> error is raised with a descriptive message. Also, the <code>encryption</code> is private: we don't need it to be public.</p>




<p>To satisfy tests, the <code>create_registration_profile!</code> must be implemented and <code>generate_password</code> for encryption. Fortunately, we just need to setup associations for <code>UserRegistrationProfile</code> to have <code>create_registration_profile!</code> implemented. But we need to generate the model first:</p>


<p><code>ruby
rails generate model UserRegistrationProfile confirmed_at:datetime confirmation_instructions_sent_at:datetime confirmation_token user_id:integer
</code></p>

<p>let's set up some database constraints in generated migration:</p>


<p>``` ruby</p>

<p>class CreateUserRegistrationProfiles &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :user_registration_profiles do |t|
  t.datetime :confirmed_at
  t.datetime :confirmation_instructions_sent_at
  t.string :confirmation_token
  t.integer :user_id, null: false

  t.timestamps
end

add_index :user_registration_profiles, :user_id
add_index :user_registration_profiles, :confirmation_token, unique: true
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>and then write the associations:</p>


<p>``` ruby app/models/user.rb</p>

<p>class User &lt; ActiveRecord::Base</p>

<p>  has_one :registration_profile, class_name: &ldquo;UserRegistrationProfile&rdquo;, inverse_of: :user</p>

<p>end</p>

<p>```</p>

<p>``` ruby app/models/user_registration_profile.rb</p>

<p>class UserRegistrationProfile &lt; ActiveRecord::Base</p>

<p>  belongs_to :user, inverse_of: :registration_profile</p>

<p>  validates :user, presence: true</p>

<p>end</p>

<p>```</p>

<p>The minimal implementation for <code>Encryption</code> to make the <code>UserRegistration</code> tests happy is the following:</p>


<p>``` ruby app/usecases/encryption.rb</p>

<p>class Encryption</p>

<p>  def generate_password(phrase)
  end</p>

<p>end</p>

<p>```</p>

<p>To finish the user creation we have to implement the password generation. Bcrypt and it's <code>create</code> password method is a reasonable choice here. Let's write the tests:</p>


<p>``` ruby spec/usecases/encryption_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe Encryption do</p>

<p>  subject { Encryption.new }</p>

<p>  let(:password) { &ldquo;password&rdquo; }
  let(:encypted_password) { &ldquo;$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa&rdquo; }
  let(:password_generator) { class_double(BCrypt::Password).as_stubbed_const }</p>

<p>  before(:each) do</p>

<pre><code>allow(password_generator).to receive(:create).with(password) { encypted_password }
</code></pre>

<p>  end</p>

<p>  it &ldquo;creates password using Bcrypt as default&rdquo; do</p>

<pre><code>expect(subject.generate_password(password)).to eq encypted_password
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The <code>encrypted_password</code> doesn't have to be that long but looks more genuine that way. The BCrypt::Password is also a class double so that we make sure we don't stub a non-existent method. And the implementation of <code>Encryption</code> class:</p>


<p>``` ruby app/usecases/encryption.rb</p>

<p>class Encryption</p>

<p>  attr_reader :password_generator
  private :password_generator</p>

<p>  def initialize(args={})</p>

<pre><code>@password_generator = args.fetch(:password_generator, BCrypt::Password)
</code></pre>

<p>  end</p>

<p>  def generate_password(phrase)</p>

<pre><code>password_generator.create(phrase)
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The pattern for constructor is similar to the one from <code>UserRegistration</code>. The <code>password_generator</code> is also made private - the rule of thumb is that everything should be private unless it needs to be public, just to keep the interfaces clean.</p>




<p>Now we have the basic implementation for user creation with it's profiles. Still, we need confirmation stuff and notification to tje admin. It is beyond the <code>UserRegistration</code> responsibilities, we also don't need always to a notification or confirmation instructions or to confirm user at all, just to have the interface flexible enough. Maybe we will have some additional things that will take place during registration - like third party API notification. To keep the responsibilities separate and <code>UserRegistration</code> easy to use, we can implement all the additional actions as the listeners that are being passed to the constructor of <code>UserRegistration</code>. Let's write specs for it first:</p>


<p>``` ruby spec/usecases/user_registration_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistration do</p>

<p>  # same code a before</p>

<p>  context &ldquo;persistence is success&rdquo; do</p>

<pre><code># same code a before

# and this is new:

context "with listeners" do

  let(:user_confirmation) { double(:user_confirmation, 
    notify: true) }
  let(:admin_notification) { double(:admin_notification,
    notify: true) }

  before(:each) do
    UserRegistration.new(user_confirmation, admin_notification,
      encryption: encryption).register!(form)
  end

  it "notifies user_confirmation listener" do
    expect(user_confirmation).to have_received(:notify).with(user)
  end

  it "notifies admin_notificaiton listener" do
    expect(admin_notification).to have_received(:notify).with(user)
  end

end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>We don't actually care what the listeners are, the only requirement is that they must implement the same interface: <code>notify</code> method which takes <code>user</code> argument. And the implementation:</p>


<p>``` ruby app/usecases/user_registration.rb</p>

<p>class UserRegistration</p>

<p>  class RegistrationFailed &lt; StandardError ; end</p>

<p>  attr_reader :encryption, :listeners
  private :encryption, :listeners</p>

<p>  def initialize(*listeners, **options)</p>

<pre><code>@listeners = listeners
@encryption = options.fetch(:encryption, Encryption.new)
</code></pre>

<p>  end</p>

<p>  def register!(aggregate)</p>

<pre><code>user = aggregate.user
profile = aggregate.profile
user.encrypted_password = encrypted_password(aggregate.password)
ActiveRecord::Base.transaction do
  begin
    user.save!
    profile.save!
    user.create_registration_profile!
  rescue ::ActiveRecord::StatementInvalid, ::ActiveRecord::RecordInvalid =&gt; e
    raise_registration_error(e)
  end
end  
notify_listeners(user)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def raise_registration_error(errors)
  message =  "Registration Failed due to the following errors: #{errors}"      
  raise UserRegistration::RegistrationFailed, message
end

def encrypted_password(password)
  encryption.generate_password(password)
end

def notify_listeners(user)
  listeners.each do |listener|
    listener.notify(user)
  end
end
</code></pre>

<p>end</p>

<p>```</p>

<p>These changes are not that noticeable but they are huge. The constructor now takes some listeners (splat) - we can pass one listener, several or none, it will always be an array. Also, the options is now a keyword argument introduced in Ruby 2.0 which makes the changes really smooth. And the new method: <code>notify_listeners</code> which sends <code>notify</code> message to all the listeners with <code>user</code> argument.</p>




<p>To handle the user confirmation stuff we will need, well, <code>UserConfirmation</code> and <code>UserRegistrationAdminNotification</code> to handle the notifcations.</p>




<p>Let's start with <code>UserConfirmation</code>. We need <code>notify</code> method which will take care of: assigning confirmation token, which must be unique, setting date when the confirmation instructions were sent and sending the instructions. We will need some mailer here (<code>UserConfirmationMailer</code>), clock (<code>DateTime</code>) and something to generate token - <code>SecureRandom</code> will be a good fit here with it's <code>base64</code> method. Let's translate the specification to the tests:</p>


<p>``` ruby spec/factories.rb</p>

<p>FactoryGirl.define do</p>

<p>  # same as before</p>

<p>  factory :user_registration_profile do # this in new here</p>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>``` ruby spec/usecases/user_confirmation_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserConfirmation do</p>

<p>  describe &ldquo;#notify&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user, 
  registration_profile: FactoryGirl.build_stubbed(:user_registration_profile)) }

let(:mailer_stub) { double(:mailer, deliver: true) }

let!(:mailer) { class_double(UserConfirmationMailer,
  send_confirmation_instructions: mailer_stub).as_stubbed_const }

let(:confirmation_instructions_sent_date) { DateTime.new(2014, 2, 23, 21, 0, 0)}
let(:clock) { double(:clock, now: confirmation_instructions_sent_date) }

subject { UserConfirmation.new(mailer: mailer, clock: clock) }

before(:each) do
  allow(user).to receive(:save_with_profiles!)
  allow(SecureRandom).to receive(:base64) { "token" }
  subject.notify(user)
end

it "assigns confirmation token to user" do
  expect(user.confirmation_token).to eq "token"
end

it "sends email with confirmation instructions" do
  expect(mailer).to have_received(:send_confirmation_instructions).with(user)
end

it "sets date when the confirmation instructions have been sent" do
  expect(user.confirmation_instructions_sent_at).to eq confirmation_instructions_sent_date
end

it "persists new data" do
  expect(user).to have_received(:save_with_profiles!)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Like before, we should start with one test, make it pass and then write the next one. Here is the implementation for it:</p>


<p>``` ruby app/usecases/user_confirmation.rb</p>

<p>class UserConfirmation</p>

<p>  attr_reader :mailer, :clock
  private :mailer, :clock</p>

<p>  def initialize(args={})</p>

<pre><code>@mailer = args.fetch(:mailer, UserConfirmationMailer)
@clock = args.fetch(:clock, DateTime)
</code></pre>

<p>  end</p>

<p>  def notify(user)</p>

<pre><code>assign_confirmation_token(user)
user.confirmation_instructions_sent_at = clock.now
mailer.send_confirmation_instructions(user).deliver
user.save_with_profiles!
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def assign_confirmation_token(user)
  begin
    user.confirmation_token = SecureRandom.base64(20)
  end while User.find_by_confirmation_token(user.confirmation_token).present?
end
</code></pre>

<p>end</p>

<p>```</p>

<p>The pattern for constructor is similar to the previous ones: provide the way to inject dependencies and some defaults if they are not specified so it is more flexible, less coupled and the testing becomes easier as a bonus. We have while loop to ensure the confirmation token is unique amongst users. The <code>find_by_attribute</code> methods are deprecated since Rails 4.0.0 and the <code>activerecord-deprecated_finders</code> will be removed from dependencies in 4.1.0 so we have to implement our own finder method. Here are also some important design decisions - we assign both <code>confirmation_instructions_sent_at</code> and <code>confirmation_token</code> to the user, not the registration profile. How is that? The important question is: do we need to expose that the user has registration profile? What if we change our mind and decide to put this data in "normal" profile, not registration profile? Or we didn't make a decision to create a registration profile at all in a first place and these attributes belonged to the user since the beginning and we later decided to move them to a separated table? From the <code>UserConfirmation</code> perspective, it is just an implementation detail. The <code>save_with_profiles!</code> is provided to make user's data persistence more convenient. We need to implement mailer as well but let's start with user's related stuff.</p>


<p>``` ruby spec/models/user.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe User do</p>

<p>  subject { User.new(email: &ldquo;<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x65;&#109;&#97;&#x69;&#108;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#101;&#x6d;&#x61;&#x69;&#x6c;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a>&rdquo;,</p>

<pre><code>encrypted_password: "password") }
</code></pre>

<p>  describe &ldquo;.find_by_confirmation_token&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.create(:user) }

before(:each) do
  FactoryGirl.create(:user_registration_profile,
    confirmation_token: "token", user_id: user.id)
end

it "finds user with specified confirmation token" do
  expect(User.find_by_confirmation_token("token")).to eq user
end
</code></pre>

<p>  end</p>

<p>  describe &ldquo;#confirmation_token=&rdquo; do</p>

<pre><code>it "assigns confirmation token to user" do
  subject.confirmation_token = "token"
  expect(subject.confirmation_token).to eq "token"
end
</code></pre>

<p>  end</p>

<p>  describe &ldquo;#confirmation_instructions_sent_at=&rdquo; do</p>

<pre><code>it "assigns confirmation instructions sent date to user" do
  date = DateTime.now
  subject.confirmation_instructions_sent_at = date
  expect(subject.confirmation_instructions_sent_at).to eq date
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The <code>find_by_confirmation_token</code> finder method is pretty easy but it involves another table with registration profile so I decided to write test for it. The tests also suggest that we need readers for these attributes, not only the writers. Let's use <code>delegate</code> macro from ActiveSupport for it:</p>


<p>``` ruby app/models/user.rb</p>

<p>class User &lt; ActiveRecord::Base</p>

<p>  # the same code as before</p>

<p>  # new code</p>

<p>  delegate :confirmation_token, :confirmation_instructions_sent_at, :confirmed_at,</p>

<pre><code> to: :registration_profile, allow_nil: true
</code></pre>

<p>  def self.find_by_confirmation_token(token)</p>

<pre><code>joins(:registration_profile)
  .where("user_registration_profiles.confirmation_token = ?", token)
  .first
</code></pre>

<p>  end</p>

<p>  def confirmation_token=(token)</p>

<pre><code>ensure_registration_profile_exists
registration_profile.confirmation_token = token
</code></pre>

<p>  end</p>

<p>  def confirmation_instructions_sent_at=(date)</p>

<pre><code>ensure_registration_profile_exists
registration_profile.confirmation_instructions_sent_at = date
</code></pre>

<p>  end</p>

<p>  def save_with_profiles!</p>

<pre><code>User.transaction do
  save!
  profile.save! if profile
  registration_profile.save! if registration_profile
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def ensure_registration_profile_exists
  build_registration_profile if registration_profile.blank?
end
</code></pre>

<p>```</p>

<p>Before making any assignment, we have to make sure that the registration profile exists. The same applies to the persistence, which is again wrapped in a transaction. And let's implement the mailer for sending confirmation instructions:</p>


<p><code>ruby
rails generate mailer UserConfirmationMailer send_confirmation_instructions
</code></p>

<p>Some basic tests to prove that the mailer actually works:</p>


<p>``` ruby spec/mailers/user_confirmation_mailer_spec.rb</p>

<p>require &ldquo;spec_helper&rdquo;</p>

<p>describe UserConfirmationMailer do</p>

<p>  describe &ldquo;#send_confirmation_instructions&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user, email: "email@example.com",
  registration_profile: FactoryGirl.build_stubbed(:user_registration_profile,
  confirmation_token: "token"))
}

let(:mail) { UserConfirmationMailer.send_confirmation_instructions(user) }

it "has proper subject" do
  expect(mail.subject).to eq("Confirmation Instructions")
end

it "sends email to the user" do
  expect(mail.to).to eq([user.email])
end

it "has link to confirm account" do
  url = "/confirmations/#{user.confirmation_token}"
  expect(mail.body.encoded).to match(url)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The setup with FactoryGirl may seem to be complex but I like doing this kind of setup manually, not to rely on predefined attributes for the factory so that I know where the data comes from. We also assume that there will be some controller action for confirmations so we will need to define routes to make the tests pass:</p>


<p>``` ruby app/mailers/user_confirmation_mailer.rb</p>

<p>  class UserConfirmationMailer &lt; ActionMailer::Base</p>

<p>  default from: &ldquo;<a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x63;&#111;&#x6e;&#x74;&#97;&#99;&#116;&#64;&#x65;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#99;&#x6f;&#110;&#116;&#97;&#x63;&#x74;&#64;&#101;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>&rdquo;</p>

<p>  def send_confirmation_instructions(user)</p>

<pre><code>@user = user
mail(to: user.email, subject: "Confirmation Instructions")
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>``` html app/views/user_confirmation_mailer/send_confirmation_instructions.html.erb</p>

<p>To complete the registration process, click the link below:</p>


<p>&lt;%= link_to &ldquo;Confirm&rdquo;, user_confirmation_path(token: @user.confirmation_token) %></p>

<p>```</p>

<p>And the route with a controller action:</p>


<p>``` ruby config/routes.rb</p>

<p>  get &lsquo;/confirmations/:token&rsquo;, to: &ldquo;confirmations#confirm&rdquo;, as: :user_confirmation</p>

<p>```</p>

<p>``` ruby app/controllers/confirmations_controller.rb</p>

<p>class ConfirmationsController &lt; ApplicationController</p>

<p>  def confirm</p>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And add the listener in <code>UsersController</code>:</p>


<p>``` ruby app/controllers/users_controller.rb</p>

<p>  def create</p>

<pre><code>@registration_form = registration_form.assign_attributes(params[:user])

if @registration_form.valid?
  UserRegistration.new(
    UserConfirmation.new
  ).register!(@registration_form)
  redirect_to root_path, notice: "You have register. Please, check your email for confimartion instructions"
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)   
end
</code></pre>

<p>```</p>

<p>To make all the tests happy, we need some to send a notification to the admin. It looks like <code>UserRegistrationAdminNotification</code> will be just an adapter layer for <code>NewUserAdminNotificationMailer</code> to provide the listener interface. The tests and the implementation are quite simple:</p>


<p>``` ruby spec/usecases/user_registration_admin_notification_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistrationAdminNotification do</p>

<p>  describe &ldquo;#notify&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user) }

let(:mailer_stub) { double(:mailer, deliver: true) }

let!(:mailer) { class_double(NewUserAdminNotificationMailer,
  notify: mailer_stub).as_stubbed_const }

subject { UserRegistrationAdminNotification.new(mailer: mailer) }

before(:each) do
  subject.notify(user)
end

it "sends email to admin about new user being registered" do
  expect(mailer).to have_received(:notify).with(user)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The implementation:</p>


<p>``` ruby app/usecases/user_registration_admin_notification.rb</p>

<p>class UserRegistrationAdminNotification</p>

<p>  attr_reader :mailer
  private :mailer</p>

<p>  def initialize(args={})</p>

<pre><code>@mailer = args.fetch(:mailer, NewUserAdminNotificationMailer)
</code></pre>

<p>  end</p>

<p>  def notify(user)</p>

<pre><code>mailer.notify(user).deliver
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>We also need to generate the mailer with <code>notify</code> method (yes, the same as for the listener but it is good enough here):</p>


<p><code>ruby
rails generate mailer NewUserAdminNotificationMailer notify
</code></p>

<p>and the simple implementation to make the tests green:</p>


<p>``` ruby app/mailers/new_user_admin_notification_mailer.rb</p>

<p>class NewUserAdminNotificationMailer &lt; ActionMailer::Base</p>

<p>  default from: &ldquo;<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x63;&#111;&#110;&#x74;&#x61;&#x63;&#116;&#x40;&#101;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;">&#x63;&#111;&#x6e;&#x74;&#97;&#x63;&#x74;&#x40;&#101;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#109;</a>&rdquo;</p>

<p>  def notify(user)</p>

<pre><code>@user = user
mail(to: "admin@example.com", subject: "New User Registration")
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Now the tests for the mailer and we are almost finished with the registration:</p>


<p>``` ruby spec/mailers/new_user_admin_notification_mailer_spec.rb</p>

<p>require &ldquo;spec_helper&rdquo;</p>

<p>describe NewUserAdminNotificationMailer do</p>

<p>  describe &ldquo;#notify&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user, email: "email@example.com") }

let(:mail) { NewUserAdminNotificationMailer.notify(user) }

it "sends email to the admin" do
  expect(mail.to).to eq(["admin@example.com"])
end

it "has link to confimartion in the body" do
  expect(mail.body.encoded).to match(user.email)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The views for the mailer:</p>


<p>``` ruby app/views/new_user_admin_notification_mailer/notify.html.erb</p>

<p><p>New user with email: &lt;%= @user.email %> has registered</p></p>

<p>```</p>

<p><p>And the listener for <code>UserRegistrationAdminNotification</code> in <code>UserRegistrationAdminNotification.new</code>:</p></p>

<p>``` ruby app/controllers/users_controller.rb</p>

<p>  def create</p>

<pre><code>@registration_form = registration_form.assign_attributes(params[:user])

if @registration_form.valid?
  UserRegistration.new(
    UserConfirmation.new,
    UserRegistrationAdminNotification.new
  ).register!(@registration_form)
  redirect_to root_path, notice: "You have register. Please, check your email for confimartion instructions"
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)   
end
</code></pre>

<p>```</p>

<p><p>Hell yeah, all tests are happy now, we have completed the user registration feature. Let&rsquo;s add account confirmation feature and simple sign in. We don&rsquo;t need acceptance test or integration test in controller for that feature, it&rsquo;s pretty simple and unit test for controller would be enough. We probably need to find user by confirmation token, confirm the account and redirect to some page. Also, we should return 404 error if there&rsquo;s no match for confirmation token. In a real world application it would probably need some expiration date for token and other features but keep in a mind it&rsquo;s just for demonstration purposes, not writing the complete devise-like solution.</p></p>

<p>``` ruby spec/controllers/confirmations_controller_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe ConfirmationsController do</p>

<p>  describe &ldquo;#confirm&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user,
  registration_profile: FactoryGirl.build_stubbed(:user_registration_profile,
    confirmation_token: "token")) }
let(:factory) { class_double(User).as_stubbed_const }

before(:each) do
  allow(factory).to receive(:find_by_confirmation_token!)
    .with(user.confirmation_token) { user }
end

it "it confirms user and redirects to root path" do
  expect(user).to receive(:confirm!) { true }
  get :confirm, token: user.confirmation_token
  expect(response).to redirect_to root_path
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>We find the user with bang method so, by convention, it raises ActiveRecord::RecordNotFound if the resource is not found &ndash; we won&rsquo;t write test for the failure path. Then the  <code>confirm!</code> method is used which needs to be implemented and redirect to root path. The implementation for the controller is the following:</p></p>

<p>``` ruby app/controllers/confirmations_controller.rb</p>

<p>class ConfirmationsController &lt; ApplicationController</p>

<p>  def confirm</p>

<pre><code>user = User.find_by_confirmation_token!(params[:token]) 
user.confirm!
redirect_to root_path, notice: "You have confirmed you account. Now you can login."
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>Now we need to implement <code>confirm!</code> and <code>find_by_confirmation_token!</code> methods:</p></p>

<p>``` ruby spec/models/user_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe User do</p>

<p>  subject { User.new(email: &ldquo;<a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#101;&#x6d;&#97;&#105;&#108;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#x65;&#x6d;&#x61;&#x69;&#108;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#109;</a>&rdquo;,</p>

<pre><code>encrypted_password: "password") }
</code></pre>

<p>  # some old code</p>

<p>  describe &ldquo;#confirm!&rdquo; do</p>

<pre><code>let(:date) { DateTime.new(2014, 02, 23, 22, 6, 0) }

before(:each) do
  allow(DateTime).to receive(:now) { date }
  subject.confirm!
end

it "assigns confirmation date with current date" do
  expect(subject.confirmed_at).to eq date
end

it "persists user and the profile" do
  expect(subject.registration_profile.persisted?).to eq true
  expect(subject.persisted?).to eq true
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>It would be quite convenient to use <code>confirm!</code> method for new user and make it persisted. I don&rsquo;t feel a need to write test for <code>find_by_confirmation_token!</code> as it is really simple and will use <code>find_by_confirmation_token</code>.</p></p>

<p>``` ruby app/models/user.rb</p>

<p>class User &lt; ActiveRecord::Base</p>

<p>  def self.find_by_confirmation_token!(token)</p>

<pre><code>user = find_by_confirmation_token(token)
if user.blank?
  raise ActiveRecord::RecordNotFound
else
  user
end
</code></pre>

<p>  end</p>

<p>  def confirm!</p>

<pre><code>ensure_profile_exists
registration_profile.confirmed_at = DateTime.now
save_with_profiles!
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def ensure_registration_profile_exists
  build_registration_profile if registration_profile.blank?
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>It&rsquo;s another method in <code>User</code> model, shouldn&rsquo;t the models be thin? Well, it&rsquo;s not business logic involving some complex actions, these are just domain methods for user to handle it&rsquo;s own state (or the profile&rsquo;s state which is rather an implementation detail in this case), it looks like a model&rsquo;s responsibility so it&rsquo;s a right place to add this kind of logic, much better than using e.g. <code>update</code> method on registration profile outside the models.</p></p>

<p><p>We completed another feature: user can confirm his/her account. There&rsquo;s only one feature left: sign in. Let&rsquo;s test drive it starting from acceptance test again: when the user exists and is confirmed, we let the user sign in, if exists but is not confirmed yet we render proper info and if the email/password combination is invalid we also want to display proper info. Capybara test for these specs may look like this:</p></p>

<p>``` ruby spec/features/sign_in_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>feature &ldquo;Sign In&rdquo; do</p>

<p>  context &ldquo;user is confirmed&rdquo; do</p>

<pre><code>given!(:user) { FactoryGirl.create(:user, 
registration_profile: FactoryGirl.build(:user_registration_profile,
  confirmed_at: DateTime.now)) }

describe "with valid data" do

  background do
    visit sign_in_path
    fill_in_sign_in_form_with_valid_data(user)
    sign_in
  end

  scenario "user signs in and and shows success message" do
    expect(page).to have_content "You have successfully signed in"    
  end

  scenario "after sign in user sees it's email" do        
    expect(page).to have_content user.email  
  end

end

describe "with invalid data" do

  scenario "signin is prohibited and user sees error message
    with wrong email/password combination" do
    visit sign_in_path
    fill_in_sign_in_form_with_invalid_data(user)
    sign_in
    expect(page).to have_content "Wrong email/password combination"    
  end

end
</code></pre>

<p>  end</p>

<p>  context &ldquo;user is not confirmed&rdquo; do</p>

<pre><code>given!(:user) { FactoryGirl.create(:user, 
registration_profile: FactoryGirl.build(:user_registration_profile)) }

background do
  visit sign_in_path
  fill_in_sign_in_form_with_valid_data(user)
  sign_in
end

scenario "signin is prohibited and user sees info about unconfirmed account" do
  expect(page).to have_content "You must confirm your account"    
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>def fill_in_sign_in_form_with_valid_data(user)
  fill_in &ldquo;email&rdquo;, with: user.email
  fill_in &ldquo;password&rdquo;, with: &ldquo;password&rdquo;
end</p>

<p>def fill_in_sign_in_form_with_invalid_data(user)
  fill_in &ldquo;email&rdquo;, with: user.email
  fill_in &ldquo;password&rdquo;, with: &ldquo;wrong_password&rdquo;
end</p>

<p>def sign_in
  click_button &ldquo;Sign in&rdquo;
end</p>

<p>```</p>

<p><p>The structure is similar to the one from registration process: there are some helper methods for filling forms and signing in. For the happy path, we also want to verify that the user is actually signed in so we will display it&rsquo;s email. This test will work because in <code>User</code> factory in <code>spec/factories.rb</code> the <code>encrypted_password</code> value is an encrypted form of &ldquo;password&rdquo; phrase. Let&rsquo;s start from defining routes and creating controller for the user signin:</p></p>

<p>``` ruby config/routes.rb</p>

<p>resources :sessions, except: [:new]</p>

<p>get &lsquo;/sign_in&rsquo;, to: &ldquo;sessions#new&rdquo;, as: :sign_in</p>

<p>```</p>

<p>``` ruby app/controllers/sessions_controller.rb</p>

<p>class SessionsController &lt; ApplicationController</p>

<p>  def new</p>

<p>  end</p>

<p>  def create</p>

<p>  end</p>

<p>```</p>

<p><p>and the view layer:</p></p>

<p>``` ruby app/views/sessions/new.html.haml</p>

<p>= display_messages</p>

<p>%h1 Sign In</p>

<p>= simple_form_for :sign_in, url: :sessions, method: :post do |f|
  = f.input :email, label: &ldquo;email&rdquo;
  = f.input :password, label: &ldquo;password&rdquo;
  = f.submit &ldquo;Sign in&rdquo;</p>

<p>```</p>

<p><p>Where does the <code>display_messages</code> helper comes from? It&rsquo;s a simple helper for displaying flash messages which can be implemented as follows:</p></p>

<p>``` ruby app/helpers/application_helper.rb</p>

<p>module ApplicationHelper</p>

<p>  def display_messages</p>

<pre><code>case
when flash[:notice]
  display_flash_message(flash[:notice], "alert-success")
when flash[:error]
  display_flash_message(flash[:error], "alert-error")
when flash[:alert]
  display_flash_message(flash[:alert], "alert-error")
end
</code></pre>

<p>  end</p>

<p>  def display_flash_message(message, class_name)</p>

<pre><code>content_tag(:div, class: "alert centerize-text #{class_name}") do
  message
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>Let&rsquo;s also update the root page:</p></p>

<p>``` ruby app/views/static_pages/home.html.haml</p>

<p>= display_messages
&ndash; if current_user
  %h1 Welcome
  = current_user.email</p>

<p>```
<p>Let&rsquo;s stick to the convention and name the helper method with current user the <code>current_user</code>. The signin process is already covered by acceptance test so we won&rsquo;t benefit much from writing controller&rsquo;s test. To keep track of current user, we will store it&rsquo;s id in a session. The implementation might be following:</p></p>

<p>``` ruby app/controllers/sessions_controller.rb</p>

<p>class SessionsController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>user = User.find_by(email: sign_in_params[:email])

return wrong_combination_of_email_or_password if user.blank?
return user_not_confirmed if !user.confirmed?

if Authentication.authenticate(user.encrypted_password, sign_in_params[:password])
  sign_in(user)
  redirect_to root_path, notice: "You have successfully signed in"
else
  wrong_combination_of_email_or_password
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def sign_in_params
  params.require(:sign_in).permit(:email, :password)
end

def sign_in(user)
  session[:user_id] = user.id
end

def wrong_combination_of_email_or_password
  flash.now[:error] = "Wrong email/password combination"
  render :new
end

def user_not_confirmed
  flash.now[:error] = "You must confirm your account"
  render :new
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>And for the <code>current_user</code>:</p></p>

<p>``` ruby app/controllers/application_controller.rb</p>

<p>class ApplicationController &lt; ActionController::Base
  # Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  protect_from_forgery with: :exception</p>

<p>  helper_method :current_user</p>

<p>  private</p>

<pre><code>def current_user
  @current_user ||= User.find(session[:user_id]) if session[:user_id].present?
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>The last step is to implement <code>Authentication</code> module with authenticate method, which compares encrypted password with plain password. Let&rsquo;s start with a test:</p></p>

<p>``` ruby spec/usecases/authentication_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe Authentication do</p>

<p>  describe &ldquo;.authenticate&rdquo; do</p>

<pre><code>let(:encrypted_password) { "$2a$10$bcMccS3q2egnNICPLYkptOoEyiUpbBI5Q.GAKe0or2QB7ij6yCeOa" }

it "returns true if encrypted password is specified password" do
  expect(Authentication.authenticate(encrypted_password,
    "password")).to eq true
end

it "returns false if encrypted password in not specified password" do
  expect(Authentication.authenticate(encrypted_password,
    "wrong_password")).to eq false
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p> I don&rsquo;t need to create an instance of <code>Authentication</code>, there is no need to make it a class. And to make all the tests green we just need to implement comparison of passwords using Bcrypt:</p></p>

<p>``` ruby app/usecases/authentication.rb</p>

<p>module Authentication</p>

<p>  def self.authenticate(encrypted_password, password)</p>

<pre><code>BCrypt::Password.new(encrypted_password) == password
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><h2>Wrapping up</h2></p>

<p><p>That&rsquo;s all! All the tests now pass. And they run pretty fast (on Ruby 2.1.0), about 1.6 s. That was quite long: the user registration, confirmation and sign in features have been test drived and some not obvious design decisions were made. That gives some basic ideas how I apply Test Driven Development / Behavior Driven Development techniques in everyday Rails programming. The aim of these tests wasn&rsquo;t to have 100% coverage (e.g. I didn&rsquo;t test ActiveModel validations, using Reform DSL to make <code>UserRegistrationForm</code> composition, delegations in <code>User</code> model) but they give me sufficient level of confidence to assume that the application works correctly and they helped with some design choices, which is a great advantage of unit tests. When TDDing, keep in mind what Kent Beck says about his way of writing tests:
  <blockquote>I get paid for code that works, not for tests so my philosophy is to test as little as possible to reach a given level of confidence (I suspect this level of confidence is high compared to industry standards but that could just be hubris). If I don&rsquo;t typically make a kind of mistake (like setting the wrong variables in a constructor), I don&rsquo;t test for it.</blockquote>
</p></p>

<p><p class="meta small-p">Changelog: 04-03-2013 &ndash; Add missing code for <code>UserRegistrationAdminNotification</code> implementation.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Driven Rails  Part 1]]></title>
    <link href="https://karolgalanciak.com/blog/2014/01/04/test-driven-rails-part-1/"/>
    <updated>2014-01-04T16:19:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2014/01/04/test-driven-rails-part-1</id>
    <content type="html"><![CDATA[<p>Testing is still one of the hottest topics when it comes to developing maintainable and business-critical applications. Ruby on Rails community embraces the importance of writings tests, yet there are so little resources about the Test-Driven Development or Behavior-Driven Development in Rails applications from a wider perspective. How should we test our application? Which tests are valuable and which dont provide any value? What scenarios should be included in acceptance tests?</p>




<!--more-->


<p></p>

<h2>Value of tests</h2>




<p>If you arent yet into testing, you might have some doubts: what can you get from tests and how they can help you? In a few words, by writing tests:</p>




<ol>
  <li>You make sure that a feature is implemented properly.</li>
  <li>You can refactor your code without fear of breaking entire application.</li>
  <li>You have an instant feedback about your code design (unit tests).</li>
</ol>




<p>And how is that different from manually checking if everything works? Well, manual checking is already some kind of testing  you can click hundreds of buttons in a browser, fill tens of forms and test different scenarios, but doing it after each change in a code is an awful waste of time. Oh, and remember to test your entire app after Rails update or any gem update So it is obvious that automated testing will save you a lot of time and will help you track any bugs. </p>




<p>How about code design? The rule of thumb is that a clean code is easy to test. If your tests look awful and are difficult to follow, it probably means that the implementation is even worse. This mainly refers to the unit testing, which I will cover later.</p>




<h2>TDD vs. BDD</h2>




<p>You have probably seen many times how some developers advocate Behavior-Driven Development. How is that different from Test-Driven approach? The thing is that these two terms mean basically the same thing: writing acceptance tests for a feature and unit-testing your code, so that it can guide your design. It is not about acceptance vs. unit tests - BDD is not just about writing acceptance tests and TDD does not concentrate on unit testing. Testing done right includes both of them: if you write only acceptance tests, you just make sure that a feature works, but the code can be awful and difficult to maintain and the unit-tests alone cannot give you sufficient level of confidence that the entire app works, not only separate parts. </p>




<h2>To mock or not to mock</h2>




<p>
Before discussing arguments for and against mocks and stubs, I should explain differences between them - stubs are fake objects with predetermined responses and mocks are about expectations and collaboration. Take a look at the following example:</p>


<p>``` ruby</p>

<p>describe SomeUsecase do</p>

<h1>some code with initializing object under the test and setting collaborators</h1>

<p>  context user is an admin  do</p>

<pre><code>it sends a notification do
  allow(user).to receive(:admin?).and_return(true)  
  expect(notifier).to receive(:deliver)
  usecase.call
end
</code></pre>

<p>  end</p>

<p>  context user is not an admin do</p>

<pre><code>it doesnt send a notification do
  allow(user).to receive(:admin?).and_return(false) 
  expect(notifier).not_to receive(:deliver)
  usecase.call
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>In this usecase, a <code>user</code> has predetermined response when the <code>:admin?</code> message is sent  this is stub. Depending on the response, the  <code>:deliver</code> message is sent to the<code>notifier</code> or not  which is a mock. By using mocks, you discover how the objects interact with its collaborators and ensure that proper expectations are met.</p>




<p>There are many arguments for using mocks and stubs, but also there are some valid issues against them. The most significant is that it can make your tests brittle, especially when you stub non-existent method (or mock). Because of that, many developers prefer to stay with integration tests using real objects. Fortunately, there are some solutions to prevent this problem. Since RSpec 3.0 (at time of writing this post the current version is beta1) the functionality of rspec-fire is merged into the core of the framework, which provides safe stubs that will inform you about stubbing non-existent method. You can also check <a href="https://www.relishapp.com/bogus/bogus/v/0-1-4/docs/getting-started" target="_blank">bogus</a> gem that provides similar functionality.</p>




<p>What are the benefits of using mock objects? You can test in isolation, which will make your test-suite running much faster  you dont have to talk to the database, send notifications, connect to an external API etc.  slow test suite can be really discouraging. And the other important aspect of using mock objects is the design: if you use real objects, you wont get much feedback about your code design. Mock objects force you to write a clean and OOP code  if you dont, tests will simply get really ugly, which is the symptom of bad design choices.</p>




<p>While mocking there is an important rule to follow: only mock collaborators (peers), not the internals (like private methods  its an implementation detail) of the object   if you think about doing so, then you should redesign your class. One more rule, which I dont dogmatically follow, but is also important: only mock types you own. When you dont own the API, you cant be absolutely certain that the code will work in the future. It looks reasonable, but why would I treat more it like a suggestion? Consider ActiveRecord API  why wouldnt you mock it? It is pretty stable and I can trust it wont change, at least in the nearest future. If possible, you should implement own domain methods and treat ActiveRecord as an implementation detail  instead of calling <code>user.update(active: true)</code> in service object, you should use <code>activate</code> method: <code>user.activate</code> and define this method in the model layer, however, <code>update</code> might be sometimes the thing you need and then you can mock it.</p>


<p></p>

<h2>TDD rules and cycle</h2>




<p>When you TDD, it is important to follow its cycle, which is: Red, Green, Refactor. What does it mean exactly? Before you write the production code, you should write failing test first (red), you have to see the test fails  if it never fails, it has basically no value. Then you should write minimal implementation for satisfying this test (green), and then you can refactor your code if required  you can move some code to private methods or extract it to separate classes and because you have tests, you make sure that you havent broken anything. </p>




<p>Writing tests first for every line of the code is not always required. There are some cases, where a test wont give you much value  remember: test itself is a code, which needs to be maintained - make sure you need it.</p>




<h2>What not to test?</h2>




<p>Before answering the question: how to write valuable tests, there are some issues that need to be discussed: what not to test? </p>




<h3>Do not test ActiveRecord and friends</h3>




<p>This may seem strange at first, but Ive seen many tests having no real value and seemed as if ActiveRecord or ActiveModel cannot be trusted. Consider the following <code>User</code> model example:</p>


<p>``` ruby</p>

<p>describe User do</p>

<p>  subject {  User.new }</p>

<p>  specify user without name is not valid do</p>

<pre><code>expect(subject).not_to be_valid
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>What kind of value does this test provide? The only scenario when this test might fail is when the model lacks of presence validation for name attribute. So either you are writing test for <code>ActiveModel::Validations</code> (believe me, it is already tested) or for the presence of the line of code with:</p>


<p><code>ruby
  validates :name, presence: true
</code></p>

<p>This test is even pretty useless as a spec for the model, because reading model itself is much more descriptive.</p>




<p>What else falls into this category? Testing associations and relations  it is all about using them properly, there is no other way the test may fail. Do not test simple scopes as well, consider the following:</p>


<p>``` ruby</p>

<p>class User &lt; ActiveRecord::Base</p>

<p>  scope :active, &ndash;> { where(active: true) }</p>

<p>end</p>

<p>```</p>

<p>Does it really make sense to write test for such code? What kind of value does it provide and how do you expect it to fail? ActiveRecord API is stable and can be trusted that it wont change and <code>where</code> method will behave exactly the same.</p>




<h3>Do not test generic CRUD controllers</h3>




<p>What do I mean by generic CRUD controllers? Consider the following:</p>


<p>``` ruby</p>

<p>class ArticlesController &lt; ApplicationController</p>

<p>  def index</p>

<pre><code>@articles = Article.all
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>@article = Article.find(params[:id])
</code></pre>

<p>  end</p>

<p>  def new</p>

<pre><code>@article = Article.new
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>@article = Article.new(article_params)

if @article.save
  flash[:notice] = Article has been created.
  redirect_to articles_path
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  def edit</p>

<pre><code>@article = Article.find(params[:id])
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>@article = Article.find(params[:id])

if @article.update(article_params)
  flash[:notice] = Article has been updated.
  redirect_to articles_path
else
  render :edit
end
</code></pre>

<p>  end</p>

<p>  def destroy</p>

<pre><code>Article.find(params[:id]).destroy
flash[:notice] = Article has been deleted.
redirect_to articles_path
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def article_params
  params.require(:article).permit(:title, :content)
end
</code></pre>

<p>end</p>

<p>```</p>

<p>Its a typical easy CRUD Rails controller, where you dont even need to read the code to know, what it does. It is so generic that you could DRY it up with some metaprogramming and naming conventions, or simply use <a href="https://github.com/josevalim/inherited_resources" target="_blank">Inherited Resources</a> gem. In many Rails testing tutorials you can find a section with controllers testing, which look basically like that:</p>


<p>``` ruby</p>

<p>describe &ldquo;#create&rdquo; do</p>

<p>  context &ldquo;valid attributes&rdquo; do</p>

<pre><code>it "saves article" do
  expect do
    post :create, params: { title: "Article title", content: "Some content" }
  end.to change(Article, :count).by(1)
end

it "redirects to articles page" do
  post :create, params: { title: "Article title", content: "Some content" }
  expect(response).to redirect_to articles_path
end
</code></pre>

<p>  end</p>

<p>  context &ldquo;invalid attributes&rdquo; do</p>

<pre><code>it "does not save article" do
  expect do
    post :create, params: { title: "Article title" }
  end.not_to change(Article, :count)
end

it "renders new template" do
  post :create, params: { title: "Article title" }
  expect(response).to render_template "new"
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And add tests for the remaining six actions. How much value do these tests provide? It does everything what is expected from simple controller and the only reason it may fail is making a typo. The same thing applies to tests with mocks and stubs in controllers testing. Basically I see no point at all in writing tests for CRUD controllers. To make things easier and make sure it works, you can provide some generic solution like <a href="https://github.com/josevalim/inherited_resources" target="_blank">Inherited Resources</a> gem or use Rails scaffolding.</p>




<p>The important thing is: you need to test controllers, but dont do it for typical CRUD. Otherwise, you should thoroughly test your code, especially before_filters with some authorization and domain related logic.</p>




<h3>Do not test Helpers</h3>




<p>Helpers should be used in most cases for providing some generic HTML markup, for example:</p>


<p>``` ruby</p>

<p>def main_menu_link_to(title, path, options={})
  content_tag(:li, class: main-menu) do</p>

<pre><code>link_to(title, path, options)
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>It probably doesnt require test coverage. If you think about putting some model presentation logic in helpers, then you are doing it wrong and should look at presenters (e.g. <a href="https://github.com/drapergem/draper" target="_blank">Draper</a> gem).</p>




<h3>Do not test trivial views</h3>




<p>And what is trivial thing in views? Writing Capybara tests for titles can be counted here, also testing simple CRUD and flash messages (unless they are somehow critical for the application). Dont write simple tests for editing an article and verifying that the title has been changed after update or the article has been deleted after clicking Delete button. Leave Capybara tests for some more complicated scenarios and critical parts of your app.</p>




<h3>Do not use Cucumber</h3>




<p>Cucumber seems to have significant popularity among developers. One argument for using Cucumber is that it helps non-technical people read and write tests and, e.g. sit with the client and let him/her write some scenarios. Yeah, right. Honestly, how many clients have you met who wrote any tests? Was it worth adding additional layer of complexity and maintaining it?</p>




<p>Cucumber makes you duplicating your intentions  firstly, you write some scenarios and then implement in RSpec. Why not to implement them in RSpec alone, when Capybara DSL is extremely expressive? <del>Cucumber is the most overrated tool and in most cases it is simple waste of time with no benefits at all. If you use Cucumber in everyday testing, then take some time and think if you really need it and how valuable are these tests for you. If you havent tried Cucumber yet, dont bother.</del>  If you use Cucumber in everyday testing, then take some time and think if you really need it and how valuable these tests are for you. If you havent tried Cucumber yet, make sure it solves your actual problems.</p>




<h2>What needs to be tested</h2>




<h3>Models</h3>




<p>The important thing is that you shouldnt put your business logic in models, so sometimes there wont be that many things that requires testing in this layer. If you write custom validations, e.g. for URLs, zip codes etc., extract it to separate validator and test it on some generic model.</p>




<p>Write tests for not trivial scopes, especially when you write raw complex SQL queries  some of them might be quite difficult to follow is much more convenient to verify query through tests, not e.g. in Rails Console or dbconsole.</p>




<p>Scopes with some database specific queries should be tested  e.g. hstore or arrays in PostgreSQL. Some operators like <code>hstore ?& text[]</code> (which means: does hstore contain all specified keys?) might look mystical at first glance. It is quite beneficial to test drive this kind of functionality. Sometimes it is not that obvious, how to use this kind of scopes and what result can be expected, even with nice, descriptive name and tests can help as a documentation.</p>




<p>Write tests for some domain methods  - when you have for instance User model, with attribute :active which can be either false or true, you can provide the following method:</p>


<p>``` ruby</p>

<p>def activate
  update(active: true)
end</p>

<p>```</p>

<p>and test for it:</p>


<p>``` ruby</p>

<p>let(:user) { FactoryGirl.create(:inactive_user) }</p>

<p>describe #activate do</p>

<p>  it makes user active do</p>

<pre><code>expect(user.activate).to change { user.active }.from(false).to(true)  
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<h3>Controllers</h3>




<p>Basically everything beyond the CRUD requires testing, especially some authorization-related logic. Consider the <code>ArticlesController</code> and the feature, when we dont want to render inactive article for non-admin user:</p>


<p>``` ruby</p>

<p>class ArticlesController &lt; ApplicationController</p>

<p>  before_filter :allow_only_admin_for_inactive, only: [:show]</p>

<p>  # some code</p>

<p>  private</p>

<p>  def allow_only_admin_for_inactive</p>

<pre><code>article = Article.find(params[:id])
if !article.active? and !(current_user and current_user.admin?)
  flash[:error] = Article is not active
  redirect_to articles_path
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Test for this before_filter should look like the following:</p>


<p>``` ruby</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe ArticlesController do</p>

<p>  describe &ldquo;inactive article&rdquo; do</p>

<pre><code>let(:article) { double(:article, active?: false, id: 1) }

before(:each) do
  allow(Article).to receive(:find) { article } 
end

describe "user is logged in" do

  context "user is an admin" do

    let(:user) { double(:user, admin?: true) }

    it "renders article" do
      allow(controller).to receive(:current_user).and_return(admin)
      get :show, id: article.id
      expect(response).to render_template :show
    end
  end

  context "user is not an admin" do

    let(:user) { double(User, admin?: false) }

    it "redirects to articles path" do
      allow(controller).to receive(:current_user).and_return(user)
      get :show, id: article.id
      expect(response).to redirect_to articles_path
    end
  end

  context "user is not logged in" do        

    before(:each) do
      allow(controller).to receive(:current_user).and_return(nil)
    end

    it "redirects to articles path" do
      get :show, id: article.id
      expect(flash[:error]).not_to be nil
      expect(response).to redirect_to root_path
    end
  end
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>And that should be sufficient. If you have some complex authorization logic, then you should move it to separate class and write tests for this class, not test in controllers.</p>




<p>How about acceptance tests for his feature? Well, it is quite simple and controller test gives me sufficient level of confidence that it works, so I believe that it is not needed.</p>




<p>The good practice is to always use mock objects and stub everything in controllers, which is writing unit tests for controllers, not integration tests.</p>




<h3>Presenters</h3>




<p>Most of the time tests are not that essential for the presenters  they contain presentation logic, often related to nice formatting and, unless it is somehow business-critical, you dont have to test it. If you have some complex logic, consider moving it to a separate class and write test for the new object (maybe <code>DateFormatter</code>?). Personally I write tests for methods, where few scenarios are possible (i.e. they contain conditionals)  it serves as a nice documentation and gives instant information how it works.</p>




<p>I wouldnt write test for the following usecase:</p>


<p>``` ruby</p>

<p>class InvestmentDecorator &lt; ApplicationDecorator</p>

<p>  # assuming that draper gem is used here
  # every investment has statistic_profile</p>

<p>  def display_areas_range</p>

<pre><code>Apartments areas from #{statistic_profile.minimum_apartments_area} to #{statistic_profile.maximum_apartments_area} 
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>However, this may require testing:</p>


<p>``` ruby</p>

<p>class UserDecorator &lt; ApplicationDecorator</p>

<p>  def display</p>

<pre><code>if model.firstname.present? and model.surname.present?
  #{model.firstname} #{model.surname}
else
  model.email
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Business logic - usecases, services, policy objects, value objects etc.</p>




<p>Nothing to be discussed here  business logic requires 100% test coverage, as simple as that. It is essential for your application, so you cannot leave anything untested.</p>




<h2>Views and acceptance testing</h2>




<p>Acceptance tests might be difficult to maintain and they are slow, you should write them carefully and make sure that you are testing right stuff. Focus on critical features of your app. When you work on an e-commerce solution, buying process is essential (with different scenarios for registered user and guest user), rendering current shopping cart, sending notifications after completing order etc. When you have georegion specific content, you should write acceptance tests for it. You have some important UI implemented using Javascript? Dont forget to write tests for it with <code>js: true</code> option in Capybara. Focus on critical parts and complex scenarios, not simple single features.</p>




<h2>Integration tests</h2>




<p>Acceptance tests shouldnt cover every possible scenarios, it may get too slow and might not give sufficient feedback why something has failed. Leave it to integrations tests with  especially when you have some XML/JSON importing or you interact with 3rs party APIs. Dont stub or mock anything there, use real objects.</p>




<hr />




<p>And thats would be end for part 1. Part 2 will be more practice oriented with implementing specified feature using techniques described here.</p>



]]></content>
  </entry>
  
</feed>
