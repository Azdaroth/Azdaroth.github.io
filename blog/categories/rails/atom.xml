<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2018-06-12T17:32:38+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Case for before_validation callback: complex state normalization]]></title>
    <link href="https://karolgalanciak.com/blog/2018/05/27/the-case-for-before-validation-callback-complex-state-normalization/"/>
    <updated>2018-05-27T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/05/27/the-case-for-before-validation-callback-complex-state-normalization</id>
    <content type="html"><![CDATA[<p>Few months ago I wrote a <a href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/">blog post</a> about <strong>ActiveRecord</strong> <code>before_validation</code> callback and how it is used for  <strong>wrong reasons</strong> and concluded that in most cases this is not something we should be using routinely. However, I missed one <strong>appropriate use case</strong> for it which might be quite common in Rails apps, so this might be an excellent opportunity to get back to  <strong>before_validation callback</strong> and show its other side.</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Imagine that we have a <code>Payment</code> model where we need to store <code>amount</code> and <code>currency</code>. However, for statistical purposes, we also want to store normalized amount in USD currency with exchange rate applied at the time of payment&rsquo;s creation. As this is a significant part of our domain, we want to add validation for <code>amount_in_usd</code> attribute. Our Payment model looks like this at the moment:</p>

<p><code>rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true
end
</code></p>

<p>The question is: where do we get <code>amount_in_usd</code> from and how can we assign it?</p>

<h2>The Solution</h2>

<p>One way of solving that problem would be a direct assignment when populating all the attributes. In that case, it would look a bit like this:</p>

<p><code>rb
Payment.new(currency: currency, amount: amount, amount_in_usd: CurrencyExchanger.exchange(amount, from: currency, to: "USD"))
</code></p>

<p>The problem with that solution is that this logic would need to be repeated in every place where payment gets initialized. We could implement a factory class that would be reused in all scenarios to keep it DRY, but that&rsquo;s some extra overhead that is not popular in a Rails world. Also, this sounds like a responsibility of the Payment model itself as it is about managing its internal state.</p>

<p>Here, we can&rsquo;t solve this by overriding writers as I suggested <a href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/">before</a> as <code>amount_in_usd</code> depends on two attributes: <code>currency</code> and <code>amount</code>, and we don&rsquo;t know in which sequence the attributes will be assigned.</p>

<p>And this is exactly the case where <code>before_validation</code> is useful: for complex state normalization where multiple attributes are involved. With that callback, a solution looks quite elegant and just simpler:</p>

<p>``` rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true</p>

<p>  before_validation :assign_amount_in_usd</p>

<p>  private</p>

<p>  def assign_amount_in_usd</p>

<pre><code>if currency &amp;&amp; amount
  self.amount_in_usd = CurrencyExchanger.exchange(amount, from: currency, to: "USD")
end
</code></pre>

<p>  end
end
```</p>

<h2>Alternative Solution</h2>

<p>In the first paragraph, I mentioned that this solution could work especially well in Rails apps. What I meant by that is the fact that usually, the &ldquo;primitive&rdquo; attributes coming from HTTP params are mass-assigned to the model. Of course in Ruby, everything is an object, but to keep things simpler, let&rsquo;s treat numeric types and strings as primitives.</p>

<p>What would be a non-primitive value though? In our case, we have something that is widely used as a typical example of a value object: <strong>Money</strong> object that is composed of <code>amount</code> and <code>currency</code>.  If the attributes before the assignment were mapped to some more domain-oriented objects, we would have an even simpler solution for our problem:</p>

<p><code>rb
money = Money.new(amount, currency)
Payment.new(money: money)
</code></p>

<p>and the model would look like this:</p>

<p>``` rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true</p>

<p>  def money=(money_object)</p>

<pre><code>self.amount = money_object.amount
self.currency = money_object.currency
self.amount_in_usd = CurrencyExchanger.exchange_money(money_object, to: "USD")
</code></pre>

<p>  end
end
```</p>

<p>It might look like extra overhead that is not necessary. However, value objects tend to simplify and DRY a lot of things in the code, so for more complex apps, using value objects will be worth that extra overhead.</p>

<h2>Wrapping Up</h2>

<p>There are some cases where <code>before_validation</code> callback might be useful. However, in more complex apps, using value object might be an alternative worth looking into.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Quick Tips: Temporarily Disabling Touching with ActiveRecord.no_touching]]></title>
    <link href="https://karolgalanciak.com/blog/2018/02/25/rails-quick-tips-temporarily-disabling-touching-with-activerecord-dot-no-touching/"/>
    <updated>2018-02-25T20:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2018/02/25/rails-quick-tips-temporarily-disabling-touching-with-activerecord-dot-no-touching</id>
    <content type="html"><![CDATA[<p><strong>Touching</strong> <strong>ActiveRecord models</strong> is quite a common thing in most of the <strong>Rails applications</strong>, especially useful for cache invalidation. By default, it updates <code>updated_at</code> timestamp with the current time, Here&rsquo;s a typical example of using <a href="https://apidock.com/rails/ActiveRecord/Persistence/touch">touch</a> in a model:</p>

<p>``` ruby</p>

<h1>app/models/photo.rb</h1>

<p>class Photo &lt; ApplicationRecord
  belongs_to :user, touch: true
end
```</p>

<p>Whenever a new photo is created, or the existing one is updated/destroyed, the <code>updated_at</code> attribute of the associated user will be updated with the current time. In the majority of the cases, this is the desired behavior (it&rsquo;s one of those rare ActiveRecord callbacks that is not that bad ;)). However, it might happen that you may not want <code>touch</code> to be executed for some reason. Is there any built-in solution that could solve that problem?</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Temporarily disabling <code>touch</code>ing can useful either for performance reasons (when updating a large number of records) or simply to prevent <code>after_touch</code> or <code>after_commit</code> from being executed multiple times. The latter might indicate that there is a deeper problem in the design as putting any important logic causing side-effects beyond the record&rsquo;s internal state in those <strong>ActiveRecord callbacks</strong> can easily go south (especially if you trigger email notifications), but the reality is that a lot of Rails applications use those callbacks in such cases.</p>

<h2>The Solution</h2>

<p>Fortunately, a heavy refactoring or a rewrite is not necessary. Instead, we can take advantage of <a href="http://api.rubyonrails.org/classes/ActiveRecord/NoTouching/ClassMethods.html">ActiveRecord.no_touching</a> which temporarily disables touching inside the block.</p>

<p>Imagine that you need to update all photos belonging to some user and <code>touch</code> this user only after all photos are updated. Here&rsquo;s how it could be handled:</p>

<p>``` ruby
user = User.find(user_id)</p>

<p>ActiveRecord::Base.transaction do
  User.no_touching do</p>

<pre><code>user.photos.find_each do |photo|
  # user won't be `touch`ed
  photo.update!(some_attributes)
end
</code></pre>

<p>  end</p>

<p>  user.touch
end
```</p>

<p>If for some reason disabling touching is necessary for all models, you could just call it on <code>ActiveRecord::Base</code>:</p>

<p>``` ruby
user = User.find(user_id)</p>

<p>ActiveRecord::Base.transaction do
  ActiveRecord::Base.no_touching do</p>

<pre><code>user.photos.find_each do |photo|
  # no model will be `touch`ed
  photo.update!(some_attributes)
end
</code></pre>

<p>  end</p>

<p>  user.touch
end
```</p>

<p>And that&rsquo;s it!</p>

<h2>Summary</h2>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/NoTouching/ClassMethods.html"><code>ActiveRecord.no_touching</code></a> is certainly a quick solution to a potentially tricky issue. However, it is also a dirty hack that indicates a potential problem with the design of the application that should be addressed sooner than later.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Traps on Rails - Overriding boolean methods in models]]></title>
    <link href="https://karolgalanciak.com/blog/2017/11/26/traps-on-rails-overriding-boolean-methods-in-models/"/>
    <updated>2017-11-26T16:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2017/11/26/traps-on-rails-overriding-boolean-methods-in-models</id>
    <content type="html"><![CDATA[<p>One very <strong>useful</strong> feature of <strong>ActiveRecord</strong> is automatically defining attribute readers and writers for all the columns for given tables. For the ones with <strong>boolean</strong> type, however, there is one more addition &ndash; defining an <strong>alias</strong> of the method with a question mark. Sometimes it might be useful to override this method and add some extra requirements for a given condition. However, this might not be such a good idea.</p>

<!--more-->


<h2>Anatomy of the problem</h2>

<p>Imagine that you are developing some application, where users can be activated and deactivated from an admin panel. However, the application is not free, and every user that wants to access the application needs to buy a subscription. In that case, to check if the user is, in fact, active, you could override <code>User#active?</code> method and add some extra requirements regarding the subscription:</p>

<p>``` rb</p>

<h1>app/models/users.rb</h1>

<p>class User &lt; ApplicationRecord
  def active?</p>

<pre><code>super &amp;&amp; valid_subscription?
</code></pre>

<p>  end</p>

<p>  def valid_subscription?</p>

<pre><code># somehow check if the subscription is valid
</code></pre>

<p>  end
end
```</p>

<p>We are taking advantage of the fact that ActiveRecord defines the aliases for boolean columns which are the original column names' ending with a question mark, so for <code>active</code> boolean column we can expect that <code>active?</code> method will be defined, and it will work the same as <code>active</code> method.</p>

<p>Ok, cool, we have our feature working and to check if a user is fully active, we call <code>User#active?</code> here and there. Our next requirement is exposing users in the API. Nothing too hard, we can add <a href="https://github.com/fotinakis/jsonapi-serializers"><code>jsonapi-serializers</code></a> gem and implement fully JSONAPI-compliant serializers. It turns out that we need to expose info if a user is active and not. Here is how our serializer could look like:</p>

<p>``` rb</p>

<h1>app/serializers/user.rb</h1>

<p>class UserSerializer
  include JSONAPI::Serializer</p>

<p>  attribute :active
  # other attributes
end
```</p>

<p>It sounds like we are done here. But the truth is there is a nasty bug here! The serializer returns the value returned by <code>User#active</code>, not by <code>User#active?</code>!</p>

<h2>What exactly went wrong here?</h2>

<p>The primary thing that went wrongs here was being lazy about the naming and not introducing proper domain concepts. Somehow ActiveRecord made it even easier &ndash; there was already a method called <code>active?</code> defined based on the <code>active</code> column name, so the only thing that was necessary in that case to make our first feature work was overriding it and adding some extra condition because the idea of being &ldquo;active&rdquo; is kind of similar. But overriding boolean methods is never a good idea &ndash; it always implies that some concept is missing or is made implicit in the code.</p>

<h2>A solution to the problem</h2>

<p>A solution would be simply making this domain concept explicit. <code>User#active?</code> method doesn&rsquo;t check if the user is active is not, it rather checks if a user can access the application, so the better name for that method would be <code>User#can_access_application?</code></p>

<p>It is quite possible that we might later need to add some extra features that are related to this feature, like checking if the user is active but cannot access the app or just simply checking the <code>active</code> flag itself. Our final model could look like this in the end:</p>

<p>``` rb</p>

<h1>app/models/users.rb</h1>

<p>class User &lt; ApplicationRecord
  def can_access_application?</p>

<pre><code>active? &amp;&amp; valid_subscription?
</code></pre>

<p>  end</p>

<p>  def cannot_access_application?</p>

<pre><code>!can_access_application?
</code></pre>

<p>  end</p>

<p>  # other methods
end
```</p>

<p>We should also update the serializer:</p>

<p>``` rb</p>

<h1>app/serializers/user.rb</h1>

<p>class UserSerializer
  include JSONAPI::Serializer</p>

<p>  attribute :active do</p>

<pre><code>object.active
</code></pre>

<p>  end</p>

<p>  attribute :can_access_application do</p>

<pre><code>object.can_access_application?
</code></pre>

<p>  end</p>

<p>  attribute :cannot_access_application do</p>

<pre><code>object.cannot_access_application?
</code></pre>

<p>  end
end
```</p>

<p>One could argue that this fix was not necessary and it was a developer&rsquo;s fault, and he or she should have checked the model if this method has not been overridden and adjust the serializer. That is somehow true, but if such code is deployed to production, it probably means that the reviewer of the code was not aware that there is a potential issue in the code and such things are really hard to spot &ndash; ActiveRecord adds those aliases for every boolean column so it might sound like a fair assumption that <code>User#active</code> and <code>User#active?</code> will return the same result.</p>

<p>However, the truth is that not only did we minimize the risk of having the name collisions by those changes but we gained some extra flexibility, and it was quite straight-forward to differentiate between <code>User#active?</code>and <code>User#can_access_application?</code>. In a previous implementation, it was simply not possible with the question-mark methods.</p>

<h2>Wrapping up</h2>

<p>Naming is one of <a href="https://martinfowler.com/bliki/TwoHardThings.html" target="_blank">two hard problems in computer science</a> and it&rsquo;s a good idea to always make all the domain concepts properly named and explicit, even if it means adding more code &ndash; just because something is not explicit, doesn&rsquo;t mean it doesn&rsquo;t exist. When it comes to <strong>ActiveRecord</strong> models, an extra caution is more than recommended &ndash; such models mix both persistence and domain concepts and it&rsquo;s quite easy to hurt yourself in such case. Not overriding boolean methods generated by ActiveRecord and properly naming things sounds like a good rule of thumb to follow.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Case Against Exotic Usage of :before_validate Callbacks]]></title>
    <link href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/"/>
    <updated>2017-10-29T22:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks</id>
    <content type="html"><![CDATA[<p>It&rsquo;s nothing new that <strong>ActiveRecord callbacks</strong> are abused in many projects and used for the wrong reasons for many use cases where they can be <strong>easily avoided</strong> in favor of a much better alternative, like service objects. There is one callback though that is special and quite often used for pretty <strong>exotic reasons</strong> that have nothing to do with the process when it gets executed &ndash; it&rsquo;s the <code>before_validate</code> callback.</p>

<!--more-->


<h2>Data Formatting</h2>

<p>Data formatting is something pretty common in the majority of the applications, especially stripping strings. Imagine that you need to strip some <code>URL</code> so that potential spaces won&rsquo;t cause any issues. How would you approach that?</p>

<p>One way would be to use <code>before_validate</code> callback, especially if you have some format validations:</p>

<p>``` ruby app/models/my_model.rb
class MyModel
  before_validate :strip_url</p>

<p>  private</p>

<p>  def strip_url</p>

<pre><code>self.url = url.to_s.strip
</code></pre>

<p>  end
end
```</p>

<p>It gets the job done. However, how would you test it? You would need to call <code>valid?</code> method on the model to check that&hellip; <code>URL</code> is stripped? Sounds quite funny and is even better when you look at the potential spec:</p>

<p>``` ruby spec/models/my_model_spec.rb
require &ldquo;rails_helper&rdquo;</p>

<p>RSpec.describe MyModel, type: :model do
  it &ldquo;strips URL before validation&rdquo; do</p>

<pre><code>model = MyModel.new(url: "  http://rubyonrails.org")

model.valid?

expect(model.url).to eq "http://rubyonrails.org"
</code></pre>

<p>  end
end
```</p>

<p>It&rsquo;s quite unlikely that this would be the result of <strong>TDD</strong> though ;). What&rsquo;s the alternative then?</p>

<p>How about just using attribute writer for that? So something like this:</p>

<p>``` ruby app/models/my_model.rb
class MyModel
  def url=(val)</p>

<pre><code>super(val.to_s.strip)
</code></pre>

<p>  end
end
```</p>

<p>And here is a potential spec for this feature:</p>

<p>``` ruby spec/models/my_model_spec.rb
require &ldquo;rails_helper&rdquo;</p>

<p>RSpec.describe MyModel, type: :model do
  it &ldquo;strips URL&rdquo; do</p>

<pre><code>model = MyModel.new(url: "  http://rubyonrails.org")

expect(model.url).to eq "http://rubyonrails.org"
</code></pre>

<p>  end
end
```</p>

<p>Both the implementation and spec are much simpler and just more natural &ndash; data formatting has nothing to do with the validation, there is no need to use a callback related to validation to handle such use case.</p>

<h2>Populating attributes and relationships</h2>

<p>Another popular scenario is assigning attributes and relationships. Imagine you are creating a comment with a <code>content</code>, an author who will be <code>current_user</code> and also want to do some denormalization for performance reasons and directly assign <code>group</code> to this comment to which <code>current_user</code> belongs to. Here is how it is sometimes handled with <code>before_validate</code> callback:</p>

<p><code>ruby
Comment.create!(
  content: content,
  author: current_user,
)
</code></p>

<p>``` ruby app/models/my_model.rb
class MyModel
  before_validate :assign_group</p>

<p>  private</p>

<p>  def assign_group</p>

<pre><code>self.group = author.group if author
</code></pre>

<p>  end
end
```</p>

<p>It&rsquo;s quite similar to the previous use case with data formatting &ndash; to write a test for this feature, we would need again to call <code>valid?</code> which doesn&rsquo;t make much sense, validation has nothing to do with populating attributes or relationships. There is much simpler and much more explicit way to handle it:</p>

<p><code>ruby
Comment.create!(
  content: content,
  author: current_user,
  group: current_user.group,
)
</code></p>

<p>There is no magic here &ndash; just a simple assignment, which is easy to test and understand.</p>

<h2>Wrapping up</h2>

<p>Maybe there are some scenarios where <code>before_validate</code> callback is the best possible choice (I&rsquo;m yet to find them though), but I&rsquo;m pretty sure data formatting or populating attributes/associations are not valid cases to use it for.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Do. Or do not. There is no try - Object#try considered harmful]]></title>
    <link href="https://karolgalanciak.com/blog/2017/09/24/do-or-do-not-there-is-no-try-object-number-try-considered-harmful/"/>
    <updated>2017-09-24T22:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2017/09/24/do-or-do-not-there-is-no-try-object-number-try-considered-harmful</id>
    <content type="html"><![CDATA[<p><a href="https://apidock.com/rails/v4.2.7/Object/try" target="_blank"><code>Object#try</code></a> is quite a commonly used method in <strong>Rails applications</strong> to cover cases where there is a possibility of dealing with a <code>nil</code> value or to provide <strong>flexible interface</strong> for handling cases where some kind of object doesn&rsquo;t necessarily implement given method. Thanks to <code>try</code>, we may avoid getting <code>NoMethodError</code>. So it seems like it&rsquo;s perfect, right? No <code>NoMethodError</code> exception, no problem?</p>

<p>Well, not really. There are some <strong>severe problems</strong> with using <code>Object#try</code>, and usually, it&rsquo;s quite easy to implement a solution that would be much better.</p>

<!--more-->


<h2>Object#try &ndash; how does it work?</h2>

<p>The idea behind <code>Object#try</code> is simple: instead of raising <code>NoMethodError</code> exception when calling some method on <code>nil</code> or calling a method on non-<code>nil</code> object that is not implemented by this object, it just returns <code>nil</code>.</p>

<p>Imagine that you want to grab the email of the first user. To make sure it won&rsquo;t blow up when there are no users, you could write it the following way:</p>

<p><code>
user.first.try(:email)
</code></p>

<p>What if you implemented some generic service where you can pass many types of objects and, e.g., after saving the object it attempts to send a notification if the object happens to implement a proper method for that? With <code>Object#try</code> it could be done like this:</p>

<p>``` rb
class MyService
  def call(object)</p>

<pre><code>object.save!
object.try(:send_success_notification, "saved from MyService")
</code></pre>

<p>  end
end
```</p>

<p>As you can see, it is also possible to provide <code>arguments</code> of the method.</p>

<p>What if you need to do some chaining of the methods where you can get <code>nil</code> at each intermediate step? No problem, you can use <code>Object#try</code>:</p>

<p><code>rb
payment.client.try(:addresses).try(:first).try(:country).try(:name)
</code></p>

<h2>What is the problem then?</h2>

<p>Apparently, <code>Object#try</code> is capable of handling multiple cases, so what is the problem with using it?</p>

<p>Well, there are many. The biggest issue with <code>Object#try</code> is that in many cases it <code>solves</code> problems that should never happen in the first place and that problem is <code>nil</code>. The another one is that the intention of using it is not clear. What does the following code try to say?</p>

<p><code>rb
payment.client.try(:address)
</code></p>

<p>Is it a legit case that some payment might not have a client and indeed it could be <code>nil</code>? Or is added &ldquo;just in case&rdquo; if <code>client</code> happens to be <code>nil</code> to not blow up with <code>NoMethodError</code> exception? Or even worse, does <code>client</code> happen to be a polymorphic relationship where some models implement <code>addresses</code> method and the others don&rsquo;t? Or maybe there is a problem with data integrity, and for a few payments the client was deleted for some reason, and it&rsquo;s no longer there?</p>

<p>Just by looking at this code it is impossible to tell what&rsquo;s the intention of <code>Object#try</code>, there are just too many possibilities.</p>

<p>Fortunately, there are plenty of alternative solutions that you can apply to get rid of <code>Object#try</code> and make your code clear and expressive &ndash; thanks to that, it will be much more maintainable, more readable and less prone to bugs as the intention will no longer be ambiguous.</p>

<h2>Alternative solutions</h2>

<p>Here are few &ldquo;patterns&rdquo; you could apply depending on the context where <code>Object#try</code> is used.</p>

<h3>Respecting Law of Demeter</h3>

<p><a href="https://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank">Law of Demeter</a> is a handy rule (I wouldn&rsquo;t go that far to call it a &ldquo;law&rdquo; though) which helps avoid structural coupling. What it states is that hypothetical object A should be only interested in its own immediate surrounding and should not be aware of the internal structure of its collaborators or associations. In many cases, it means having only one &ldquo;dot&rdquo; in method calls. However, <strong>Law of Demeter</strong> is not really about the amount of &ldquo;dots&rdquo; (method calls), it&rsquo;s only about the coupling between objects, so chained operations and transformations are perfectly fine, e.g., the following example doesn&rsquo;t violate the law:</p>

<p><code>rb
input.to_s.strip.split(" ").map(&amp;:capitalize).join(" ")
</code></p>

<p>but the following one does:</p>

<p><code>rb
payment.client.address
</code></p>

<p>Respecting <strong>Law of Demeter</strong> usually results in a clean and maintainable code, so unless you have a good reason to violate it, you should stick to the law and avoid tight coupling.</p>

<p>Let&rsquo;s get back to the example with <code>payment</code>, <code>client</code> and <code>address</code>. How could we refactor the following code?</p>

<p><code>rb
payment.client.try(:address)
</code></p>

<p>The first thing would be to reduce structural coupling and implement <code>Payment#client_address</code> method:</p>

<p>``` rb
class Payment
  def client_address</p>

<pre><code>client.try(:address)
</code></pre>

<p>  end
end
```</p>

<p>It&rsquo;s much better now &ndash; instead of referring to the address via <code>payment.client.try(:address)</code> we can simply do <code>payment.client_address</code>, which is already an improvement as <code>Object#try</code> happens only in one place. Let&rsquo;s refactor it further.</p>

<p>We are left now with two options: either <code>client</code> being <code>nil</code> is a legit case or not. If it is, we can make the code look confident and explicitly return early, which clearly shows that having no <code>client</code> is a valid use case:</p>

<p>``` rb
class Payment
  def client_address</p>

<pre><code>return nil if client.nil?

client.address
</code></pre>

<p>  end
end
```</p>

<p>If it never happens to be <code>nil</code>, we can skip the guard statement:</p>

<p>``` rb
class Payment
  def client_address</p>

<pre><code>client.address
</code></pre>

<p>  end
end
```</p>

<p>Such delegations are pretty generic; maybe Rails has some nice solution to this problem? The answer is &ldquo;yes&rdquo;! <code>ActiveSupport</code> offers a very nice solution to the exact issue: <a href="http://api.rubyonrails.org/classes/Module.html#method-i-delegate" target="_blank"><code>ActiveSupport#delegate</code></a> macro. Thanks to that macro, you can define delegations and even handle <code>nil</code> in the exact way we did it.</p>

<p>The first example, where <code>nil</code> is a legit use case, could be rewritten the following way:</p>

<p><code>rb
class Payment
  delegate :address, to: :client, prefix: true, allow_nil: true
end
</code></p>

<p>and the second one, if <code>nil</code> is never to be expected:</p>

<p><code>rb
class Payment
  delegate :address, to: :client, prefix: true
end
</code></p>

<p>Much cleaner, less coupled and we&rsquo;ve managed to achieve the final result of not using <code>Object#try</code>, but just in a much more elegant way.</p>

<p>However, it is still possible that we might not expect payment to have an empty client (e.g. payment for the transaction that is not completed yet) in some cases, e.g., when displaying data for the payments with completed transactions, but somehow we are getting dreaded <code>NoMethodEror</code> exception. It doesn&rsquo;t necessarily mean that we need to add <code>allow_nil: true</code> option in <code>delegate</code> macro and for sure it doesn&rsquo;t mean that we should use <code>Object#try</code>. The solution here would be:</p>

<h3>Operating on the scoped data</h3>

<p>If we want to deal payments with completed transactions, which are guaranteed to have <code>client</code>, why not simply make sure that we are dealing with the right set of data? In Rails apps that would probably mean applying some ActiveRecord <code>scope</code> to <code>Payment</code>s collection, like <code>with_completed_transactions</code>:</p>

<p><code>rb
Payment.with_completed_transactions.find_each do |payment|
  do_something_with_address(payment.client_address)
end
</code></p>

<p>Since we never plan to do anything with client&rsquo;s <code>address</code> for payments for not completed transactions, we don&rsquo;t need to explicitly handle <code>nil</code>s here.</p>

<p>Nevertheless, even if <code>client</code> were always required for creating a payment, it would still be possible that such code might result in <code>NoMethodError</code>. One example where that might happen would be a deleted by mistake associated <code>client</code> record. In that case, we would need to fix:</p>

<h3>Data integrity</h3>

<p>Ensuring data integrity, especially with RDBMS like PostgreSQL, is quite simple &ndash; we just need to remember about adding the right constraints when creating new tables. Keep in mind that this needs to be handled on a database level, validations in models are never enough as they can easily be bypassed. To avoid the issue where <code>client</code> turns out to be <code>nil</code>, despite presence validation, we should add <code>NOT NULL</code> and <code>FOREIGN KEY</code> constraints when creating <code>payments</code> table, which will prevent us from not having a client assigned at all and also deleting the client record if it&rsquo;s still associated with some payment:</p>

<p><code>rb
create_table :payments do |t|
  t.references :client, index: true, foreign_key: true, null: false
end
</code></p>

<p>And that&rsquo;s it! By remembering about those constraints, you can avoid a lot of unexpected use cases with <code>nil</code>s.</p>

<h3>Ensuring types via explicit conversion</h3>

<p>I saw few times <code>Object#try</code> used in a quite exotic way which looked similar to this:</p>

<p><code>rb
params[:name].try(:upcase)
</code></p>

<p>Well, this code clearly shows that some string is expected to be found under <code>name</code> key in <code>params</code>, so why not just ensure it is a string by applying explicit conversion using <code>to_s</code> method?</p>

<p><code>rb
params[:name].to_s.upcase
</code></p>

<p>Much cleaner that way!</p>

<p>However, those two codes are not equivalent. The former one returns a string if <code>params[:name]</code> is a string, but if it is <code>nil</code>, it will return <code>nil</code>. The latter always returns a string. It is not entirely clear if <code>nil</code> is expected in such case (which is the obvious problem with <code>Object#try</code>), so we are left with two options:</p>

<ul>
<li><code>nil</code> is the expected return value if <code>params[:name]</code> is <code>nil</code> &ndash; might not be the best idea as dealing with nils instead of strings might be quite inconvenient, however, in some cases, it might be necessary to have <code>nil</code>s. If that&rsquo;s the case, we can make it clear that we expect <code>params[:name]</code> to be <code>nil</code> by adding a guard statement:</li>
</ul>


<p>``` rb
return if params[:name].nil?</p>

<p>params[:name].to_s.upcase
```</p>

<ul>
<li>a string is the expected return type &ndash; we don&rsquo;t need to bother with guard statements, and we can just keep the explicit conversion:</li>
</ul>


<p><code>rb
params[:name].to_s.upcase
</code></p>

<p>In more complex scenarios, it might be a better idea to use form objects and/or have a more robust types management, e.g. by using <a href="https://github.com/dry-rb/dry-types" target="_blank">dry-types</a>, but the idea would still be the same as for explicit conversions, it would just be better as far as the design goes.</p>

<h3>Using right methods</h3>

<p>Dealing with nested hashes is quite a common use case, especially when building APIs and dealing with user-provided payload. Imagine you are dealing with JSONAPI-compliant API and want to grab client&rsquo;s name when updating. The expected payload might look like this:</p>

<p>``` rb
{
  data: {</p>

<pre><code>id: 1,
type: "clients",
attributes: {
  name: "some name"
}
</code></pre>

<p>  }
}
```</p>

<p>However, since we never know if the API consumer provided a proper payload or not, it would make sense to assume that the structure won&rsquo;t be right.</p>

<p>One terrible way to handle it would be using&hellip; guess what? Obviously <code>Object#try</code>:</p>

<p><code>rb
params[:data].try(:[], :attributes).try(:[], :name)
</code></p>

<p>It&rsquo;s certainly hard to say that this code looks pleasant. And the funny thing is that it is really easy to rewrite cleanly.</p>

<p>One solution would be applying explicit conversions on each intermediate step:</p>

<p><code>rb
params[:data].to_h[:attributes].to_h[:name]
</code></p>

<p>That&rsquo;s better, but not really expressive. Ideally, we would use some dedicated method. One of those potentially dedicated methods is <a href="https://ruby-doc.org/core-2.2.0/Hash.html#method-i-fetch" target="_blank"><code>Hash#fetch</code></a> which allows you to provide a value that should be returned if the given key is not present in the hash:</p>

<p><code>rb
params.fetch(:data).fetch(:attributes, {}).fetch(:name)
</code></p>

<p>It looks even better but would be nice to have something even more dedicated for digging through nested hashes. Fortunately, since Ruby 2.3.0, we can take advantage of <a href="http://ruby-doc.org/core-2.3.0_preview1/Hash.html#method-i-dig" target="_blank"><code>Hash#dig</code></a>, which was implemented for exactly this purpose &ndash; digging through nested hashes and not raising exceptions if some intermediate key turns out to not be there:</p>

<p><code>rb
params.dig(:data, :attributes, :name)
</code></p>

<h3>Having Proper interfaces / Duck typing</h3>

<p>Let&rsquo;s get back to the example that was mentioned in the beginning with sending a potential notification:</p>

<p>``` rb
class MyService
  def call(object)</p>

<pre><code>object.save!
object.try(:send_success_notification, "saved from MyService")
</code></pre>

<p>  end
end
```</p>

<p>There are two possible solutions here:</p>

<ul>
<li><strong>Implementing two set of services</strong> &ndash; one that sends notifications and one that doesn&rsquo;t:</li>
</ul>


<p>``` rb
class MyServiceA
  def call(object)</p>

<pre><code>object.save!
</code></pre>

<p>  end
end</p>

<p>class MyServiceB
  def call(object)</p>

<pre><code>object.save!
object.send_success_notification("saved from MyService")
</code></pre>

<p>  end
end
```</p>

<p>Thanks to this refactoring, the code is much cleaner, and we easily got rid of <code>Object#try</code>. However, now we need to know that for one type of objects we need to use <code>MyServiceA</code> and for another type <code>MyServiceB</code>. It might make sense, but might also be a problem. In such case the 2nd option would be better:</p>

<ul>
<li><strong>Duck typing</strong>. Simply add <code>send_success_notification</code> method to all objects that are passed to <code>MyService</code> and if it&rsquo;s supposed to do nothing, just leave the method body empty:</li>
</ul>


<p>``` rb
class MyService
  def call(object)</p>

<pre><code>object.save!
object.send_success_notification("saved from MyService")
</code></pre>

<p>  end
end
```</p>

<p>The extra benefit of this option is that it helps to identify some common behaviors of the objects and to make them explicit. As you can see, in case of <code>Object#try</code> a lot of domain concepts might stay implicit and unclear. It doesn&rsquo;t mean they are not there; they are just not clearly identified. This is yet another important thing to keep in mind &ndash; <code>Object#try</code> also hurts your domain.</p>

<h3>Null Object Pattern</h3>

<p>Let&rsquo;s reuse the example above with sending notifications after persisting some models and do a little modification &ndash; we will make <code>mailer</code> an argument of the method and call <code>send_success_notification</code> on it:</p>

<p>``` rb
class MyService
  def call(object, mailer: SomeMailer)</p>

<pre><code>object.save!
mailer.send_success_notification(object, "saved from MyService")
</code></pre>

<p>  end
end
```</p>

<p>That&rsquo;s going to work great if we always want to send a notification. What if we don&rsquo;t want to do it? One terrible way to handle it would be passing <code>nil</code> as a mailer and take advantage of <code>Object#try</code>:</p>

<p>``` rb
class MyService
  def call(object, mailer: SomeMailer)</p>

<pre><code>object.save!
mailer.try(:send_success_notification, object, "saved from MyService")
</code></pre>

<p>  end
end</p>

<p>Service.new.call(object, mailer: nil)
```</p>

<p>But you&rsquo;ve probably already guessed this solution is a no-go. Fortunately, we can apply <a href="https://en.wikipedia.org/wiki/Null_Object_pattern" target="_blank">Null Object Pattern</a> and pass an instance of some <code>NullMailer</code> which implements <code>send_success_notification</code> method that simply does nothing:</p>

<p>``` rb
class NullMailer
  def send_success_notification(*)
  end
end</p>

<p>class MyService
  def call(object, mailer: SomeMailer)</p>

<pre><code>object.save!
mailer.send_success_notification(object, "saved from MyService")
</code></pre>

<p>  end
end</p>

<p>MyService.new.call(object, mailer: NullMailer.new)
```</p>

<p>That&rsquo;s certainly better than using <code>Object#try</code>.</p>

<h2>What about <code>&amp;.</code> a.k.a. lonely/safe navigation operator?</h2>

<p><code>&amp;.</code>, lonely/safe navigation operator is a pretty new thing introduced in Ruby 2.3.0. It&rsquo;s quite similar to <code>Object#try</code>, but it&rsquo;s less ambiguous &ndash; if you call a method on the object different than <code>nil</code>, and this method is not implemented by that object, <code>NoMethodError</code> will still be raised which is not the case for <code>Object#try</code>. Check the following examples:</p>

<p><code>`` rb
User.first.try(:unknown_method) # assuming</code>user` is nil
=> nil</p>

<p>User.first&amp;.unknown_method
=> nil</p>

<p>User.first.try(:unknown_method!) # assuming <code>user</code> is not nil
=> nil</p>

<p>User.first&amp;.unknown_method
=> NoMethodError: undefined method `unknown_method' for #&lt;User:0x007fb10c0fd498>
```</p>

<p>Does it mean safe navigation operator is fine and safe to use? Not really. It still comes with the same problems as <code>Object#try</code> does, it&rsquo;s merely one serious issue less.</p>

<p>Nevertheless, I think there is a case where the lonely operator is not that bad. Check the following example:</p>

<p><code>rb
Comment.create!(
  content: content,
  author: current_user,
  group_id: current_user&amp;.group_id,
)
</code></p>

<p>What we want to do is create a comment belonging to some <code>current_user</code> who might be an author and also assign a <code>group_id</code> from <code>current_user</code>, who might be nil.</p>

<p>The same code could be written as:</p>

<p><code>rb
Comment.create!(content: content, author: current_user) do |c|
  c.group_id = current_user&amp;.group_id if current_user
end
</code></p>

<p>or maybe as:</p>

<p>``` rb
comment_params = {
  content: content,
  author: current_user,
}</p>

<p>comment_params[:group_id] = current_user.group_id if current_user</p>

<p>Comment.create!(comment_params)
```</p>

<p>But I think neither of those alternatives is more readable than the first example with <code>&amp;.</code> operator, so might be worth trading a bit of clarity for more readability.</p>

<h2>Wrapping Up</h2>

<p>I believe there is not a single valid use case for <code>Object#try</code> due to the <strong>ambiguity</strong> of its intentions, <strong>negative impact</strong> on the <strong>domain</strong> model and simply for the fact that there are <strong>many other ways</strong> to solve the problems that <code>Object#try</code> &ldquo;solves&rdquo; in a clumsy way &ndash; starting from respecting Law of Demeter and delegations, through operating on properly scoped data, applying right database constraints, ensuring types using explicit conversions, using proper methods, having right interfaces, taking advantage of duck typing, ending with Null Object Pattern  or even using the safe navigation operator (<code>&amp;.</code>) which is much safer to use and might be applied in limited cases.</p>

<p><img src="/images/object_try/yoda.jpeg" title="&lsquo;yoda&rsquo; &lsquo;yoda&rsquo;" ></p>

<p class="small-p center">
  Source: https://www.pbnsg.org/weight-management/2015/7/27/do-or-do-not-there-is-no-try-yoda
</p>



]]></content>
  </entry>
  
</feed>
