<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2018-07-29T20:22:18+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails And Conditional Validations In Models]]></title>
    <link href="https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models/"/>
    <updated>2018-06-24T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models</id>
    <content type="html"><![CDATA[<p>Adding consents for accepting Terms of Service/Privacy Policies must have been a top popular feature in the majority of the applications due to enforcement of <strong>GDPR</strong> in May ;). From the technical aspects that GDPR requires, there is a proof of consent for processing the personal information. In that case, you need to have some actual attributes in the database that would confirm the fact that some user has indeed accepted Terms of Service/Privacy Policy.</p>

<p>That makes a significant impact on how we approach this kind of features. However, in the past, such things were quite often not stored in a database at all &ndash; it just took some UI <strong>acceptance validation</strong> or maybe a <strong>validation of the virtual attribute</strong> on the backend to be on the safe side.</p>

<p>Let&rsquo;s focus on the latter case where we don&rsquo;t need to store anything in DB and see what the possible solutions to that problems are. As <strong>trivial</strong> as this problem initially sounds, it will get <strong>quite interesting</strong> ;).</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>We want to make sure a user accepts Terms of Service during the signup process and to be sure that it is indeed validated, even if JavaScript validation fails in UI, we want to validate that fact on the backend.</p>

<h2>Solution 1 &ndash; Just add a virtual attribute to the model and validate it</h2>

<p>It is probably the most straightforward approach to that problem and most likely the least elegant. That&rsquo;s how we could implement it:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Well, it does work, no doubt about that. But currently, the validation will always be triggered, even during updates, which doesn&rsquo;t make much sense. We need to find a better solution.</p>

<h2>Solution 2 &ndash; Add a virtual attribute to the model and validate it only during the creation of a user</h2>

<p>A minor improvement over the previous version, we make sure that the validation is not triggered by updates, but only when creating a user:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :create
end
```</p>

<p>Even if it solves the actual problem, there is a big issue about that &ndash; the validation will always be triggered during a creation, even when creating users from factories! What other options do we have?</p>

<h2>Solution 3 &ndash; Add a virtual attribute to the model and validate it only for a specific context</h2>

<p>What is interesting in ActiveModel validations is that <code>on</code> option is not limited to <code>:create</code> or <code>:update</code> contexts &ndash; those are merely the ones that ActiveRecord sets by default depending on the persistence status of the model. We can provide a custom context for both <code>valid?</code> and <code>save</code> methods:</p>

<p><code>rb
user.valid?(:registration)
user.save(context: :registration)
</code></p>

<p>In that case, we could replace <code>:create</code> context with <code>:registration</code> context for the acceptance validation:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :registration
end
```</p>

<p>However, this is still not ideal &ndash; a global model which is used in multiple contexts has some logic that only applies to just one use case, and what is even worse, it&rsquo;s for an UI concern.</p>

<p>Let&rsquo;s try to find a solution that doesn&rsquo;t add any unnecessary mess to a model.</p>

<h2>Solution 4 &ndash; Use form object</h2>

<p>Using form object is probably the cleanest solution to our problem &ndash; we don&rsquo;t introduce any additional concerns to a model which should not be there, and we handle everything in a dedicated object. The are multiple ways how to implement a form object: we could create another ActiveModel model and take advantage of <a href="https://github.com/Azdaroth/active_model_attributes">ActiveModel Attributes</a> to make it smoother. We could use <a href="http://dry-rb.org/gems/dry-validation/basics/working-with-schemas/">dry-validation</a> gem for that. Or we could use my favorite tool for that purpose: <a href="https://github.com/trailblazer/reform">reform</a> gem from <a href="http://trailblazer.to">Trailblazer</a> stack.</p>

<p>Explaining the entire API of <code>reform</code> gem is way beyond the scope of this article, but the following implementation should be quite self-explanatory:</p>

<p>``` rb</p>

<h1>app/forms/user/registration_form.rb</h1>

<p>require &ldquo;reform/form/coercion&rdquo;</p>

<p>class User::RegistrationForm &lt; Reform::Form
  # other property declarations and validations</p>

<p>  property :terms_of_service_accepted, virtual: :true, type: Types::Form::Boolean</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Besides handling other properties (most likely <code>email</code>, <code>password</code> and <code>password confirmation</code>), we are adding a virtual <code>terms_of_service_accepted</code> attribute with explicit type and adding acceptance validation using ActiveModel validator.</p>

<p>Even though using form objects is the cleanest approach, it requires some extra overhead, mostly with the setup, and sometimes it might be painful to add that setup, especially when extending third party&rsquo;s logic, e.g. <a href="https://github.com/scambra/devise_invitable">devise_invitable</a>. In such case, we would need some heavy customization which could potentially break when updating a gem and we would also need extra test coverage for the custom solution. It might still be worth introducing a form object, but it would be a good idea to consider other potential solutions. What option do we have left?</p>

<h2>Solution 5 &ndash; Extend user&rsquo;s instance with a custom logic</h2>

<p>Have you ever heard of DCI (Data Context Interaction) paradigm? If yes, you might have seen something like that:</p>

<p><code>rb
user = User.find(id)
user.extend(User::RegistrationContext)
</code></p>

<p>What this code does is adding extra functionality from <code>User::RegistrationContext</code> module to user&rsquo;s singleton class. Effectively, it means that we are not adding any additional logic to all User class instances, but only to that particular instance. Sounds like exactly what we need! That way, we can solve our problem achieving all the other goals as well &ndash; ease of extending the logic without too much overhead and without making a mess in the model.</p>

<p>Here is how our implementation of <code>User::RegistrationContext</code> context module could look like:</p>

<p>``` rb</p>

<h1>app/models/user/registration_context.rb</h1>

<p>module User::RegistrationContext
  def self.extended(model)</p>

<pre><code>class &lt;&lt; model
  validates :terms_of_service_accepted, acceptance: true
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :terms_of_service_accepted
end
```</p>

<p>The interesting thing about this implementation is that there is some singletons' inception going on there &ndash; first, we are using <code>extend</code> itself on the model, and then, in <code>extended</code> module hook we are opening singleton class of the model and declaring validation there. However, this is necessary since <code>validates</code> method is not defined in the context of that module, and we need to do that in the context of the model.</p>

<p>Let&rsquo;s try our fancy solution in action:</p>

<p><code>rb
user = User.new
user.extend(User::RegistrationContext)
user.terms_of_service_accepted = "0"
user.valid?
=&gt; false
user.errors.messages[:terms_of_service_accepted]
=&gt; ["must be accepted"]
</code></p>

<p>Perfect, that&rsquo;s exactly what we needed!</p>

<h2>Wrapping Up</h2>

<p>There are multiple ways in Rails (or Ruby in general) to handle <strong>conditional validation</strong>, and thanks to the flexibility of the framework and the language, we can pick whatever seems best for our particular problem &ndash; from adding additional validations in a model with <strong>extra ActiveModel context</strong>, through using <strong>form objects</strong>, ending with arcane DCI-style object&rsquo;s extensions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Case for before_validation callback: complex state normalization]]></title>
    <link href="https://karolgalanciak.com/blog/2018/05/27/the-case-for-before-validation-callback-complex-state-normalization/"/>
    <updated>2018-05-27T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/05/27/the-case-for-before-validation-callback-complex-state-normalization</id>
    <content type="html"><![CDATA[<p>Few months ago I wrote a <a href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/">blog post</a> about <strong>ActiveRecord</strong> <code>before_validation</code> callback and how it is used for  <strong>wrong reasons</strong> and concluded that in most cases this is not something we should be using routinely. However, I missed one <strong>appropriate use case</strong> for it which might be quite common in Rails apps, so this might be an excellent opportunity to get back to  <strong>before_validation callback</strong> and show its other side.</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Imagine that we have a <code>Payment</code> model where we need to store <code>amount</code> and <code>currency</code>. However, for statistical purposes, we also want to store normalized amount in USD currency with exchange rate applied at the time of payment&rsquo;s creation. As this is a significant part of our domain, we want to add validation for <code>amount_in_usd</code> attribute. Our Payment model looks like this at the moment:</p>

<p><code>rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true
end
</code></p>

<p>The question is: where do we get <code>amount_in_usd</code> from and how can we assign it?</p>

<h2>The Solution</h2>

<p>One way of solving that problem would be a direct assignment when populating all the attributes. In that case, it would look a bit like this:</p>

<p><code>rb
Payment.new(currency: currency, amount: amount, amount_in_usd: CurrencyExchanger.exchange(amount, from: currency, to: "USD"))
</code></p>

<p>The problem with that solution is that this logic would need to be repeated in every place where payment gets initialized. We could implement a factory class that would be reused in all scenarios to keep it DRY, but that&rsquo;s some extra overhead that is not popular in a Rails world. Also, this sounds like a responsibility of the Payment model itself as it is about managing its internal state.</p>

<p>Here, we can&rsquo;t solve this by overriding writers as I suggested <a href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/">before</a> as <code>amount_in_usd</code> depends on two attributes: <code>currency</code> and <code>amount</code>, and we don&rsquo;t know in which sequence the attributes will be assigned.</p>

<p>And this is exactly the case where <code>before_validation</code> is useful: for complex state normalization where multiple attributes are involved. With that callback, a solution looks quite elegant and just simpler:</p>

<p>``` rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true</p>

<p>  before_validation :assign_amount_in_usd</p>

<p>  private</p>

<p>  def assign_amount_in_usd</p>

<pre><code>if currency &amp;&amp; amount
  self.amount_in_usd = CurrencyExchanger.exchange(amount, from: currency, to: "USD")
end
</code></pre>

<p>  end
end
```</p>

<h2>Alternative Solution</h2>

<p>In the first paragraph, I mentioned that this solution could work especially well in Rails apps. What I meant by that is the fact that usually, the &ldquo;primitive&rdquo; attributes coming from HTTP params are mass-assigned to the model. Of course in Ruby, everything is an object, but to keep things simpler, let&rsquo;s treat numeric types and strings as primitives.</p>

<p>What would be a non-primitive value though? In our case, we have something that is widely used as a typical example of a value object: <strong>Money</strong> object that is composed of <code>amount</code> and <code>currency</code>.  If the attributes before the assignment were mapped to some more domain-oriented objects, we would have an even simpler solution for our problem:</p>

<p><code>rb
money = Money.new(amount, currency)
Payment.new(money: money)
</code></p>

<p>and the model would look like this:</p>

<p>``` rb
class Payment &lt; ApplicationRecord
  validates :amount, :currency, :amount_in_usd, presence :true</p>

<p>  def money=(money_object)</p>

<pre><code>self.amount = money_object.amount
self.currency = money_object.currency
self.amount_in_usd = CurrencyExchanger.exchange_money(money_object, to: "USD")
</code></pre>

<p>  end
end
```</p>

<p>It might look like extra overhead that is not necessary. However, value objects tend to simplify and DRY a lot of things in the code, so for more complex apps, using value objects will be worth that extra overhead.</p>

<h2>Wrapping Up</h2>

<p>There are some cases where <code>before_validation</code> callback might be useful. However, in more complex apps, using value object might be an alternative worth looking into.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Quick Tips: Temporarily Disabling Touching with ActiveRecord.no_touching]]></title>
    <link href="https://karolgalanciak.com/blog/2018/02/25/rails-quick-tips-temporarily-disabling-touching-with-activerecord-dot-no-touching/"/>
    <updated>2018-02-25T20:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2018/02/25/rails-quick-tips-temporarily-disabling-touching-with-activerecord-dot-no-touching</id>
    <content type="html"><![CDATA[<p><strong>Touching</strong> <strong>ActiveRecord models</strong> is quite a common thing in most of the <strong>Rails applications</strong>, especially useful for cache invalidation. By default, it updates <code>updated_at</code> timestamp with the current time, Here&rsquo;s a typical example of using <a href="https://apidock.com/rails/ActiveRecord/Persistence/touch">touch</a> in a model:</p>

<p>``` ruby</p>

<h1>app/models/photo.rb</h1>

<p>class Photo &lt; ApplicationRecord
  belongs_to :user, touch: true
end
```</p>

<p>Whenever a new photo is created, or the existing one is updated/destroyed, the <code>updated_at</code> attribute of the associated user will be updated with the current time. In the majority of the cases, this is the desired behavior (it&rsquo;s one of those rare ActiveRecord callbacks that is not that bad ;)). However, it might happen that you may not want <code>touch</code> to be executed for some reason. Is there any built-in solution that could solve that problem?</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Temporarily disabling <code>touch</code>ing can useful either for performance reasons (when updating a large number of records) or simply to prevent <code>after_touch</code> or <code>after_commit</code> from being executed multiple times. The latter might indicate that there is a deeper problem in the design as putting any important logic causing side-effects beyond the record&rsquo;s internal state in those <strong>ActiveRecord callbacks</strong> can easily go south (especially if you trigger email notifications), but the reality is that a lot of Rails applications use those callbacks in such cases.</p>

<h2>The Solution</h2>

<p>Fortunately, a heavy refactoring or a rewrite is not necessary. Instead, we can take advantage of <a href="http://api.rubyonrails.org/classes/ActiveRecord/NoTouching/ClassMethods.html">ActiveRecord.no_touching</a> which temporarily disables touching inside the block.</p>

<p>Imagine that you need to update all photos belonging to some user and <code>touch</code> this user only after all photos are updated. Here&rsquo;s how it could be handled:</p>

<p>``` ruby
user = User.find(user_id)</p>

<p>ActiveRecord::Base.transaction do
  User.no_touching do</p>

<pre><code>user.photos.find_each do |photo|
  # user won't be `touch`ed
  photo.update!(some_attributes)
end
</code></pre>

<p>  end</p>

<p>  user.touch
end
```</p>

<p>If for some reason disabling touching is necessary for all models, you could just call it on <code>ActiveRecord::Base</code>:</p>

<p>``` ruby
user = User.find(user_id)</p>

<p>ActiveRecord::Base.transaction do
  ActiveRecord::Base.no_touching do</p>

<pre><code>user.photos.find_each do |photo|
  # no model will be `touch`ed
  photo.update!(some_attributes)
end
</code></pre>

<p>  end</p>

<p>  user.touch
end
```</p>

<p>And that&rsquo;s it!</p>

<h2>Summary</h2>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/NoTouching/ClassMethods.html"><code>ActiveRecord.no_touching</code></a> is certainly a quick solution to a potentially tricky issue. However, it is also a dirty hack that indicates a potential problem with the design of the application that should be addressed sooner than later.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Traps on Rails - Overriding boolean methods in models]]></title>
    <link href="https://karolgalanciak.com/blog/2017/11/26/traps-on-rails-overriding-boolean-methods-in-models/"/>
    <updated>2017-11-26T16:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2017/11/26/traps-on-rails-overriding-boolean-methods-in-models</id>
    <content type="html"><![CDATA[<p>One very <strong>useful</strong> feature of <strong>ActiveRecord</strong> is automatically defining attribute readers and writers for all the columns for given tables. For the ones with <strong>boolean</strong> type, however, there is one more addition &ndash; defining an <strong>alias</strong> of the method with a question mark. Sometimes it might be useful to override this method and add some extra requirements for a given condition. However, this might not be such a good idea.</p>

<!--more-->


<h2>Anatomy of the problem</h2>

<p>Imagine that you are developing some application, where users can be activated and deactivated from an admin panel. However, the application is not free, and every user that wants to access the application needs to buy a subscription. In that case, to check if the user is, in fact, active, you could override <code>User#active?</code> method and add some extra requirements regarding the subscription:</p>

<p>``` rb</p>

<h1>app/models/users.rb</h1>

<p>class User &lt; ApplicationRecord
  def active?</p>

<pre><code>super &amp;&amp; valid_subscription?
</code></pre>

<p>  end</p>

<p>  def valid_subscription?</p>

<pre><code># somehow check if the subscription is valid
</code></pre>

<p>  end
end
```</p>

<p>We are taking advantage of the fact that ActiveRecord defines the aliases for boolean columns which are the original column names' ending with a question mark, so for <code>active</code> boolean column we can expect that <code>active?</code> method will be defined, and it will work the same as <code>active</code> method.</p>

<p>Ok, cool, we have our feature working and to check if a user is fully active, we call <code>User#active?</code> here and there. Our next requirement is exposing users in the API. Nothing too hard, we can add <a href="https://github.com/fotinakis/jsonapi-serializers"><code>jsonapi-serializers</code></a> gem and implement fully JSONAPI-compliant serializers. It turns out that we need to expose info if a user is active and not. Here is how our serializer could look like:</p>

<p>``` rb</p>

<h1>app/serializers/user.rb</h1>

<p>class UserSerializer
  include JSONAPI::Serializer</p>

<p>  attribute :active
  # other attributes
end
```</p>

<p>It sounds like we are done here. But the truth is there is a nasty bug here! The serializer returns the value returned by <code>User#active</code>, not by <code>User#active?</code>!</p>

<h2>What exactly went wrong here?</h2>

<p>The primary thing that went wrongs here was being lazy about the naming and not introducing proper domain concepts. Somehow ActiveRecord made it even easier &ndash; there was already a method called <code>active?</code> defined based on the <code>active</code> column name, so the only thing that was necessary in that case to make our first feature work was overriding it and adding some extra condition because the idea of being &ldquo;active&rdquo; is kind of similar. But overriding boolean methods is never a good idea &ndash; it always implies that some concept is missing or is made implicit in the code.</p>

<h2>A solution to the problem</h2>

<p>A solution would be simply making this domain concept explicit. <code>User#active?</code> method doesn&rsquo;t check if the user is active is not, it rather checks if a user can access the application, so the better name for that method would be <code>User#can_access_application?</code></p>

<p>It is quite possible that we might later need to add some extra features that are related to this feature, like checking if the user is active but cannot access the app or just simply checking the <code>active</code> flag itself. Our final model could look like this in the end:</p>

<p>``` rb</p>

<h1>app/models/users.rb</h1>

<p>class User &lt; ApplicationRecord
  def can_access_application?</p>

<pre><code>active? &amp;&amp; valid_subscription?
</code></pre>

<p>  end</p>

<p>  def cannot_access_application?</p>

<pre><code>!can_access_application?
</code></pre>

<p>  end</p>

<p>  # other methods
end
```</p>

<p>We should also update the serializer:</p>

<p>``` rb</p>

<h1>app/serializers/user.rb</h1>

<p>class UserSerializer
  include JSONAPI::Serializer</p>

<p>  attribute :active do</p>

<pre><code>object.active
</code></pre>

<p>  end</p>

<p>  attribute :can_access_application do</p>

<pre><code>object.can_access_application?
</code></pre>

<p>  end</p>

<p>  attribute :cannot_access_application do</p>

<pre><code>object.cannot_access_application?
</code></pre>

<p>  end
end
```</p>

<p>One could argue that this fix was not necessary and it was a developer&rsquo;s fault, and he or she should have checked the model if this method has not been overridden and adjust the serializer. That is somehow true, but if such code is deployed to production, it probably means that the reviewer of the code was not aware that there is a potential issue in the code and such things are really hard to spot &ndash; ActiveRecord adds those aliases for every boolean column so it might sound like a fair assumption that <code>User#active</code> and <code>User#active?</code> will return the same result.</p>

<p>However, the truth is that not only did we minimize the risk of having the name collisions by those changes but we gained some extra flexibility, and it was quite straight-forward to differentiate between <code>User#active?</code>and <code>User#can_access_application?</code>. In a previous implementation, it was simply not possible with the question-mark methods.</p>

<h2>Wrapping up</h2>

<p>Naming is one of <a href="https://martinfowler.com/bliki/TwoHardThings.html" target="_blank">two hard problems in computer science</a> and it&rsquo;s a good idea to always make all the domain concepts properly named and explicit, even if it means adding more code &ndash; just because something is not explicit, doesn&rsquo;t mean it doesn&rsquo;t exist. When it comes to <strong>ActiveRecord</strong> models, an extra caution is more than recommended &ndash; such models mix both persistence and domain concepts and it&rsquo;s quite easy to hurt yourself in such case. Not overriding boolean methods generated by ActiveRecord and properly naming things sounds like a good rule of thumb to follow.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Case Against Exotic Usage of :before_validate Callbacks]]></title>
    <link href="https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks/"/>
    <updated>2017-10-29T22:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2017/10/29/the-case-against-exotic-usage-of-before-validate-callbacks</id>
    <content type="html"><![CDATA[<p>It&rsquo;s nothing new that <strong>ActiveRecord callbacks</strong> are abused in many projects and used for the wrong reasons for many use cases where they can be <strong>easily avoided</strong> in favor of a much better alternative, like service objects. There is one callback though that is special and quite often used for pretty <strong>exotic reasons</strong> that have nothing to do with the process when it gets executed &ndash; it&rsquo;s the <code>before_validate</code> callback.</p>

<!--more-->


<h2>Data Formatting</h2>

<p>Data formatting is something pretty common in the majority of the applications, especially stripping strings. Imagine that you need to strip some <code>URL</code> so that potential spaces won&rsquo;t cause any issues. How would you approach that?</p>

<p>One way would be to use <code>before_validate</code> callback, especially if you have some format validations:</p>

<p>``` ruby app/models/my_model.rb
class MyModel
  before_validate :strip_url</p>

<p>  private</p>

<p>  def strip_url</p>

<pre><code>self.url = url.to_s.strip
</code></pre>

<p>  end
end
```</p>

<p>It gets the job done. However, how would you test it? You would need to call <code>valid?</code> method on the model to check that&hellip; <code>URL</code> is stripped? Sounds quite funny and is even better when you look at the potential spec:</p>

<p>``` ruby spec/models/my_model_spec.rb
require &ldquo;rails_helper&rdquo;</p>

<p>RSpec.describe MyModel, type: :model do
  it &ldquo;strips URL before validation&rdquo; do</p>

<pre><code>model = MyModel.new(url: "  http://rubyonrails.org")

model.valid?

expect(model.url).to eq "http://rubyonrails.org"
</code></pre>

<p>  end
end
```</p>

<p>It&rsquo;s quite unlikely that this would be the result of <strong>TDD</strong> though ;). What&rsquo;s the alternative then?</p>

<p>How about just using attribute writer for that? So something like this:</p>

<p>``` ruby app/models/my_model.rb
class MyModel
  def url=(val)</p>

<pre><code>super(val.to_s.strip)
</code></pre>

<p>  end
end
```</p>

<p>And here is a potential spec for this feature:</p>

<p>``` ruby spec/models/my_model_spec.rb
require &ldquo;rails_helper&rdquo;</p>

<p>RSpec.describe MyModel, type: :model do
  it &ldquo;strips URL&rdquo; do</p>

<pre><code>model = MyModel.new(url: "  http://rubyonrails.org")

expect(model.url).to eq "http://rubyonrails.org"
</code></pre>

<p>  end
end
```</p>

<p>Both the implementation and spec are much simpler and just more natural &ndash; data formatting has nothing to do with the validation, there is no need to use a callback related to validation to handle such use case.</p>

<h2>Populating attributes and relationships</h2>

<p>Another popular scenario is assigning attributes and relationships. Imagine you are creating a comment with a <code>content</code>, an author who will be <code>current_user</code> and also want to do some denormalization for performance reasons and directly assign <code>group</code> to this comment to which <code>current_user</code> belongs to. Here is how it is sometimes handled with <code>before_validate</code> callback:</p>

<p><code>ruby
Comment.create!(
  content: content,
  author: current_user,
)
</code></p>

<p>``` ruby app/models/my_model.rb
class MyModel
  before_validate :assign_group</p>

<p>  private</p>

<p>  def assign_group</p>

<pre><code>self.group = author.group if author
</code></pre>

<p>  end
end
```</p>

<p>It&rsquo;s quite similar to the previous use case with data formatting &ndash; to write a test for this feature, we would need again to call <code>valid?</code> which doesn&rsquo;t make much sense, validation has nothing to do with populating attributes or relationships. There is much simpler and much more explicit way to handle it:</p>

<p><code>ruby
Comment.create!(
  content: content,
  author: current_user,
  group: current_user.group,
)
</code></p>

<p>There is no magic here &ndash; just a simple assignment, which is easy to test and understand.</p>

<h2>Wrapping up</h2>

<p>Maybe there are some scenarios where <code>before_validate</code> callback is the best possible choice (I&rsquo;m yet to find them though), but I&rsquo;m pretty sure data formatting or populating attributes/associations are not valid cases to use it for.</p>
]]></content>
  </entry>
  
</feed>
