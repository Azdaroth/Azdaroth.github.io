<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ember | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/ember/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2019-03-04T15:26:44+01:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Ember Data Customization - Different Model Types in Ember App and API For The Same Resource]]></title>
    <link href="https://karolgalanciak.com/blog/2018/04/28/advanced-ember-data-customization-different-model-types-in-ember-app-and-api-for-the-same-resource/"/>
    <updated>2018-04-28T19:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/04/28/advanced-ember-data-customization-different-model-types-in-ember-app-and-api-for-the-same-resource</id>
    <content type="html"><![CDATA[<p>A <strong>great advantage</strong> of using <strong>Ember Data</strong> with <strong>JSONAPI-compliant</strong> adapters/serializers is that there is almost nothing extra needed to work with the <strong>data layer</strong> &ndash; just create the models with names matching the types of the resources returned by the <strong>API</strong> and you are good to go! However, sometimes you may need to customize the naming which means that the names of the models in the <strong>Ember application</strong> will be different than the ones expected by the API and their corresponding types. What are the steps required to make it work in <strong>Ember Data</strong>?</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Imagine that the API you work with has two resources: <code>User</code> and <code>Picture</code> and that a User can have many Pictures. However, in the Ember application, you want to have these resources named as <code>Photographer</code> and <code>Photo</code>. Here are the models and relationships between them:</p>

<p>``` js
// app/models/photographer.js
import Model from &lsquo;ember-data/model&rsquo;;
import { hasMany } from &lsquo;ember-data/relationships&rsquo;;</p>

<p>export default Model.extend(MessageSender, {
  photos: hasMany(&lsquo;photo&rsquo;)
});
```</p>

<p>``` js
// app/models/photo.js
import Model from &lsquo;ember-data/model&rsquo;;
import { belongsTo } from &lsquo;ember-data/relationships&rsquo;;</p>

<p>export default Model.extend({
  photographer: belongsTo(&lsquo;photographer&rsquo;)
});
```</p>

<h2>The Solution</h2>

<p>Unfortunately, models' names don&rsquo;t follow the naming expected by the API. There are a couple of things that we need to customize here:</p>

<ol>
<li>Endpoints for a given resource &ndash; by default, for <code>Photographer</code> model, all requests will be performed to <code>/photographers</code> endpoint. We need to make it work with <code>/users</code> endpoint. Same thing with <code>Photo</code> model.</li>
<li>Serialization of the models &ndash; for <code>Photographers</code> we will need to make sure that <code>users</code> type is present in the payload, not <code>photographers</code> and the same thing for <code>pictures</code> vs. <code>photos</code>.</li>
<li>Normalization of the payload from the API &ndash; we need to map <code>user</code> type to <code>photographer</code> and <code>picture</code> type to <code>photo</code>.</li>
<li>Handle the relationship between <code>Photographer</code> and <code>Photo</code> with proper types.</li>
</ol>


<p>Let&rsquo;s handle each case one by one.</p>

<p>The first one is quite straightforward &ndash; we need to adjust adapters for both models. According to the <a href="https://guides.emberjs.com/v3.0.0/models/customizing-adapters/#toc_path-customization">docs</a>, <code>pathForType</code> method is the one that we care about. Since we are just going to change the type, not the actual logic that happens to that type later, we can handle these adjustments the following way:</p>

<p>``` js
// app/adapters/application.js
import DS from &lsquo;ember-data&rsquo;;</p>

<p>export default DS.JSONAPIAdapter.extend();
```</p>

<p>``` js
// app/adapters/photographer.js
import ApplicationAdapter from &lsquo;./application&rsquo;;</p>

<p>export default ApplicationAdapter.extend({
  pathForType() {</p>

<pre><code>return this._super('user');
</code></pre>

<p>  }
});
```</p>

<p>``` js
// app/adapters/photo.js
import ApplicationAdapter from &lsquo;./application&rsquo;;</p>

<p>export default ApplicationAdapter.extend({
  pathForType() {</p>

<pre><code>return this._super('picture');
</code></pre>

<p>  }
});
```</p>

<p>The first part is done. Let&rsquo;s focus now on the serialization. After a bit of research of the docs and the source code, it looks like <code>payloadKeyFromModelName</code> needs to be customized. In this case, we just want to make sure that <code>photographer</code> type is mapped to <code>user</code>, and <code>photo</code> is mapped to <code>picture</code>. As this is arguably a less straightforward change than overriding <code>pathForType</code> in adapters, it might make sense to write some unit tests for that. Fortunately, it&rsquo;s nothing too complex &ndash; just comparing the serialization result with the expected one. Let&rsquo;s write a test for <code>ApplicationSerializer</code>:</p>

<p>``` js
// tests/unit/serializers/application-test.js
import { module, test } from &lsquo;qunit&rsquo;;
import { setupTest } from &lsquo;ember-qunit&rsquo;;
import { run } from &lsquo;@ember/runloop&rsquo;;</p>

<p>module(&lsquo;Unit | Serializer | application&rsquo;, function(hooks) {
  setupTest(hooks);</p>

<p>  module(&lsquo;serialize&rsquo;, function() {</p>

<pre><code>module('photographer', function() {
  test('it is serialized according to remapped naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');

    run(() =&gt; {
      let model = store.createRecord('photographer', {});
      let payload = model.serialize();

      assert.equal(payload.data.type, 'users');
    });
  });
});

module('photo', function() {
  test('it is serialized according to its naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');

    run(() =&gt; {
      let model = store.createRecord('photo', {});
      let payload = model.serialize();

      assert.equal(payload.data.type, 'pictures');
    });
  });
});
</code></pre>

<p>  });
});
```</p>

<p>Since we are interested only in a type remapping, we don&rsquo;t check the entire payload, only <code>type</code> attribute. Let&rsquo;s make these tests pass by either remapping types or using the default logic:</p>

<p>``` js
// app/serializers/application.js
import DS from &lsquo;ember-data&rsquo;;</p>

<p>const keysMappingForSerialization = {
  &lsquo;photographer&rsquo;: &lsquo;user&rsquo;,
  &lsquo;photo&rsquo;: &lsquo;picture&rsquo;
};</p>

<p>export default DS.JSONAPISerializer.extend({
  payloadKeyFromModelName(key) {</p>

<pre><code>if (keysMappingForSerialization[key]) {
  return this._super(keysMappingForSerialization[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>Awesome, we are almost there.</p>

<p>Both third and fourth points are actually about normalization, so we are going to handle them together. Again, after some research, it looks like we need to customize <code>modelNameFromPayloadKey</code> to map types returned by API to corresponding types in our app and also override <code>keyForRelationship</code> method to handle relationships in the payload correctly. Again, let&rsquo;s start with some tests. The simplest way to test such things is checking the result of <a href="https://emberjs.com/api/ember-data/3.0/classes/DS.JSONAPISerializer/methods/normalizeResponse?anchor=normalizeResponse">normalizeResponse</a> for some request type, e.g., for &lsquo;findAll&rsquo;. Let&rsquo;s write a test for a more complex scenario including relationships and sideloading as well:</p>

<p>``` js
// tests/unit/serializers/application-test.js
import { module, test } from &lsquo;qunit&rsquo;;
import { setupTest } from &lsquo;ember-qunit&rsquo;;
import { run } from &lsquo;@ember/runloop&rsquo;;</p>

<p>module(&lsquo;Unit | Serializer | application&rsquo;, function(hooks) {
  setupTest(hooks);</p>

<p>  module(&lsquo;serialize&rsquo;, function() {</p>

<pre><code>// previous tests
</code></pre>

<p>  });</p>

<p>  module(&lsquo;normalizeResponse&rsquo;, function() {</p>

<pre><code>module('photographer', function() {
  test('it is normalized according to remapped naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');
    let serializer = store.serializerFor('photographer');

    run(() =&gt; {
      let payload = {
        'data': {
          'type': 'users',
          'id': '1',
          'attributes': {},
          'relationships': {
            'pictures': {
              'links': {
                'self': 'https://host.test/api/v1/users/1/relationships/pictures',
                'related': 'https://host.test/api/v1/users/1/pictures'
              },
              'data': [{ 'type': 'pictures', 'id': '10' }]
            }
          }
        },
        'included': [
          {
            'type': 'pictures',
            'id': '10',
            'attributes': {},
            'links': {
              'self': 'https://host.test/api/v1/pictures/10'
            }
          }
        ]
      };

      let normalizedPayload = serializer.normalizeResponse(store, store.modelFor('photographer'),
        payload, 1, 'findAll');
      let expectedPayload = {
        'data': {
          'attributes': {},
          'id': '1',
          'relationships': {
            'emails': {
              'data': [
                { 'id': '10', 'type': 'photos' }
              ],
              'links': {
                'self': 'https://host.test/api/v1/users/1/relationships/pictures',
                'related': 'https://host.test/api/v1/users/1/pictures'
              }
            }
          },
          'type': 'photographer'
        },
        'included': [
          {
            'attributes': {},
            'id': '10',
            'relationships': {},
            'type': 'photo'
          }
        ]
      };

      assert.deepEqual(normalizedPayload, expectedPayload);
    });
  });
});

module('photo', function() {
  test('it is normalized according to remapped naming', function(assert) {
    assert.expect(1);

    let store = this.owner.lookup('service:store');
    let serializer = store.serializerFor('photo');

    run(() =&gt; {
      let payload = {
        'data': {
          'type': 'pictures',
          'id': '1',
          'attributes': {},
          'relationships': {
            'user': {
              'links': {
                'self': 'https://host.test/api/v1/pictures/1/relationships/user',
                'related': 'https://host.test/api/v1/pictures/1/user'
              },
              'data': { 'type': 'users', 'id': '10' }
            }
          }
        },
        'included': [
          {
            'type': 'users',
            'id': '10',
            'attributes': {},
            'links': {
              'self': 'https://host.test/api/v1/users/10'
            }
          }
        ]
      };

      let normalizedPayload = serializer.normalizeResponse(store, store.modelFor('photo'),
        payload, 1, 'findAll');
      let expectedPayload = {
        'data': {
          'attributes': {},
          'id': '1',
          'relationships': {
            'photographer': {
              'data': { 'id': '10', 'type': 'photographer' },
              'links': {
                'related': 'https://host.test/api/v1/pictures/1/user',
                'self': 'https://host.test/api/v1/pictures/1/relationships/user'
              }
            }
          },
          'type': 'photo'
        },
        'included': [
          {
            'attributes': {},
            'id': '10',
            'relationships': {},
            'type': 'photographer'
          }
        ]
      };

      assert.deepEqual(normalizedPayload, expectedPayload);
    });
  });
});
</code></pre>

<p>  });
});
```</p>

<p>First, let&rsquo;s make it work with nonrelationship-related part, i.e. <code>modelNameFromPayloadKey</code> customization:</p>

<p>``` js
// app/serializers/application.js
import DS from &lsquo;ember-data&rsquo;;</p>

<p>const keysMappingForSerialization = {
  &lsquo;photographer&rsquo;: &lsquo;user&rsquo;,
  &lsquo;photo&rsquo;: &lsquo;picture&rsquo;
};</p>

<p>const keysMappingForNormalization = {
  &lsquo;users&rsquo;: &lsquo;photographers&rsquo;,
  &lsquo;pictures&rsquo;: &lsquo;photos&rsquo;
};</p>

<p>export default DS.JSONAPISerializer.extend({});
  payloadKeyFromModelName(key) {</p>

<pre><code>if (keysMappingForSerialization[key]) {
  return this._super(keysMappingForSerialization[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  },</p>

<p>  modelNameFromPayloadKey(modelName) {</p>

<pre><code>if (keysMappingForNormalization[modelName]) {
  return this._super(keysMappingForNormalization[modelName]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>Again, the same pattern as before &ndash; for whitelisted types we want to remap them and apply the default logic for the rest of the types.</p>

<p>And to handle the relationships we can customize the serializers separately:</p>

<p>``` js
// app/serializers/photographer.js
import ApplicationSerializer from &lsquo;./application&rsquo;;</p>

<p>const keysForRelationshipsMapping = {
  &lsquo;photographer&rsquo;: &lsquo;user&rsquo;
};</p>

<p>export default ApplicationSerializer.extend({
  keyForRelationship(key) {</p>

<pre><code>if (keysForRelationshipsMapping[key]) {
  return this._super(keysForRelationshipsMapping[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>``` js
// app/serializers/photo.js
import ApplicationSerializer from &lsquo;./application&rsquo;;</p>

<p>const keysForRelationshipsMapping = {
  &lsquo;photo&rsquo;: &lsquo;picture&rsquo;
};</p>

<p>export default ApplicationSerializer.extend({
  keyForRelationship(key) {</p>

<pre><code>if (keysForRelationshipsMapping[key]) {
  return this._super(keysForRelationshipsMapping[key]);
} else {
  return this._super(...arguments);
}
</code></pre>

<p>  }
});
```</p>

<p>And that&rsquo;s it! All our tests are green, and the models are going to work with the API!</p>

<h2>Wrapping Up</h2>

<p>Thanks to a <strong>solid design</strong> of <strong>Ember Data</strong>, it&rsquo;s quite simple to customize the <strong>data layer</strong> which in most cases requires merely overriding a couple of methods.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Tips: Testing Outgoing HTTP Requests]]></title>
    <link href="https://karolgalanciak.com/blog/2017/06/25/ember-tips-testing-outgoing-http-requests/"/>
    <updated>2017-06-25T22:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2017/06/25/ember-tips-testing-outgoing-http-requests</id>
    <content type="html"><![CDATA[<p><strong>Ember.js</strong> is a web frontend framework and it&rsquo;s no surprise that majority of the applications deal with a lot of <strong>HTTP requests</strong>. But such fact has a lot of implications on the process of development of the Ember apps, especially when it comes to <strong>testing</strong>. For basic <code>GET</code> requests which don&rsquo;t include any query params or don&rsquo;t deal with pagination it&rsquo;s quite straight-forward &ndash; for those we just want to fetch some data, so we can check if proper objects are present as a side-effect of these requests. What about <code>POST</code>, <code>PATCH</code> or <code>DELETE</code> requests, where we can&rsquo;t easily test the side effects?</p>

<p>Fortunately, thanks to the awesome tools such as <a href="https://github.com/pretenderjs/pretender" target="_blank">pretender</a> and <a href="https://github.com/samselikoff/ember-cli-mirage" target="_blank">ember-cli-mirage</a>, it&rsquo;s not a big problem.</p>

<!--more-->


<h2>Scenario #1: Testing if the request body sent in the outgoing request is right</h2>

<p>Imagine that you are writing a classic sign-up for users. It would be quite useful to ensure that the right params are indeed sent to the <code>/api/users</code> endpoint (if that&rsquo;s the case).</p>

<p>For dealing with HTTP requests and/or implementing a backend mock, <a href="https://github.com/samselikoff/ember-cli-mirage" target="_blank">ember-cli-mirage</a> addon is a great choice. The setup is beyond the scope of this article, but if you happen to not be familiar with <code>ember-cli-mirage</code>, I highly recommend reading the <a href="http://www.ember-cli-mirage.com" target="_blank">docs</a> which are very clear about the setup and its features.</p>

<p>Let&rsquo;s assume that we have a proper route generated for the signup, let it be a <code>signup</code> route, a corresponding <code>signup</code> controller already handling a logic for the registration in one of its actions and that we have a <code>User</code> model with <code>email</code> and <code>password</code> attributes. Our scenario will be pretty simple: we want to make sure that after filling in <code>email</code> and <code>password</code> fields and clicking the <code>submit</code> button the request will be performed to <code>/api/users</code> with the right params. Here&rsquo;s our test for the signup feature:</p>

<p>``` javascript my-awesome-app/tests/acceptance/sign-up.js
/<em> global server </em>/
import { test } from &lsquo;qunit&rsquo;;
import moduleForAcceptance from &lsquo;book-me/tests/helpers/module-for-acceptance&rsquo;;</p>

<p>moduleForAcceptance(&lsquo;Acceptance | sign up&rsquo;);
test(&lsquo;user can successfully sign up&rsquo;, function(assert) {
  assert.expect(1);</p>

<p>  server.post(&lsquo;/api/users&rsquo;, function(schema)  {</p>

<pre><code>const attributes = this.normalizedRequestAttrs();
const expectedAttributes = {
  email: 'example@email.com',
  password: 'secretpassword'
};

assert.deepEqual(attributes, expectedAttributes, "attributes don't match the expected ones");

return schema.users.create(attributes);
</code></pre>

<p>  });</p>

<p>  visit(&lsquo;/signup&rsquo;);</p>

<p>  andThen(() => {</p>

<pre><code>fillIn('[data-test=signup-email]', "example@email.com");
fillIn('[data-test=signup-password]', 'secretPassword');

click('[data-test=submit-signup]');
</code></pre>

<p>  });
});
```</p>

<p>In this acceptance test we visit the <code>signup</code> page, provide the email and password combo and we click on the submit button. There is only one simple assertion here: comparing the expected attributes against the normalized attributes from the requests to <code>/api/users</code> endpoint &ndash; we use normalized attributes to avoid dealing with JSONAPI format. To achieve that we provide a custom action handler which is very close to the default implementation for <code>POST</code> actions from <code>ember-cli-mirage</code>. The only extra step here is comparing the attributes.</p>

<p>What if we want to just make sure that the request was performed to the given endpoint, but we don&rsquo;t care about the request body?</p>

<h2>Scenario #2 Testing if the request was performed to the given endpoint</h2>

<p>For this scenario imagine that we want to have a feature of deleting some tasks from the to-do list. The simplest way to make sure that the task will be removed would be checking if the <code>DELETE</code> request was performed to <code>/api/tasks/:id</code> endpoint. Again, let&rsquo;s assume that we already have a right implementation for this feature (too bad we didn&rsquo;t practice strict TDD to develop it properly).</p>

<p>For this use case we will do something a bit different than the last time. First, let&rsquo;s add the right config for the <code>ember-cli-mirage</code> to handle CRUD actions for <code>tasks</code> using <code>resource</code> helper:</p>

<p>``` javascript my-awesome-app/mirage/config.js
export default function() {
  this.namespace = &lsquo;api&rsquo;;</p>

<p>  this.resource(&lsquo;users&rsquo;);
}
```</p>

<p>And that&rsquo;s how our test could look like:</p>

<p>``` javascript my-awesome-app/tests/acceptance/delete-task.js
/<em> global server </em>/
import { test } from &lsquo;qunit&rsquo;;
import moduleForAcceptance from &lsquo;book-me/tests/helpers/module-for-acceptance&rsquo;;</p>

<p>moduleForAcceptance(&lsquo;Acceptance | delete task&rsquo;);
test(&lsquo;user can delete tasks&rsquo;, function(assert) {
  assert.expect(1);</p>

<p>  const task = server.create(&lsquo;task&rsquo;);</p>

<p>  visit(&lsquo;/tasks&rsquo;);</p>

<p>  click(&lsquo;[data-test=delete-task]&rsquo;);</p>

<p>  andThen(() => {</p>

<pre><code>const taskUrl = `/api/tasks/${task.id}`;
const deleteTaskRequest = server.pretender.handledRequests.find((request) =&gt; {
  return request.url === taskUrl &amp;&amp; request.method === 'DELETE';
});

assert.ok(deleteTaskRequest, 'delete task request should be performed');
</code></pre>

<p>  });
});
```</p>

<p>Again, our test has a very simple structure: we visit the <code>tasks</code> route where all the tasks are displayed and delete the one we created in the test&rsquo;s setup. To make sure that the request was performed to the right endpoint we take advantage of the fact that <code>ember-cli-mirage</code> uses <code>pretender</code> under the hood which keeps track of all handled requests in <code>handledRequests</code> property. Thanks to this feature, we can identify our request based on the <strong>URL</strong> and the <strong>request method</strong>.</p>

<h2>Wrapping Up</h2>

<p>Testing <strong>outgoing requests</strong> in Ember might not be the most obvious thing to do. Fortunately, thanks to <a href="https://github.com/pretenderjs/pretender" target="_blank">pretender</a> and <a href="https://github.com/samselikoff/ember-cli-mirage" target="_blank">ember-cli-mirage</a>, we can easily verify both the <strong>URLs</strong> of the endpoints where the requests were performed to and the <strong>request body</strong> that was sent with the request.</p>

<p>P.S. I&rsquo;ve just started <strong>writing a book</strong> about <strong>test-driving Ember</strong> applications. If you found this article useful, you are going to love it :). <strong>Subscribe</strong> to my newsletter to get updates and promotion code once it&rsquo;s released.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Tips: Managing Timeouts And Delays]]></title>
    <link href="https://karolgalanciak.com/blog/2017/04/30/ember-quick-tips-managing-timeouts-and-delays/"/>
    <updated>2017-04-30T22:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2017/04/30/ember-quick-tips-managing-timeouts-and-delays</id>
    <content type="html"><![CDATA[<p><strong>Timeouts</strong> and <strong>delays</strong> are quite extensively used in many applications when deferring execution of some action via <code>Ember.run.later</code> or debouncing via <code>Ember.run.debounce</code>. Having small amounts of tests executing such methods might not be a problem initially, but obviously, as the application grows, this can easily lead to <strong>slow test suite</strong> which takes minutes to finish due to the waiting for all the timeouts and delays in many places. Let&rsquo;s try to find the best solution to solve this problem.</p>

<!--more-->


<h2>Anatomy of The Problem</h2>

<p>Imagine you are implementing a todo-list and want to add a <strong>destroy item feature</strong>. The obvious solution would be adding a button which would trigger some <code>destroy</code> action once a user clicks it. But the problem with such solution is that it doesn&rsquo;t offer the best <strong>UX</strong> as a user could easily destroy items <strong>by accident</strong>. A nicer way for such use cases is making a user hold the button for a certain period of time and only after this <strong>delay</strong> would the action be invoked, otherwise it won&rsquo;t be executed.</p>

<p>A great news is that there is already an addon solving such problem: <a href="https://www.npmjs.com/package/ember-hold-button" target="_blank">ember-hold-button</a>. Let&rsquo;s create a very simple component handling the logic of displaying the item and deleting it after holding a button for 3 seconds using <code>ember-hold-button</code>:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
{{#hold-button type="rectangle" action="destroy" delay=3000 data-test="destroy-item-btn"}}
  Destroy
{{/hold-button}}
</code>
</p>

<p>Ok, cool, so the feature is done. What about integrations tests verifying that this feature works? Currently, it would take at least 3 seconds due to the waiting time + the runtime of the test itself, which is definitely too slow.</p>

<h2>Solving The Problem</h2>

<p>One way to fix this problem would be moving <code>delay</code> to computed property which would be configurable and by default make it equal to 3 seconds. The component would look like this in such case:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  destroyActionDelay: 3000,</p>

<p>  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
{{#hold-button type="rectangle" action="destroy" delay=destroyActionDelay data-test="destroy-item-btn"}}
  Destroy
{{/hold-button}}
</code>
</p>

<p>To make integration tests fast, we would simply override the default value of <code>destroyActionDelay</code> and render the component in the test the following way:</p>

<p>
``` javascript tests/integration/components/display-todo-item-test.js
// the rest of the tests</p>

<p>this.render(hbs<code>{{display-todo-item item=item destroyActionDelay=0}}</code>);</p>

<p>// the rest of the tests
```
</p>

<p>This surely solves the problem for <strong>integration tests</strong>, but what about the <strong>acceptance ones</strong>? It would still take at least 3 seconds of waiting for this delay.</p>

<p>For this purpose we could add a special function which would return the value for the delay <strong>based on the environment</strong>. For <strong>non-test</strong> we may want to return a provided value and for test environment some other value, which by default would be equal to 0 to make the tests fast. Let&rsquo;s add such a utility function and call it <code>timeoutForEnv</code>:</p>

<p>``` javascript my-app/app/utils/timeout-for-env.js
import config from &lsquo;my-app/config/environment&rsquo;;</p>

<p>export default function timeoutForEnv(timeout, timeoutForTestEnv = 0) {
  if (config.environment === &lsquo;test&rsquo;) {</p>

<pre><code>return timeoutForTestEnv;
</code></pre>

<p>  } else {</p>

<pre><code>return timeout;
</code></pre>

<p>  }
}
```</p>

<p>And update the component:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;
import timeoutForEnv from &lsquo;my-app/utils/timeout-for-env&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  destroyActionDelay: timeoutForEnv(3000),</p>

<p>  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>If we wanted for some reason to have a delay different than <code>0</code> for the test env, we could simply provide the value of the second argument:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;
import timeoutForEnv from &lsquo;my-app/utils/timeout-for-env&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  destroyActionDelay: timeoutForEnv(3000, 1000),</p>

<p>  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>And that&rsquo;s it! It will work for both integration and acceptance tests.</p>

<h2>Wrapping Up</h2>

<p>Using a lot of <strong>timeouts</strong> and <strong>delays</strong> without special adjustments for tests can easily lead to a very <strong>slow test suite</strong> as the application grows. Fortunately, it&rsquo;s quite easy so solve such a problem by using <strong>environment-dependent</strong> config and setting the values to <code>0</code> for tests.</p>

<p>P.S. I&rsquo;ve just started <strong>writing a book</strong> about <strong>test-driving Ember</strong> applications. If you found this article useful, you are going to love it :). <strong>Subscribe</strong> to my newsletter to get updates and promotion code once it&rsquo;s released.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Driven Ember - Testing Holding a Button]]></title>
    <link href="https://karolgalanciak.com/blog/2017/03/26/test-driven-ember-testing-holding-button/"/>
    <updated>2017-03-26T23:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2017/03/26/test-driven-ember-testing-holding-button</id>
    <content type="html"><![CDATA[<p>Thanks to the awesome tools in <strong>Ember ecosystem</strong> such as <a href="http://github.com/samselikoff/ember-cli-mirage/" target="_blank">ember-cli-mirage</a>, <a href="https://github.com/emberjs/ember-test-helpers" target="_blank">ember-qunit</a> or <a href="https://github.com/emberjs/ember-test-helpers" target"_blank">ember-test-helpers</a> writing majority of the tests is pretty straight-forward. Nevertheless, there are quite a few cases where <strong>simulating user&rsquo;s interaction</strong> is not that simple. An example of such use case would be <strong>holding a button</strong> for particular period of time triggering some side effect.</p>

<!--more-->


<h2>Anatomy of The Problem</h2>

<p>Imagine you are implementing a feature of destroying some records in your application, e.g. the todo items from the list. It would be a bit unfortunate to destroy any item if a user <strong>accidentally clicked</strong> on the destroy button, so it might be a good idea to somehow make it harder to execute such an action. A simple approach would be displaying some alert <strong>asking user to confirm</strong> whether this item should be removed or not. This approach would get our job done, but it doesn&rsquo;t offer the best <strong>UX</strong>. What are the better options here?</p>

<p>A pretty cool solution to this problem would be making user <strong>hold a delete button</strong> for a particular period of time, e.g. for 3 seconds. Holding this button for less than 3 seconds wouldn&rsquo;t destroy the item, so it would be impossible to accidentally delete anything.</p>

<p>There is an addon which solves exactly this problem: <a href="https://www.npmjs.com/package/ember-hold-button" target="_blank">ember-hold-button</a>, so there is no need to reinvent the wheel. Let&rsquo;s add this to our application.</p>

<h2>Adding Destroy Action</h2>

<p>Let&rsquo;s start by installing <code>ember-hold-button</code> addon:</p>

<p><code>
ember install ember-hold-button
</code></p>

<p>and assume that we already have some component for displaying a single item with <code>destroy</code> action:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
&lt;button {{action "destroy"}} data-test="destroy-item-btn"&gt;Destroy&lt;/button&gt;
</code>
</p>

<p>and that the component was test-driven with the following test written before the actual implementation (TDD for FTW!):</p>

<p>
``` javascript tests/integration/components/display-todo-item-test.js
import Ember from &lsquo;ember&rsquo;;
import { moduleForComponent, test } from &lsquo;ember-qunit&rsquo;;
import hbs from &lsquo;htmlbars-inline-precompile&rsquo;;</p>

<p>const {
  set,
  RSVP,
} = Ember;</p>

<p>moduleForComponent(&lsquo;display-todo-item&rsquo;, &lsquo;Integration | Component | display todo item&rsquo;, {
  integration: true
});</p>

<p>test(&lsquo;item can be destroyed&rsquo;, function(assert) {
  assert.expect(1);</p>

<p>  const {</p>

<pre><code>$,
</code></pre>

<p>  } = this;</p>

<p>  const item = Ember.Object.extend({</p>

<pre><code>destroyRecord() {
  assert.ok(true, 'item should be destoyed');

  return RSVP.resolve(this);
},
</code></pre>

<p>  });</p>

<p>  set(this, &lsquo;item&rsquo;, item);</p>

<p>  this.render(hbs<code>{{display-todo-item item=item}}</code>);</p>

<p>  const $destroyBtn = $(&lsquo;[data-test=destroy-item-btn]&rsquo;);</p>

<p>  $destroyBtn.click();
});
```
</p>

<p>Basically this test verifies that the <code>destroyRecord</code> method will be called on item after clicking the button.</p>

<p>Let&rsquo;s add <code>hold-button</code> which will trigger <code>destroy</code> action after holding it for 3 seconds:</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
{{#hold-button type="rectangle" action="destroy" delay=3000 data-test="destroy-item-btn"}}
  Destroy
{{/hold-button}}
</code>
</p>

<p><code>delay</code> option will get the job done here to make it holdable for 3 seconds to trigger <code>destroy</code> action.</p>

<p>The button is working great, but our test obviously is failing now! How can we simulate holding action in our integration tests?</p>

<h2>Testing Holding Interaction</h2>

<p>To solve that problem we should break the problem down into the single events. On desktop, pressing a button simply means triggering <code>mouseDown</code> event and releasing means trigger <code>mouseUp</code> event. On mobile that would be <code>touchStart</code> and <code>touchEnd</code> events accordingly.</p>

<p>Based on how <code>hold-button</code> component works, we may suspect that there is some internal timer which starts counting time after triggering <code>mouseDown</code> (<code>touchStart</code>) event or a scheduler which executes the action if it was held for required period of time and cancels it if it was released before that period of time, which would mean cancelling timer on <code>mouseUp</code> event.</p>

<p>After checking <a href="https://github.com/AddJam/ember-hold-button/blob/master/addon/components/hold-button.js" target="_blank">the internals</a>, it turns out this is exactly the case! Let&rsquo;s rewrite our test by triggering these events. We will also need two extra things as we are dealing with asynchronous actions:</p>

<ul>
<li><p><code>async()</code> / <code>done()</code> &ndash; To make sure QUnit will wait for an asynchronous operation to be finished we need to use <code>async()</code> function. That way QUnit will wait until <code>done()</code> is called. We will call <code>done()</code> after triggering <code>mouseUp</code> event. But we also need to wait until the action is executed. We will need <code>wait()</code> helper for that.</p></li>
<li><p><code>wait()</code> &ndash; it forces run loop to process all the pending events. That way we ensure that the asynchronous operation have been executed (like calling <code>destroy</code> action after 3 seconds).</p></li>
</ul>


<p>Here&rsquo;s our new test:</p>

<p>
``` javascript tests/integration/components/display-todo-item-test.js
import Ember from &lsquo;ember&rsquo;;
import { moduleForComponent, test } from &lsquo;ember-qunit&rsquo;;
import hbs from &lsquo;htmlbars-inline-precompile&rsquo;;
import wait from &lsquo;ember-test-helpers/wait&rsquo;;</p>

<p>const {
  set,
  RSVP,
} = Ember;</p>

<p>moduleForComponent(&lsquo;display-todo-item&rsquo;, &lsquo;Integration | Component | display todo item&rsquo;, {
  integration: true
});</p>

<p>test(&lsquo;item can be destroyed&rsquo;, function (assert) {
  assert.expect(1);</p>

<p>  const {</p>

<pre><code>$,
</code></pre>

<p>  } = this;</p>

<p>  const item = Ember.Object.extend({</p>

<pre><code>destroyRecord() {
  assert.ok(true, 'item should be destoyed');

  return RSVP.resolve(this);
},
</code></pre>

<p>  });</p>

<p>  set(this, &lsquo;item&rsquo;, item);</p>

<p>  this.render(hbs<code>{{display-todo-item item=item}}</code>);</p>

<p>  const $destroyBtn = $(&lsquo;[data-test=destroy-item-btn]&rsquo;);</p>

<p>  $destroyBtn.mousedown();</p>

<p>  wait().then(() => {</p>

<pre><code>$destroyBtn.mouseup();
done();
</code></pre>

<p>  });
});
```
</p>

<p>Nice! Our test is passing again. However, there is one serious problem: this test is quite slow as it waits 3 second for the action to finish. Can we make it somehow faster?</p>

<h2>Making Our Test Faster</h2>

<p>The answer is: yes. We just need to provide a way to make <code>delay</code> configurable from the outside. This can be simply done by introducing <code>destroyActionDelay</code> property with default value equal <code>3000</code> and allowing it to be modified. Let&rsquo;s start with applying this little change to the test:</p>

<p>
<code>javascript tests/integration/components/display-todo-item-test.js
// the rest of the tests
this.render(hbs`{{display-todo-item item=item destroyActionDelay=0}}`);
</code>
</p>

<p>We don&rsquo;t care about waiting for 3 seconds in the tests, we just want to test if it works and to make it fast. <code>0</code> sounds like the most reasonable value in such case.</p>

<p>And let&rsquo;s change few things in our component:</p>

<p>``` javascript app/components/display-todo-item.js
import Ember from &lsquo;ember&rsquo;;</p>

<p>const {
  get,
} = Ember;</p>

<p>export default Ember.Component.extend({
  destroyActionDelay: 3000,</p>

<p>  actions: {</p>

<pre><code>destroy() {
  const item = get(this, 'item');

  item.destroyRecord();
},
</code></pre>

<p>  },
});
```</p>

<p>
<code>html app/templates/components/display-todo-item.hbs
{{item.name}}
{{#hold-button type="rectangle" action="destroy" delay=destroyActionDelay data-test="destroy-item-btn"}}
  Destroy
{{/hold-button}}
</code>
</p>

<p>And that&rsquo;s it! You can now enjoy the much faster test suite!</p>

<h2>Wrapping Up</h2>

<p>Testing holding a button for particular period of time doesn&rsquo;t sound like an obvious thing to do. Fortunately, with proper design and understanding the interaction from the <strong>browser&rsquo;s perspective</strong>, it isn&rsquo;t that hard to do and doesn&rsquo;t necessarily make your tests slower.</p>

<p>P.S. I&rsquo;ve just started <strong>writing a book</strong> about <strong>test-driving Ember</strong> applications. If you found this article useful, you are going to love it :). <strong>Subscribe</strong> to my newsletter to get updates and promotion code once it&rsquo;s released.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember Tips: Computed Properties And Arrow Functions? Not A Good Idea]]></title>
    <link href="https://karolgalanciak.com/blog/2016/12/11/ember-tips-computed-properties-and-arrow-functions-not-a-good-idea/"/>
    <updated>2016-12-11T22:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2016/12/11/ember-tips-computed-properties-and-arrow-functions-not-a-good-idea</id>
    <content type="html"><![CDATA[<p><strong>Arrow function expressions</strong> were definitely a great addition in ES6 and thanks to tools like <a href="https://babeljs.io" target="_blank">babel</a> the new syntax has been quite widely adopted. Besides more concise syntax, an interesting thing about <strong>arrow function expressions</strong> is that they preserve the context, i.e. they don't define their own <code>this</code>, which was sometimes annoying and resulted in assigning <code>that</code> or <code>self</code> variables to keep the outer context that could be referred inside functions. As great as it sounds, <strong>arrow function expressions</strong> cannot be used in all cases. One example would be <strong>Ember computed properties</strong>.</p>




<!--more-->




<h2>Arrow Function Expressions - A Quick Introduction</h2>




<p>Let's start with a quick introduction to arrow functions. Before ES6, anytime we were using <strong>function expressions</strong> and wanted to refer <code>this</code> from outer context, we had to do some workarounds which are (arguably) a bit unnatural, especially comparing to other major programming languages.</p>




<p>Let's do some pseudo-object-oriented programming with JavaScript (ES5) to illustrate a possible issue with <strong>function expressions</strong>:</p>


<p>``` js
function Order() {
  this.id = Math.floor((Math.random() * 10000000) + 1); // don&rsquo;t do it in a production code ;)
  this.items = [];
}</p>

<p>Order.prototype.addItem = function(item) {
  this.items.push(item);
}</p>

<p>Order.prototype.logItems = function() {
  this.items.forEach(function(item) {</p>

<pre><code>console.log("item description: " + item.description + " for order with id: " + this.id);
</code></pre>

<p>  });
}</p>

<p>var order = new Order();
order.addItem({ description: &lsquo;Glimmer 2 rockzzz&rsquo; });
order.logItems();  // whooops
```</p>

<p>We have a simple class-like functionality using <strong>constructor function</strong> and <strong>prototype</strong> to implement <code>Order</code> with some questionable ( ;) ) way of assigning id and some <code>items</code>. We can add more items with <code>Order.prototype.addItem</code> function and we can log them with <code>Order.prototype.logItems</code> function.</p>




<p>But there's a problem: <code>logItems</code> function doesn't log <code>id</code>, but logs <code>undefined</code> instead. Why is that?</p>




<p><strong>Function expressions</strong> create their own context and define own <code>this</code>, so it no longer refers to the outer context, which is the <code>order</code> instance. There are several ways to solve this problem.</p>




<p>The most obvious is to assign outer <code>this</code> to some other variable, like <code>that</code> or <code>self</code>:</p>


<p>``` js
Order.prototype.logItems = function() {
  var self = this;
  this.items.forEach(function(item) {</p>

<pre><code>console.log("item description: " + item.description + " for order with id: " + self.id);
</code></pre>

<p>  });
}
```</p>

<p>You can also pass outer <code>this</code> as a second argument to <code>forEach</code> function:</p>


<p>``` js
Order.prototype.logItems = function() {
  this.items.forEach(function(item) {</p>

<pre><code>console.log("item description: " + item.description + " for order with id: " + this.id);
</code></pre>

<p>  }, this);
}
```</p>

<p>You can even explicitly <code>bind</code> outer <code>this</code> to callback argument inside <code>forEach</code> function:</p>


<p>``` js
Order.prototype.logItems = function() {
  this.items.forEach(function(item) {</p>

<pre><code>console.log("item description: " + item.description + " for order with id: " + this.id);
</code></pre>

<p>  }.bind(this));
}
```</p>

<p>All these solutions work, but aren't really that clean. Fortunately, since ES6, we can use <code>arrow function expressions</code> which preserve outer context and don't define own <code>this</code>. After little refactoring <code>Order.prototype.logItems</code> could look like this:</p>


<p>``` js
Order.prototype.logItems = function() {
  this.items.forEach((item) => {</p>

<pre><code>console.log("item description: " + item.description + " for order with id: " + this.id);
</code></pre>

<p>  });
}
```</p>

<p>Much Better!</p>




<p>As great as it looks like, it may not be a good idea to apply <strong>arrow function expressions</strong> everywhere, especially for <strong>Ember computed properties</strong>.</p>




<h2>Ember Computed Properties And Arrow Functions? - Not A Good Idea</h2>




<p>Recently I was doing some refactoring in one Ember app. The syntax in one of the models was a bit mixed and there were some <strong>function expressions</strong> and <strong>arrow function expressions</strong> which looked a bit like this:</p>


<p>``` js app/models/user.js
import Ember from &ldquo;ember&rdquo;;
import Model from &lsquo;ember-data/model&rsquo;;</p>

<p>export default Model.extend({
  fullname: Ember.computed(&lsquo;firstname&rsquo;, &lsquo;lastname&rsquo;, function() {</p>

<pre><code>return `${this.get('firstName')} ${this.get('lastName')}`;
</code></pre>

<p>  }),</p>

<p>  doThis: function() {</p>

<pre><code>// some logic goes here
</code></pre>

<p>  },</p>

<p>  doThat: function() {</p>

<pre><code>// even more logic
</code></pre>

<p>  },</p>

<p>  doYetAnotherThing(args) {</p>

<pre><code>// more logic
</code></pre>

<p>  }
});
```</p>

<p>So I decided ES6-ify entire syntax here and ended up with the following code:</p>


<p>``` js app/models/user.js
import Ember from &ldquo;ember&rdquo;;
import Model from &lsquo;ember-data/model&rsquo;;</p>

<p>export default Model.extend({
  fullname: Ember.computed(&lsquo;firstname&rsquo;, &lsquo;lastname&rsquo;, () => {</p>

<pre><code>return `${this.get('firstName')} ${this.get('lastName')}`;
</code></pre>

<p>  }),</p>

<p>  doThis() {</p>

<pre><code>// some logic goes here
</code></pre>

<p>  },</p>

<p>  doThat() {</p>

<pre><code>// even more logic
</code></pre>

<p>  },</p>

<p>  doYetAnotherThing(args) {</p>

<pre><code>// more logic
</code></pre>

<p>  }
});
```</p>

<p>And how did this refactoring end up? Well, instead of a proper <code>fullName</code> I was getting <code>undefined undefined</code>! That was surprising, but then I looked at the changes and saw that I'm using <strong>arrow function expressions</strong> in computed properties and referring there to <code>this</code>, which won't obviously work for the reasons mentioned before. So what are the options for computed properties?</p>




<p>The first one would be to simply use good ol' <strong>function expressions</strong>:</p>


<p>``` js app/models/user.js
import Ember from &ldquo;ember&rdquo;;
import Model from &lsquo;ember-data/model&rsquo;;</p>

<p>export default Model.extend({
  fullname: Ember.computed(&lsquo;firstname&rsquo;, &lsquo;lastname&rsquo;, function() {</p>

<pre><code>return `${this.get('firstName')} ${this.get('lastName')}`;
</code></pre>

<p>  })
});
```</p>

<p>But if you don't really like it, you may define <strong>explicit getter</strong>:</p>


<p>``` js app/models/user.js
import Ember from &ldquo;ember&rdquo;;
import Model from &lsquo;ember-data/model&rsquo;;</p>

<p>export default Model.extend({
  fullname: Ember.computed(&lsquo;firstname&rsquo;, &lsquo;lastname&rsquo;, {</p>

<pre><code>get() {
  return `${this.get('firstName')} ${this.get('lastName')}`;
}
</code></pre>

<p>  })
});
```</p>

<p>And the last option, my preferred one: unleashing the power of <a href="https://karolgalanciak.com/blog/2015/12/02/ember-and-es7-decorators/" target="_blank">ES7 decorators</a> and using <a href="https://github.com/rwjblue/ember-computed-decorators" target="_blank">ember-computed-decorators</a> addon. That way we could define <code>fullName</code> computed property in the following way:</p>


<p>``` js app/models/user.js
import Ember from &ldquo;ember&rdquo;;
import Model from &lsquo;ember-data/model&rsquo;;
import computed from &lsquo;ember-computed-decorators&rsquo;;</p>

<p>export default Model.extend({
  @computed(&lsquo;firstName&rsquo;, &lsquo;lastName&rsquo;)
  fullname(firstName, lastName) {</p>

<pre><code>return `${firstName} ${lastName}`;
</code></pre>

<p>  }
});
```</p>

<p>which looks just beautiful ;).</p>




<h2>Wrapping Up</h2>




<p>Even though <strong>arrow function expressions</strong> are very convenient to use, they can't be used interchangeably with <strong>function expressions</strong>. Sometimes you may not want <code>this</code> inside a function to preserve outer context, which is exactly the case with <strong>Ember computed properties</strong>.</p>

]]></content>
  </entry>
  
</feed>
