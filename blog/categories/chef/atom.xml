<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chef | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/chef/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2019-02-24T22:10:12+01:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automate to the max: instant Ubuntu Server setup with Chef]]></title>
    <link href="https://karolgalanciak.com/blog/2014/07/10/automate-to-the-max-instant-ubuntu-server-setup-with-chef/"/>
    <updated>2014-07-10T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2014/07/10/automate-to-the-max-instant-ubuntu-server-setup-with-chef</id>
    <content type="html"><![CDATA[<p>You've started developing new app and need server to deploy it. You can choose hosting platform like <a href="https://www.heroku.com" target="_blank">Heroku</a> or <a href="https://shellycloud.com" target="_blank">Shelly</a> which may turn out to be quite expensive if you want to host multiple apps. You can also set up your own server. Going with the latter option can be quite time consuming, especially if sysadministration is not you main responsibility and you have multiple servers to provision. I that case automation beyond simple Bash scripts is a must - time to meet <strong>Chef</strong>.</p>




<!--more-->




<h2>What is Chef?</h2>


<p>Chef is the automation framework which uses Ruby DSL and helps provisioning new servers by automating the whole process. We are going to concentrate on Chef Solo where we set up all roles (like PostgreSQL server) on local machine and use them on our server, contrary to Chef Server which is a hub for configuration data that is automatically applied to all nodes (servers) connected with central server, quite useful when you need to manage serious amount of servers.</p>




<p>We will also be using some other utilities - <strong>Knife</strong> (solo) which is a command line utility helpings us interact with server and <strong>Berkshelf</strong> - a bundler-like utility for Chef recipes.</p>




<p><p>I&rsquo;m not going to write another tutorial explaining every possible detail of entire Chef DSL. The <a href="http://docs.opscode.com" target="_blank">documentation</a> is pretty good and there are also plenty of other resources you can learn from. I&rsquo;d rather like to explain the most important terms, show basic configuration, demonstrate how to write very simple recipe and at the end I am going to introduce my own cookbook that I use for servers' setup with <strong>Ubuntu Server 14.04</strong>. Why Ubuntu? Well, sysadministration is not my main responsibility and it&rsquo;s much easier to find solutions (or Chef cookbooks) for Ubuntu than any other distribution.</p>

<p><p>After reading this post you should be able to setup every server instantly and have some basic understanding of what&rsquo;s going on.</p></p>

<p><h2>Why use Chef?</h2></p>

<p><p>You may wonder what are the benefits of using Chef over the Bash scripts. Firstly, Chef provides extremely expressive DSL, just take a look at the code below:</p></p>

<p><code>ruby
template "/etc/nginx/nginx.conf" do
  owner "root"
  group "root"
  mode "0644"
  source "nginx.conf.erb"
end
</code>
<p>You can have some general idea what it does, even if you don&rsquo;t know Chef. That way it&rsquo;s quite easy to find reusable recipes that you can customize to your requirements and write your own solutions.</p></p>

<p><p>Another huge benefit is <strong>idempotence</strong> &ndash; you can apply the same recipes multiple times on your server and the state of the server will be exactly the same as after running them for the first time. If you change something in eg. configuration files, only these changes will be applied. Try achieving the same using shell scripts only ;).</p></p>

<p><p>Once you understand Chef, provisioning new servers will be extremely easy and fast &ndash; it can be even limited to 2 commands if you use the same configuration for all servers.</p></p>

<p><h2>Chef basics</h2></p>

<p><h3>Terminology</h3></p>

<p><p><strong>Node</strong></p></p>

<p><p>A server (machine) we are going to set up and run Chef on.</p></p>

<p><p><strong>Recipe</strong></p></p>

<p><p>Basic unit in Chef for installing one thing, like PostgreSQL, ImageMagick, etc.</p></p>

<p><p><strong>Cookbook</strong></p></p>

<p><p>Collection of recipes, e.g. PostgreSQL cookbook.</p></p>

<p><p><strong>Role</strong></p></p>

<p><p>Combination of recipes that fulfill specific &ldquo;feature&rdquo; (or role) &ndash; PostgreSQL server role ,besides Postgres itself, may also require Monit configuration</p></p>

<p><p><strong>Data bags</strong></p></p>

<p><p>Files with data that may be required by some recipes, e.g. ssh keys that will be added to the authorized keys for deploy user.</p></p>

<p><h3>Getting started</h3></p>

<p><p>Let&rsquo;s start with creating directory for really simple chef recipe:</p></p>

<p><code>
mkdir chef-simple-recipe
cd chef-simple-recipe
</code></p>

<p><p>and create Gemfile with chef, knife-solo and berkshelf gems:</p></p>

<p>``` ruby
source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;</p>

<p>gem &lsquo;knife-solo&rsquo;
gem &lsquo;chef&rsquo;
gem &lsquo;berkshelf&rsquo;
```</p>

<p><p>Now we can initialize our project using Knife utility:</p></p>

<p><code>
knife solo init .
</code></p>

<p><p>You should be familiar with the generated directory structure after going through <em>terminology</em> part. You may wonder what&rsquo;s the difference between cookbooks and site-cookbooks directory: cookbooks is for storing, well, cookbooks, installed by Berkshelf and site-cookbooks is for our own cookbooks.</p></p>

<p><p>Berskfile resembles closely Gemfile: to add new cookbooks just specify the name of cookbook:</p></p>

<p>```
site :opscode</p>

<p>cookbook &lsquo;build-essential&rsquo;
```</p>

<p><p>In most cases I also specify git repository to have a quick reference to the cookbook:</p></p>

<p>```
site :opscode</p>

<p>cookbook &lsquo;build-essential&rsquo;, git: &lsquo;<a href="https://github.com/opscode-cookbooks/build-essential">https://github.com/opscode-cookbooks/build-essential</a>
```</p>

<p><p>To install all recipes use Berkshelf:</p></p>

<p><code>
berks install
</code></p>

<p><p>If you want cookbooks to be extracted to <code>cookbooks</code> directory:</p></p>

<p><code>
berks install --path cookbooks
</code></p>

<p><h3>Writing first Chef role &ndash; Nginx server</h3></p>

<p><p>To understand the general idea behind Chef we are going to write pretty simple role for Nginx. It will take care of installing Nginx with some specified attributes in configuration file and setup monitoring with Monit. We also need to check if everything works. Fortunately, we don&rsquo;t need real server, <a href="http://www.vagrantup.com" target="_blank">Vagrant</a> will be perfect to set up a virtual environment. Just download it and follow the instructions below:</p></p>

<p><p>Firstly, let&rsquo;s create directory for our server:</p></p>

<p><code>bash
mkdir ubuntu-server-14-04
cd ubuntu-server-14-04
</code></p>

<p><p>and install Ubuntu Server 14-04:</p></p>

<p><code>bash
vagrant init ubuntu-server-14-04 https://cloud-images.ubuntu.com/vagrant/trusty/current/trusty-server-cloudimg-amd64-vagrant-disk1.box
</code></p>

<p><p>As you can see, the <code>Vagrantfile</code> was created. You may check it out but it&rsquo;s not necessary.</p></p>

<p><p>To run Vagrant:</p></p>

<p><code>
vagrant up
</code></p>

<p><p>To check if everything works, ssh on the virtual machine with Ubuntu Server:</p></p>

<p><code>
vagrant ssh
</code></p>

<p><p>Now we have our node, let&rsquo;s prepare it for running Chef (the command below must be run within main Chef project directory):</p></p>

<p><code>
knife solo prepare vagrant@127.0.0.1 -p 2222 -i ~/.vagrant.d/insecure_private_key
</code></p>

<p><p>Remember to use real system user name.</p></p>

<p><p>Our virtual node can now run the Chef client. The command above has also generated <b>nodes/127.0.0.1.json</b> configuration file. Let&rsquo;s investigate the content: <code>run_list</code> is a list of all roles and recipes that will be applied on the node. You can add new roles/recipes just by specifying the name but it may be a good idea to be more explicit and specify whether it&rsquo;s a role or a recipe to avoid name collisions. In our case it will be:</p></p>

<p>```
{
  &ldquo;run_list&rdquo;: [</p>

<pre><code>"role[nginx]"
</code></pre>

<p>  ],
  &ldquo;automatic&rdquo;: {</p>

<pre><code>"ipaddress": "127.0.0.1"
</code></pre>

<p>  }
}
```
<p>Note: If you want to play a bit with the entire configuration discussed in this blog post, you may check it out <a href="https://github.com/Azdaroth/conf-chef-nginx-monit" target="_blank">here</a>.</p></p>

<p><p>Let&rsquo;s create our nginx role:</p></p>

<p><code>
touch roles/nginx.json
</code></p>

<p><p>Here&rsquo;s a basic template for roles:</p></p>

<p><code>json
{
  "name": "nginx",
  "description": "Nginx server with Monit configuration",
  "default_attributes": {},
  "json_class": "Chef::Role",
  "run_list": [],
  "chef_type": "role"
}
</code></p>

<p><p>The content is pretty self-explanatory: We need to specify name of the role and mark it to be role, so we use <code>Chef::Role</code> <code>json_class</code> and <code>role</code> as a <code>chef_type</code>. We can also provide some description. And what&rsquo;s the <code>default_attributes</code>? We will put there any configuration related parameters, once we set up basic template, you will know how it works.</p></p>

<p><p>Let&rsquo;s create our custom cookbook for Nginx in site-cookbooks directory. It will consist of:</p></p>

<p><ul>
  <li>metadata.rb file &ndash; where we can specify some details like dependencies, supported operating systems, author of the cookbook etc.</li>
  <li>recipes directory &ndash; with default.rb file which will contain all the commands that need to be executed to install Nginx.</li>
  <li>templates directory &ndash; place for configuration files etc., we will put nginx.conf.erb template in <code>default</code> subdirectory.</li>
</ul></p>

<p><p>Why <code>default.rb</code> file name? You can write multiple recipes and specify their names, e.g. <code>monit-configuration::postgres</code>, <code>monit-configuration::nginx</code> but in our case we need just one recipe so the <code>default.rb</code> will be sufficient. Using <code>nginx::default</code> and <code>nginx</code> won&rsquo;t make any difference in this case. The same applies to the template files, that&rsquo;s why <code>nginx.conf.erb</code> is located in <code>templates/default/nginx.conf.erb</code>, not <code>templates/nginx.conf.erb</code></p></p>

<p><p>Out metadata.rb can look like that:</p></p>

<p>``` ruby site-cookbooks/nginx/metadata.rb
name              &ldquo;Nginx&rdquo;
maintainer        &ldquo;Karol Galanciak&rdquo;
maintainer_email  &ldquo;<a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x6b;&#97;&#114;&#111;&#108;&#x2e;&#103;&#x61;&#x6c;&#x61;&#110;&#x63;&#105;&#x61;&#x6b;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#x6b;&#x61;&#x72;&#x6f;&#108;&#x2e;&#103;&#97;&#108;&#97;&#110;&#x63;&#105;&#x61;&#107;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a>&rdquo;
description       &ldquo;Installs Nginx&rdquo;
version           &ldquo;0.0.1&rdquo;</p>

<p>recipe &ldquo;nginx&rdquo;, &ldquo;Installs Nginx&rdquo;</p>

<p>supports &ldquo;ubuntu&rdquo;
```</p>

<p><p>What about the configuration file? We need some basic template and decide which attributes will be hardcoded and where we want to have an ability to customize them within our roles. Here&rsquo;s an example, based on <a href="https://library.linode.com/web-servers/nginx/configuration/basic" target="_blank">that one</a>:</p></p>

<p>```
user www-data;
worker_processes 4;</p>

<p>pid /var/run/nginx.pid;</p>

<p>events {
  worker_connections 768;
}</p>

<p>http {</p>

<p>  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  server_names_hash_bucket_size  64;</p>

<p>  include /etc/nginx/mime.types;
  default_type application/octet-stream;</p>

<p>  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;</p>

<p>  gzip on;
  gzip_disable &ldquo;msie6&rdquo;;</p>

<p>  include /etc/nginx/conf.d/<em>.conf;
  include /etc/nginx/sites-enabled/</em>;
}
```</p>

<p><p>Just to keep it as simple as possible let&rsquo;s assume that we will want only <code>user</code> and <code>worker_processes</code> attributes to be customizable and <code>www-data</code> user will be our default with 4 worker processes. We can achieve that using <strong>erb</strong> templates and specifying default attributes for our <code>default.rb</code> recipe. Using attributes is pretty straight-forward: we need to create file for our recipe (in that case<code>default.rb</code>) file in attributes directory and use hash syntax on <code>default</code> object where <code>nginx</code> will be our namespace:</p></p>

<p><code>ruby attributes/default.rb
default['nginx']['user']      = 'www-data'
default['nginx']['worker_processes'] = '4'
</code></p>

<p><p>And how to access these values within our <code>nginx.conf.erb</code> template? The same way, hash syntax but with <code>node</code> object. So our template will look like this:</p></p>

<p>``` ruby templates/default/nginx.conf.erb
user &lt;%= node[&lsquo;nginx&rsquo;][&lsquo;user&rsquo;] %>;
worker_processes &lt;%= node[&lsquo;nginx&rsquo;][&lsquo;worker_processes&rsquo;] %>;</p>

<p>pid /var/run/nginx.pid;</p>

<p>events {
  worker_connections 768;
}</p>

<p>http {</p>

<p>  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  server_names_hash_bucket_size  64;</p>

<p>  include /etc/nginx/mime.types;
  default_type application/octet-stream;</p>

<p>  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;</p>

<p>  gzip on;
  gzip_disable &ldquo;msie6&rdquo;;</p>

<p>  include /etc/nginx/conf.d/<em>.conf;
  include /etc/nginx/sites-enabled/</em>;
}
```
<p>We will be able to customize these attributes from our role and/or node definition.</p></p>

<p><p>So we are left with the last part of installing Nginx: the recipe itself. Let&rsquo;s think how we want to this: we probably want to install <strong>Nginx</strong> &ndash; before that we may add <strong>ppa:nginx/stable</strong> repository to download the latest version, extract our template for configuration file and restart Nginx to use the new configuration. Fortunately, it looks very similar in Chef DSL:</p></p>

<p>``` ruby recipes/default.rb</p>

<p>bash &lsquo;add repo for Nginx&rsquo; do
  user &lsquo;root&rsquo;
  code &lt;&lt;-CODE</p>

<pre><code>add-apt-repository ppa:nginx/stable
apt-get update
</code></pre>

<p>  CODE
end</p>

<p>package &ldquo;nginx&rdquo;</p>

<p>template &ldquo;/etc/nginx/nginx.conf&rdquo; do
  owner &ldquo;root&rdquo;
  group &ldquo;root&rdquo;
  mode &ldquo;0644&rdquo;
  source &ldquo;nginx.conf.erb&rdquo;
  notifies :run, &ldquo;execute[nginx-restart]&rdquo;, :immediately
end</p>

<p>execute &ldquo;nginx-restart&rdquo; do
  command &ldquo;/etc/init.d/nginx restart&rdquo;
  action :nothing
end
```
<p>What&rsquo;s going on here?</p></p>

<p><ol>
  <li>We start with adding Nginx repository using <code>bash</code> method which is used for executing Bash scripts (as the name implies). We want to run in as <code>root</code> user and the script for adding repository is in <code>code</code> body.</li>
  <li>In next step we tell Chef to install Nginx itself using package manager.</li>
  <li>Then we want Chef to use our template file for configuration. Most of the parameters are pretty self-explanatory: root user will be the owner of the file, the file will belong to root group, we set permissions for the file, specify source in <code>templates</code> directory and we use notifications to take some action <code>immediately</code> (the other option is <code>delayed</code> taking action at the end of chef-client run). To specify action to take place we use <code>resource[name]</code> syntax.</li>
  <li>In last step we define our action for restarting Nginx using Chef Execute provider: we specify the command to be run and action, which can be <code>:run</code>(will run the command) and <code>:nothing</code>(prevents from running the command &ndash; we use <code>:nothing</code> in this case as we use it in <code>notifies</code> method in <code>template</code>).</li>
</ol></p>

<p><p>And that&rsquo;s it. We are left with Monit config. We&rsquo;ve already written our own recipe for Nginx so let&rsquo;s use <a href="https://github.com/TalkingQuickly/monit-tlq" target="_blank">this</a> recipe for Monit itself and <a href="https://github.com/TalkingQuickly/monit_configs-tlq" target="_blank">that one</a> for Nginx configuration. Copy these two cookbooks to <code>Berksfile:</code></p></p>

<p><code>ruby
cookbook 'monit_configs-tlq', git: 'git@github.com:TalkingQuickly/monit_configs-tlq.git', branch: 'master'
cookbook 'monit-tlq', git: 'git@github.com:TalkingQuickly/monit-tlq.git', branch: 'master'
</code></p>

<p><p>And run:</p></p>

<p><code>bash
berks install
</code></p>

<p><p>Let&rsquo;s get back to our <code>nginx.json</code> role definition. We need to specify attributes for nginx namespace: the default <code>user</code> as www-data is ok, so we will just set <code>worker_processes</code> to 2 and also add Monit configuration for Nginx. At the end the role will look like that:</p></p>

<p>``` json roles/nginx.json
{
  &ldquo;name&rdquo;: &ldquo;nginx-server&rdquo;,
  &ldquo;description&rdquo;: &ldquo;Nginx server&rdquo;,
  &ldquo;default_attributes&rdquo;: {</p>

<pre><code>"nginx": {
  "worker_processes": "2"
}
</code></pre>

<p>  },
  &ldquo;json_class&rdquo;: &ldquo;Chef::Role&rdquo;,
  &ldquo;run_list&rdquo;: [</p>

<pre><code>"nginx",
"monit_configs-tlq::nginx"
</code></pre>

<p>  ],
  &ldquo;chef_type&rdquo;: &ldquo;role&rdquo;
}
```</p>

<p><p>We will also need to install Monit itself. To check if everything works as it should, we will include email notifications. Let&rsquo;s define <code>monit</code> role:</p></p>

<p>``` json roles/monit.json
{
  &ldquo;name&rdquo;: &ldquo;monit&rdquo;,
  &ldquo;description&rdquo;: &ldquo;Monit&rdquo;,
  &ldquo;default_attributes&rdquo;: {</p>

<pre><code>"monit": {
  "notify_emails" : ["email@example.com"],
  "enable_emails" : true,
  "mailserver" : {
    "host" : "smtp.gmail.com",
    "port" : "587",
    "username" : "email@example.com",
    "password" : "password",
    "hostname" : "hostname"
  }
}
</code></pre>

<p>  },
  &ldquo;json_class&rdquo;: &ldquo;Chef::Role&rdquo;,
  &ldquo;run_list&rdquo;: [</p>

<pre><code>"monit-tlq"
</code></pre>

<p>  ],
  &ldquo;chef_type&rdquo;: &ldquo;role&rdquo;
}
```</p>

<p><p>Don&rsquo;t forget to put real data there ;). You may be wondering how did I know what attributes should I specify &ndash; in most cases these are documented but sometimes you will have to read the template files and check what kind of attributes you can customize and which are hardcoded.</p></p>

<p><p>We have our roles defined, the last thing we need to do is to include them in node definition:</p></p>

<p>``` json nodes/127.0.0.1.json
{
  &ldquo;run_list&rdquo;: [</p>

<pre><code>"role[monit]",
"role[nginx]"
</code></pre>

<p>  ],
  &ldquo;automatic&rdquo;: {</p>

<pre><code>"ipaddress": "127.0.0.1"
</code></pre>

<p>  }
}
```</p>

<p><p>So here is the final step &ndash; applying recipes on our node:</p></p>

<p><code>bash
knife solo cook vagrant@127.0.0.1 -p 2222 -i /Users/system_user_name/.vagrant.d/insecure_private_key
</code></p>

<p><p>The great thing about Chef is that you can change the values of attributes, apply them on the node and the chef-client will pick that change up. Just change <code>worker_processes</code> to 3 and watch what happens &ndash; Chef client will change the value of the attribute and restart Nginx.</p></p>

<p><p>Note: applying the cookbooks on a real server is almost the same as working with Vagrant:</p></p>

<p><code>
knife solo prepare root@ip
knife solo cook root@ip
</code></p>

<p><h2>Setting up complete server for Rails apps with Chef</h2></p>

<p><p>Composing Chef cookbooks for your server can take a long time: reading all recipes / cookbooks, checking configuration etc. may be quite tedious, especially when doing if for the first time, so I decided to share with <a href="https://github.com/Azdaroth/chef-server-setup-template" target="_blank">my own</a> configuration which I&rsquo;m going to describe in this section (heavily inspired by <a href="https://github.com/TalkingQuickly" target="_blank"></a> Ben Dixon&rsquo;s recipes, author of <a href="https://leanpub.com/deploying_rails_applications" target="_blank">Reliably Deploying Rails Applications</a>).</p></p>

<p><p>Let&rsquo;s take a look at the <a href="https://github.com/Azdaroth/chef-server-setup-template/blob/master/nodes/put_your_ip_address_here.json" target="_blank">node definition</a>. We have some new parameters: <code>environment</code> set to production &ndash; I will explain in a minute what is it for &ndash; and Debian <code>platform_family</code>. Next we&rsquo;ve got some recipes-related attributes. It could also be put in role definitions but I like keeping sensitive data in node definition:</p></p>

<p><ul>
  <li><strong>authorization</strong> &ndash; these attributes are related to <code>sudo</code> recipe &ndash; we assume that we are going to use <strong>deploy</strong> user which is going to have sudo access enabled. Also, the entire <strong>sysadmin</strong> group is going to have sudo access. We set <code>passwordless</code> to be false &ndash; the password will alwaus be required.</li>
  <li><strong>monit</strong> &ndash; configuration for Monit concerning sending notifications and accessing via web interface. I would suggest having them enabled. However, if you decide not to enable them, just delete this section.</li>
  <li><strong>postgresql</strong> &ndash; you must specify password hash for <code>postgres</code> user. You can generate it easily using openssl:</li>
<code>bash
  openssl passwd -1 "yourpassword"
</code>
  <li><strong>security</strong> &ndash; we can set ssh port here. The important thing is that you will have to restart ssh service, even if you don&rsquo;t change the value. Restarting using Chef caused some exceptions that I couldn&rsquo;t handle so far, so remember to restart the service while sshing on your server after running Chef for the first time:</li>
<code>bash
  /etc/init.d/ssh restart
</code>
</ul></p>

<p><p>And the last thing is <code>run_list</code>:</p></p>

<p><ul>
  <li><strong>role[server]</strong> &ndash; responsible for basic server setup</li>
  <li><strong>role[postgres-server]</strong> &ndash; install PostgreSQL and related stuff</li>
  <li><strong>role[rails-app]</strong> &ndash; Ruby / Rails related components, like RVM, Rubies</li>
  <li><strong>role[mongo-server]</strong> &ndash; installs MongoDB and sets up Monit monitoring</li>
  <li><strong>role[redis-server]</strong> &ndash; installs Redis and sets up Monit monitoring</li>
  <li><strong>role[memcached-server]</strong> &ndash; installs Elasticsearch and sets up Monit monitoring</li>
  <li><strong>role[nginx]</strong> &ndash; installs Nginx with Passenger and sets up Monit monitoring.</li>
</ul></p>

<p><p>If you don&rsquo;t want to install some components, simply remove them from <code>run_list</code>.</p></p>

<p><p>One more thing before we move to more detailed description of the roles: <code>data_bags</code> directory. It will be used for creating user (<strong>deploy</strong>), setting up password (again, password hash, not the plain password) and uploading ssh key. The <strong>deploy</strong> user is already specified in <code>deploy.json</code> file, so just paste your ssh key from <code>id_rsa.pub</code> and the password hash generated by:</p></p>

<p><code>bash
openssl passwd -1 "yourpassword"
</code></p>

<p><p>As the attributes set in the node definition take precedence over the ones defined in roles, the important part in the server role is the <code>run_list</code>:</p>
<ul>
  <li><code>openssl</code> is responsible for managing passwords></li>
  <li><code>build-essential</code> installs build-essential</li>
  <li><code>chef-solo-search</code> &ndash; library related to data bags which helps with searching</li>
  <li><code>sudo</code> and <code>users::sysadmins</code> were already discussed &ndash; they are responsible for creating users with specified password and giving sudo access</li>
  <li><code>ssh_key_gen</code> generated ssh key for deploy user</li>
  <li><code>basic-security-tlq</code> &ndash; based on <a href="https://github.com/TalkingQuickly/basic_security-tlq" target="_blank">this</a> recipe &ndash; deals with security. It installs fail2ban, ufw (firewall), unattended-upgrades packages and installs security updates automatically each day. It also modifies ssh settings (X11Forwarding is set to no, UsePAM to no and ssh port to specified value in node definition). It also enables 22, 80 (for Nginx) and specified ssh port in firewall and disables any other. You can add some rules for firewall using <code>firewall_allow</code> attributes in the following format:  {&ldquo;port&rdquo;: &ldquo;x&rdquo;, &ldquo;ip&rdquo;: &ldquo;xxx.xxx.xxx.xxx&rdquo;}</li>
  <li><code>look-and-feel-tlq</code> &ndash; based on <a href="https://github.com/TalkingQuickly/look_and_feel-tlq" target="_blank">this</a> recipe (I had to comment out restarting ssh service) &ndash; installs htop, vim, unzip packages. Remeber that <code>environment</code> parameter? If set to <code>production</code>, it will display beautiful &ldquo;PRODUCTION&rdquo; banner while sshing ;).</li>
  <li><code>monit-tlq</code> &ndash; installs Monit</li>
  <li><code>monit_configs-tlq::system</code> &ndash; sets up Monit configuration for system. You should check <a href="https://github.com/TalkingQuickly/monit_configs-tlq/blob/master/templates/default/system.conf.erb" target="_blank">it</a> out and decide if you want to include it, you may receive some occasional spam about on eg. small VPS instances, which is not a good sign. Monit notifications shouldn&rsquo;t be neglected.</li>
</ul></p>

<p><p>Let&rsquo;s move to another role &ndash; Postgres server: basically it installs PostgreSQL (9.3), changes <code>pg_hba.conf</code> configuration using specified attributes, uses <strong>pgtune</strong> utility to provide better configuration parameters (based on the hardware) and thus performance and sets up Monit monitoring. If you need more customization, refer to the <a href="https://github.com/hw-cookbooks/postgresql" target="_blank">docs</a>.</p></p>

<p><p>Next role deals with Ruby and Rails environment. The most important thing here is that it installs system-wide RVM, which is in my opinion much more convenient to work with on servers (development machine is a different story). Next, <code>deploy</code> user is added to rvm group, default Ruby version is specified and Rubies are installed. We also install Bundler and Passenger gems. You can check the <a href="https://github.com/fnichol/chef-rvm" target="_blank">docs</a> if you need further customization. And what about <code>rails_gem_dependencies-tlq</code> recipe? It installs some packages that you will probably need: curl, libcurl3, libcurl3-dev, <strong>imagemagick</strong>, libmagickwand-dev and nodejs. And one more thing: there might be a problem with RVM permissions (at time of writing this post, <a href="https://github.com/fnichol/chef-rvm/pull/257" target="_blank">this</a> pull request haven&rsquo;t been merged yet), so it may be a good idea to run: <code>rvm fix-permissions system</code> when sshing to your server for the first time.</p></p>

<p><p>Another role is Mongo server &ndash; it installs Mongodb, sets up Monit monitoring and uses <strong>/home/data/mongodb</strong> directory for db, you may delete it if you want the default value.</p></p>

<p><p>Next three roles are quite similar: they install Redis, Memcached and Elasticsearch and set up Monit configuration for each of them. Also, in case of Elasticsearch, it installs OpenJDK and gives possibility to customize the amount of allocated memory &ndash; you will probably  want to remove it, I keep it in a template, just to remember that it&rsquo;s a customizable attribute.</p></p>

<p><p>And the last one role: Nginx role, which installs Nginx with Passenger and sets up monitoring with Monit. There were some problems with using RVM Ruby when dealing with Passenger so it required helper recipe for <code>rake</code> package. There are a lot of hardcoded values (Ruby version, Passenger version) so make sure they match the ones specified in Rails App role. If you want more customization, refer to the <a href="https://github.com/miketheman/nginx" target="_blank">docs</a>.</p></p>

<p><h2>Wrapping up</h2></p>

<p><p>That was pretty quick introduction to <strong>Chef</strong> and there might be a lot things that weren&rsquo;t made perfectly clear. Again, it was not the purpose of this post to explain every possible detail but to give you the general idea. I hope that after reading this blog post you will have some basic understanding how Chef and related utilities work, how to write your own recipes, fork other cookbooks and modify them to your taste and never again do the manual server setup. You also have pretty nice starting point &ndash; just clone the repo of my server template and apply to the nodes ;).</p></p>
]]></content>
  </entry>
  
</feed>
