<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: OOP | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/oop/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2019-01-27T18:32:19+01:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Model your domain with composed models]]></title>
    <link href="https://karolgalanciak.com/blog/2015/02/26/model-your-domain-with-composed-models/"/>
    <updated>2015-02-26T09:10:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2015/02/26/model-your-domain-with-composed-models</id>
    <content type="html"><![CDATA[<p>In many Rails applications the modeling is limited only to creating classes inheritng from <code>ActiveRecord::Base</code> which are 1:1 mapped to database tables. Having AR models like <code>User</code> and <code>Project</code> doesn't tell much about the domain of your application. Well, you can add some domain logic to the models but that way you will easily end up having giant classes with thousands lines of code, so let's just use models for database-related stuff only. Other option would be to create service objects for every usecase. That's a good and clean way, but it's merely the interaction layer between different parts of your application. You may end up easily with all logic encapsulated within service objects that will start looking more like procedural programming rather than proper OOP and not real domain API at all. The good news is that you can easily counteract it: time to use composed models.</p>




<!--more-->




<h2>Definition and examples composed models</h2>




<p>Composed models are classes which emphasize the relation between entities and the interactions between them. In most applications the models have multiple different relations between each other, rarely are they self-contained. So what happens if we take some entities and try to put them in one class?</p>




<p>Imagine you are developing project management application and you've got <code>User</code>, <code>Project</code> and <code>Task</code> models. What are the possible interactions between these models? User can be assigned to many tasks in a given project, so we can both query for the existing tasks and add some new tasks. We would probably query for finished tasks, currently being done and the ones not started. We may also check if user is in given project or can add/remove him/her from the project. In this case, the predominant relation is the one between the <code>user</code> and <code>project</code>, so let's create a class <code>UserWithProject</code>. We will make it a decorator over these two models, so the class will take both <code>user</code> and <code>project</code> to constructor:</p>


<p>``` ruby
class UserWithProject
  attr_reader :user, :project
  private     :user, :project</p>

<p>  def initialize(user, project)</p>

<pre><code>@user = user
@project = project
</code></pre>

<p>  end
end
```</p>

<p>Let's add some actual logic to our composed model: querying for different tasks for related <code>user</code> and <code>project</code>, adding new tasks, checking if user is assigned to the project and maybe leaving the project. </p>


<p>``` ruby
class UserWithProject
  attr_reader :user, :project
  private     :user, :project</p>

<p>  def initialize(user, project)</p>

<pre><code>@user = user
@project = project
</code></pre>

<p>  end</p>

<p>  def tasks</p>

<pre><code>@tasks ||= project.tasks.with_assignee(user)
</code></pre>

<p>  end</p>

<p>  def pending_tasks</p>

<pre><code>tasks.pending
</code></pre>

<p>  end</p>

<p>  def finished_tasks</p>

<pre><code>tasks.finished
</code></pre>

<p>  end</p>

<p>  def not_started_tasks</p>

<pre><code>tasks.not_started
</code></pre>

<p>  end</p>

<p>  def add_task(task)</p>

<pre><code>task.asignee = user
task.project = project
task.save!
</code></pre>

<p>  end</p>

<p>  def assigned_to_project?</p>

<pre><code>project.users.include?(user)
</code></pre>

<p>  end</p>

<p>  def leave_project</p>

<pre><code>project.users.destroy(user)
</code></pre>

<p>  end
end
```</p>

<p>Most methods are probably self-explanatory and don't need to be discussed. Now we have an actual domain model which neatly encapsulates interactions between <code>users</code>, <code>projects</code> and <code>tasks</code>. Looks like a real API for application that can be simply (re)used.</p>




<p>One usecase for composed models is about interactions between models. But this patterns also shines when you consider some modifiers of values. By modifier I mean an object that has some kind of influence on values being returned by methods of other object. For example you might be developing an e-commerce app and have <code>Order</code> with <code>total_price</code>. Let's imagine that you need to handle discounts for orders, which as you max expect, are going to decrease <code>total_price</code>. With composed model pattern you could create <code>OrderWithDiscount</code> class. To make it still behave like an <code>Order</code> instance, the class may inherit from <code>SimpleDelegator</code> and all the method calls not implemented by <code>OrderWithDiscount</code> are going to be delegated to <code>Order</code>:</p>


<p>``` ruby
class OrderWithDiscount &lt; SimpleDelegator
  attr_reader :order, :discount
  private     :order, :discount</p>

<p>  def initialize(order, discount)</p>

<pre><code>@order = order
@discount = discount
super(order)
</code></pre>

<p>  end</p>

<p>  def total_price</p>

<pre><code># somehow apply the discount.value to order.total_price
</code></pre>

<p>  end
end
```</p>

<p>That way you can still have <code>total_price</code> on Order without adding additional arguments, conditionals etc. for handling discounts and have a separate object for special usecases.</p>




<h2>Extracting existing logic to composed models</h2>




<p>Now that you know how what are the composed models for, you may be wondering how to extract already existing codebase to that pattern. Fortunately, it's easy to tell in many cases if a particular method is a good fit to move. When you have multiple methods in one class taking the same kind of argument(s), that's probably a good idea to think about some changes. Let's use the example with <code>User</code> and <code>Project</code>. If that pattern hadn't been used there we would probably have had some code in <code>Project</code> model looking like this:</p>


<p>``` ruby
class Project &lt; ActiveRecord::Base
  # associations and stuff like that</p>

<p>  def tasks_for_user(user)</p>

<pre><code># some logic
</code></pre>

<p>  end</p>

<p>  def pending_tasks_for_user(user)</p>

<pre><code># some logic
</code></pre>

<p>  end</p>

<p>  def finished_tasks_for_user(user)</p>

<pre><code># some logic
</code></pre>

<p>  end</p>

<p>  def add_task_for_user(task, user)</p>

<pre><code># some logic
</code></pre>

<p>  end
end
```</p>

<p>This class really begs for refactoring ;). Another sign would be having methods where there might be an argument modyfing the value or may not. Using the <code>Order</code> example, there could be a method like:</p>


<p>``` ruby
class Order &lt; ActiveRecord::Base
  def total_price(discount: nil)</p>

<pre><code># somehow calculate the total_price
if discount?
  # apply the discount
end
</code></pre>

<p>  end
end
```</p>

<p>Doesn't really look great, having separate class makes it much easier to read and understand.</p>




<h2>Wrapping up</h2>




<p>I've shown a pretty cool pattern I've started using recently, which works really great and makes a big difference when looking at the domain logic of the application. I hope you will find it useful.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails: Useful Patterns]]></title>
    <link href="https://karolgalanciak.com/blog/2014/09/17/rails-useful-patterns/"/>
    <updated>2014-09-17T19:55:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2014/09/17/rails-useful-patterns</id>
    <content type="html"><![CDATA[<p>There've been a lot of discussions for several months about "The Rails Way" and problems associated with it - huge models with several thousands lines of code and no distinguishable responsibilities (User class which does everything related to users doesn't tell much what the app does), unmaintainable callback hell and no domain objects at all. Fortunately, service objects (or usecases) and other forms of extracting logic from models have become quite mainstream recently. However, it's not always clear how to use them all together without creating huge classes with tens of private methods and too many responsibilities. Here are some strategies you can use to solve these problems.</p>




<!--more-->


<p></p>

<h2>Pass form objects as data aggregates to service objects</h2>




<p>Imagine situation where your usecase involves more than one model, some virtual attributes are needed etc., basically the usecase where form object is necessary (unless you want to have a serious mess in models). Furthermore, you need to implement pretty complex features - besides proper mapping of attributes to models in form objects you want to send some notifications, log an activity and other stuff. How to tackle such a problem? Often I see a code where all custom logic, apart from simple saving data, is put in form objects. That's not really a way to go. Why start from separating responsibilities and end up with form object which does everything? You can easily handle it by passing form objects with populated data to service objects. Take a look at the controller action below:</p>


<p>``` ruby
class UsersController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>user = User.new
form = User::RegistrationForm.new(user)
registration = User::Registration.new(logger: MyFancyCustomLogger, mailer: User::RegistraionMailer)

if form.validate(params) &amp;&amp; registration.register(form)
  # success path
else
  # failure path
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The <code>UsersController</code> is responsible here for control flow, form aggregates and validates data and <code>User::Registration</code> does some domain business logic and assumes it operates on valid data. Looks and feels great, it's easy to test and the responsibilities are clear. I also inject some dependencies in the constructor of <code>User::Registration</code> to make it even more testable and extensible.</p>


<p></p>

<p>The only problem with such an approach is lack of compatibility or difficulties with customization with some gems (like <code>inherited_resources</code>). But gems shouldn't force you to write code in a particular way and it would be probably better to give up on them and enjoy a clean code.</p>




<h2>Create flexible service objects with listeners</h2>




<p>Let's consider previous usecase: registration. Imagine situation where you need three types of user registration: “normal” one like when you enter the page and want to create an account,  registration by admin and registering new users by non-admin within some kind of groups. The core of registration process remains the same in all cases. However, there will be slight differences between the usesaces, eg. there won't be any notification sent to admin when user is being registered by admin. One way would be to create service object for each usecase and encapsulate entire logic within them. But it may lead to code that is not DRY and these classes may be unnecessary. If the core of the registration process doesn't change, we can create interface flexible enough to handle all cases by passing listeners that are being notified after registration process. Our service object could look like this:</p>


<p>``` ruby</p>

<p>class User::Registration</p>

<p>  attr_reader :logger, :listeners
  private :logger, :listeners</p>

<p>  def initialize(*listeners, **options)</p>

<pre><code>@listeners = listeners
@logger = options.fetch(:logger) { MyFancyCustomLogger }
</code></pre>

<p>  end</p>

<p>  def register(aggregate)</p>

<pre><code># do some stuff common in all cases
notify_listeners(aggregate)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def notify_listeners(aggregate)
  listeners.each { |listener| listener.notify(aggregate) }
end
</code></pre>

<p>```</p>

<p>We can pass any number of listeners to the constructor and inject dependencies if required. All listeners have to implement the same interface: <code>notify</code> method which takes one argument. The controller action for registering new user may look like this:</p>


<p>``` ruby
class UsersController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>user = User.new
form = User::RegistrationForm.new(user)
registration = User::Registration.new(
  AdminNewUserListener.new,
  SomeExternalServiceNewUserListener.new
  logger: MyFancyCustomLogger
)

if form.validate(params) &amp;&amp; registration.register(form)
  # success path
else
  # failure path
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>We've encapsulated additional logic in separate classes in form of listeners and created quite flexible interface - we need another action in registration process but only in one type of registration, not all of them? Just pass another listener into the constructor in controller.</p>




<h2>Extract context classes</h2>




<p>It often happens that you need an entity to play different roles, eg. the user can be a seller or a buyer, depending on the usecase. Instead of adding plenty of methods to the <code>User</code> class that are related only to the particular role, you can create context classes. Both sellers and buyers will probably share the same methods. One way to solve this problem could be inheritance but it would mean single table inheritance in this case (ActiveRecord model) and that's not what we need. However, we can use <code><a href="http://ruby-doc.org/stdlib-2.1.2/libdoc/delegate/rdoc/SimpleDelegator.html" target="_blank">SimpleDelegator</a></code> which would delegate all the method calls to the decorated object (user) if the decorator doesn't implement these methods:</p>


<p>``` ruby
class Seller &lt; SimpleDelegator</p>

<p>  def rating</p>

<pre><code># instead of rating_as_seller method in User class
positive_opinions_from_bought_items.to_f / opinions_from_bought_items.to_f
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>``` ruby
class Buyer &lt; SimpleDelegator</p>

<p>  def rating</p>

<pre><code># instead of rating_as_buyer method in User class
positive_opinions_from_seld_items.to_f / opinions_from_sold_items.to_f
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>We can also implement some convenience methods in <code>User</code> class to get user in approperiate context:</p>


<p>``` ruby
class User &lt; ActiveRecord::Base</p>

<p>  def to_buyer</p>

<pre><code>Buyer.new(self)
</code></pre>

<p>  end</p>

<p>  def to_seller</p>

<pre><code>Seller.new(self)
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Trade long if/case statements for declarative dispatch</h2>




<p>Rather a structural implementation detail but still quite interesting. Imagine situation when you have to return proper status based on some conditions. You can of course use <code>case</code> statement but the problem with this approach is that the code is not really pretty, especially when you have multiple conditions for each status. For complex logic it might be better to handle such usecases with more declarative approach:</p>


<p>``` ruby
class User::SellerStatus</p>

<p>  attr_reader :user
  private :user</p>

<p>  def initialize(user)</p>

<pre><code>@user = user
</code></pre>

<p>  end</p>

<p>  def call</p>

<pre><code>statuses_conditions.detect do |aggregate|
  conditions = aggregate.last
  conditions.all? { |condition| send(condition) }
end.first
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def statuses_conditions
  {
    super_seller: [
      :has_more_than_1000_opinions?,
      :has_more_than_95_percent_positive_opinions_as_seller?
    ],
    blacklisted_seller: [ 
      :has_at_least_10_opinion_as_seller?,
      :has_more_than_50_precent_or_equal_negative_opinions_as_seller?
    ],
    new: [
      :has_less_than_10_opinion_as_seller?,
    ],
    no_status: []
  }
end

def has_more_than_1000_opinions?
  # some code
end

def has_more_than_95_percent_positive_opinions_as_seller?
  # some code
end

def has_at_least_10_opinion_as_seller?
  # some code
end

def has_more_than_50_precent_or_equal_negative_opinions_as_seller?
  # some code
end

def has_less_than_10_opinion_as_seller?
  # some code
end
</code></pre>

<p>end</p>

<p>```</p>

<p>The <code>detect</code> enumerator (aliased also as <code>find</code>) will return the first element for which the block returns true. In this case all the conditions must be satisfied to return true.</p>




<p>Instead of using bunch of private methods, you can move these methods to policy objects and change the receiver of the message to be the policy, not <code>self</code>:</p>


<p>``` ruby</p>

<p>def call
  policy = User::SellerPolicy.new(user)
  statuses_conditions.detect do |aggregate|</p>

<pre><code>conditions = aggregate.last
conditions.all? { |condition| policy.public_send(condition) }
</code></pre>

<p>  end.first
end</p>

<p>```</p>

<p>I like the clarity of this approach - you can immediately say what are the necessary conditions for each status without multiple <code>&&</code> operators in case statement which would make it harder to read.</p>




<h2>Wrapping up</h2>




<p>I've shown some simple and common techniques I use in almost everyday coding. I hope that you will find them useful and will keep the code clean.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Driven Rails - Part 2]]></title>
    <link href="https://karolgalanciak.com/blog/2014/03/03/test-driven-rails-part-2/"/>
    <updated>2014-03-03T19:52:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2014/03/03/test-driven-rails-part-2</id>
    <content type="html"><![CDATA[<p>Last time, in <a href="http://karolgalanciak.com/blog/2014/01/04/test-driven-rails-part-1/" target="_blank">part 1</a>, I was giving some advice about testing - why to test at all, which tests are valuable and which are not, when to write acceptance tests and in what cases aim for the maximum code coverage. It brought about some serious discussion about testing ideas and if you haven't read it yet, you should probably check (<a href="http://karolgalanciak.com/blog/2014/01/04/test-driven-rails-part-1/#disqus_thread" target="_blank">it</a>) it out. Giving some general point of view about such broad topic like Test Driven Development / Behavior Driven Development is definetely not enough so I will try to apply these techniques by implementing a concrete feature. I wanted to choose some popular usecase so that most developers will have an opinion how they would approach it. In most applications you will probably need:</p>




<!--more-->


<p></p>

<h2>User Registration</h2>




<p>It is quite common feature and it can be approached in many ways. The most popular is to some authentication gem, like Devise, which is the probably the safest and the fastest way. However, Devise might be an overkill for some cases or maybe you need highly customizable solution. How would you write an implementation fot that usecase then?</p>




<p>Note: the implementation below doesn't aim to be the most secure approach for that feature, it's rather for demonstration purposes. I made some non-standard design decisions for the Rails application, you may want to read one of my <a href="http://karolgalanciak.com/blog/2013/10/06/structuring-rails-applications/" target="_blank">previous posts</a> to get more details why this way of designing code might be beneficial.</p>




<h2>Specification</h2>




<p>We know that we want to implent user registration. Let's say that we want user to confirm his/her account before signing in so we will need to send some confirmation instructions. Also, let's add some admin notifications about new user being registered to make it more interesting.</p>




<p>To make it even better, let's assume that we will create both <code>User</code> and <code>UserProfile</code> during registration: <code>User</code> will have just an <code>email</code> and <code>encrypted_password</code> attributes, <code>UserProfile</code> will have <code>country</code> and <code>age</code> attributes. User will also have to accept some policy to register. If we want to have confirmation, we will also need some attributes for <code>confirmation_token</code>, confirmation date (<code>confirmed_at</code>) and let's add <code>confirmation_instructions_sent_at</code> just to know, when the instructions were sent. These are just registration-specific attributes and we won't need them in most cases so let's extract them to <code>UserRegistrationProfile</code></p>




<p>Note: when writing the implementation and the tests, the following gems were used: <code>rails (4.0.3)</code>, <code>database_cleaner (1.2.0)</code>, <code>simple_form (3.0.1)</code> with <code>country_select (1.3.1)</code>, <code>reform (0.2.4)</code>, <code>bcrypt (3.1.6)</code>, <code>rspec-rails (3.0.0.beta1)</code>, <code>factory_girl_rails (4.3.0)</code> and <code>capybara (2.2.1)</code>.</p>




<h2>Start with acceptance tests</h2>




<p>When writing new feature we should start from acceptance tests - we will make sure that the feature works from the higher level: from the user perspective and some side effects like sending emails. So the good start will be covering user creation and sending emails to an admin and to the user. Let's write some Capybara tests:</p>


<p>``` ruby spec/features/user_registration_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>feature &ldquo;User Registration&rdquo; do</p>

<p>  context &ldquo;when visiting new user path&rdquo; do</p>

<pre><code>background do
  visit new_user_path
end

context "registering with valid data" do

  given(:email) { "myawesome@email.com" }

  background do
    fill_form_with_valid_data(email: email)
  end

  scenario "new user is created" do
    expect do
      register
    end.to change(User, :count).by(1)
  end

  context "notifications" do

    background do
      register
    end

    scenario "confirmation email is sent to the user" do
      expect(all_email_addresses).to include email
    end

    scenario "notification is sent to the admin" do
      expect(all_email_addresses).to include "admin@example.com"
    end

    scenario "2 emails are sent" do
      expect(all_emails.count).to eq 2
    end

  end

end
</code></pre>

<p>  end</p>

<p>end</p>

<p>def fill_form_with_valid_data(args={})
  email = args.fetch(:email, &ldquo;<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#101;&#x6d;&#x61;&#105;&#x6c;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;">&#101;&#x6d;&#x61;&#x69;&#108;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;</a>&rdquo;)
  fill_in &ldquo;email&rdquo;, with: email
  fill_in &ldquo;user_password&rdquo;, with: &ldquo;my-super-secret-password&rdquo;
  fill_in &ldquo;user_password_confirmation&rdquo;, with: &ldquo;my-super-secret-password&rdquo;
  fill_in &ldquo;age&rdquo;, with: 22
  select &ldquo;Poland&rdquo;, from: &ldquo;country&rdquo;
  check &ldquo;policy&rdquo;
end</p>

<p>def register
  click_button &ldquo;Register&rdquo;
end</p>

<p>```</p>

<p>I like using some helper methods, especially in acceptance tests so I wrote <code>fill_form_with_valid_data</code> and <code>register</code> helpers - these are just some details and I don't need to know them when reading tests. There are also some helpers like <code>all_email_addresses</code> and <code>all_emails</code>, which come from the <code>MailerMacros</code>:</p>


<p>``` ruby spec/support/mailer_macros.rb
module MailerMacros</p>

<p>  def last_email</p>

<pre><code>ActionMailer::Base.deliveries.last
</code></pre>

<p>  end</p>

<p>  def last_email_address</p>

<pre><code>last_email.to.join
</code></pre>

<p>  end</p>

<p>  def reset_email</p>

<pre><code>ActionMailer::Base.deliveries = []
</code></pre>

<p>  end</p>

<p>  def reset_with_delayed_job_deliveries</p>

<pre><code>ActionMailer::Base.deliveries = []
</code></pre>

<p>  end</p>

<p>  def all_emails</p>

<pre><code>ActionMailer::Base.deliveries
</code></pre>

<p>  end</p>

<p>  def all_emails_sent_count</p>

<pre><code>ActionMailer::Base.deliveries.count
</code></pre>

<p>  end</p>

<p>  def all_email_addresses</p>

<pre><code>all_emails.map(&amp;:to).flatten
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>If you like it, just create <code>spec/support/mailer_macros.rb</code>, put the code there and in your <code>spec_helper.rb</code> insert the following lines:</p>


<p><code>ruby spec/spec_helper.rb
config.include(MailerMacros)
config.before(:each) { reset_email }
</code></p>

<p>Also, the select with country might be not clear - the collection with countries comes from <code>country_select</code> gem.</p>




<p>We have some failing acceptance tests, it will take some time to make them all green. Now we can write some migrations:</p>


<p><code>ruby
rails generate model User email encrypted_password
rails generate model UserProfile user_id:integer age:integer country
</code></p>

<p>We also need to add some database constraints, to ensure that users' emails are unique and fields are not null, the migrations would look like this:</p>


<p>``` ruby</p>

<p>class CreateUsers &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :users do |t|
  t.string :email, null: false
  t.string :encrypted_password, null: false

  t.timestamps
end

add_index :users, :email, unique: true
</code></pre>

<p>  end
end</p>

<p>class CreateUserProfiles &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :user_profiles do |t|
  t.integer :age
  t.string :country, null: false
  t.integer :user_id, null: false

  t.timestamps
end
add_index :user_profiles, :user_id
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Now we have to define some routes:</p>


<p>``` ruby config/routes.rb</p>

<p>root to: &ldquo;static_pages#home&rdquo;</p>

<p>resources :users do
end</p>

<p>```</p>

<p>For user registration, we have REST actions: <code>new</code> and <code>create</code>. Let's also add some root page, currently just to get rid of default Rails page:</p>


<p>``` ruby app/controllers/static_pages_controller.rb
class StaticPagesController &lt; ApplicationController</p>

<p>  def home</p>

<p>  end</p>

<p>end
```</p>

<p>But how to deal with <code>UsersController</code> and form for user registration? We have some fields that are not present in models (<code>password/password_confirmation</code> and <code>policy</code>). The popular solution would be using: <code>accepts_nested_attributes_for :profile</code> and some virtual attributes. I don't really like this solution, <code>accepts_nested_attributes_for</code> sometimes can really save a lot of time, especially with complex nested forms with <a href="https://github.com/ryanb/nested_form" target="_blank">nested_form</a> gem. But virtual attributes are quite ugly and they make models the interfaces for forms. Much better approach is to use form objects. There's a great gem for this kind of problems: <code>Reform</code> -  we will use it here.</p>


<p>``` ruby app/controllers/users_controller.rb
class UsersController &lt; ApplicationController</p>

<p>  def new</p>

<pre><code>@registration_form = registration_form
</code></pre>

<p>  end</p>

<p>  def create</p>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)   
end
</code></pre>

<p>end</p>

<p>```</p>

<p>That's it for <code>UsersController</code>, we will need some views and the actual form object:</p>


<p>``` ruby app/views/users/new.html.haml</p>

<p>%h1 User Registration</p>

<p>= simple_form_for @registration_form do |f|
  = f.input :email, label: &ldquo;email&rdquo;
  = f.input :country, label: &ldquo;country&rdquo;, as: :country
  = f.input :age, label: &ldquo;age&rdquo;
  = f.input :password, label: &ldquo;password&rdquo;
  = f.input :password_confirmation, label: &ldquo;password confirmation&rdquo;
  = f.input :policy, label: &ldquo;I accept the policy&rdquo;, as: :boolean
  = f.submit &ldquo;Register&rdquo;</p>

<p>```</p>

<p>And the actual <code>UserRegistrationForm</code>:</p>


<p>``` ruby app/forms/user_registration_form.rb</p>

<p>class UserRegistrationForm &lt; Reform::Form</p>

<p>  include Reform::Form::ActiveRecord
  include Composition</p>

<p>  property :email, on: :user
  property :password, on: :nil, empty: true
  property :password_confirmation, on: :nil, empty: true
  property :age, on: :profile
  property :country, on: :profile
  property :policy, on: :nil, empty: true</p>

<p>  validates :email, presence: true, email: true, uniqueness: { case_sensitive: false }
  validates :password, presence: true, confirmation: true
  validates :age, presence: true
  validates :country, presence: true
  validates :policy, acceptance: true, presence: true</p>

<p>  model :user</p>

<p>end</p>

<p>```</p>

<p>Reform is not (yet) that popular in the Rails community so some things require explanation (check also the <a href="https://github.com/apotonick/reform" target="_blank">docs</a> out). The <code>Reform::Form::ActiveRecord</code> module is for uniqueness validation and the <code>Composition</code> is for... composition - some properties are mapped to user and other to profile. There is also a mystical mapping with <code>on: :nil</code> - these are "virtual" properties like <code>password</code>, <code>password_confirmation</code> and <code>policy</code> - all properties must be mapped to a resource so just to satisfy Reform API I use <code>on: :nil</code> as a convention, also the <code>empty: true</code> option is for virtual attributes that won't be processed. And where does the email validation come from? From our custom validator, let's write some specs but before we should add /forms (and /usecases for business logic) directories to be autoloaded:</p>


<p><code>ruby config/application.rb
config.autoload_paths += %W(#{config.root}/app/usecases)
config.autoload_paths += %W(#{config.root}/app/forms)
</code></p>

<p>``` ruby spec/usecases/email_validator_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>class DummyModel</p>

<p>  include ActiveModel::Validations</p>

<p>  attr_accessor :email</p>

<p>  validates :email, email: true</p>

<p>end</p>

<p>describe EmailValidator do</p>

<p>  let(:model) { DummyModel.new }</p>

<p>  it &ldquo;validates email format&rdquo; do</p>

<pre><code>valid_emails = %w[email@example.com name.surname@email.com 
    e-mail@example.com]

valid_emails.each do |email|
  model.email = email
  expect(model).to be_valid
end

invalid_emails = %w[email @email.com email.example.com 
  email@example email@example.]

invalid_emails.each do |email|
  model.email = email
  expect(model).not_to be_valid
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>You can probably come up with some more examples to cover email validation but these are sufficient cases. I've introduced <code>DummyModel</code> here to have a generic object that can be validated so the <code>ActiveModel::Validations</code> module is needed and an accessor for an email. Let's implement the actual validation:</p>


<p>``` ruby usecases/email_validator.rb</p>

<p>class EmailValidator &lt; ActiveModel::EachValidator</p>

<p>  def validate_each(record, attribute, value)</p>

<pre><code>unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
  record.errors[attribute] &lt;&lt; (options[:message] || "is not a valid email format")
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The regexp for email validation comes from Rails guides:). It won't cover all the possibilities but the <a href="http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html" target="_blank">actual format</a> of the email is an overkill.</p>




<p>I don't fell the need to write tests for other validations and composition for <code>UserRegistrationForm</code>: it's just using very descriptive DSL, the validation are already tested in Rails.</p>




<p>We haven't set up the associations yet in models:</p>


<p>``` ruby app/models/user.rb
class User &lt; ActiveRecord::Base</p>

<p>  has_one :profile, class_name: &ldquo;UserProfile&rdquo;, inverse_of: :user</p>

<p>  validates :email, presence: true, uniqueness: { case_insensitive: false }, email: true
  validates :encrypted_password, presence: true</p>

<p>```</p>

<p>``` ruby app/models/user_profile.rb
class UserProfile &lt; ActiveRecord::Base</p>

<p>  belongs_to :user, inverse_of: :profile</p>

<p>  validates :user, :country, :age, presence: true</p>

<p>end</p>

<p>```</p>

<p>I added also validations in models. These may seem like a duplication because form object already implements them but these are validations always applicable do these models so it is a good idea to have them in models.</p>




<p>Let's concentrate on <code>UsersController</code> and <code>create</code> action. I don't really like testing controllers, especially for CRUD-like stuff, user creation still feels like CRUD but not that typical in Rails, especially when using dedicated form object. So let's test drive registration process: we are going to use <code>UserRegistrationForm</code> for data aggregation and validation - if the data is valid, the user will be created by <code>UserRegistration</code> service object with redirection to root path, otherwise it will render <code>new</code> template.</p>


<p>``` ruby spec/controllers/users_controller_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UsersController do</p>

<p>  describe &ldquo;#create&rdquo; do</p>

<pre><code>let(:registration_form) { instance_double(UserRegistrationForm) }

let(:user_params) { { "email" =&gt; "email@example.com" } }
let(:params) { { user: user_params } }

let(:user_registration) { instance_double(UserRegistration) }

before(:each) do
  allow(UserRegistrationForm).to receive(:new) { registration_form }
  allow(registration_form).to receive(:assign_attributes)
    .with(user_params) { registration_form }
  allow(user_registration).to receive(:register!)
    .with(registration_form) { true }
  allow(UserRegistration).to receive(:new) { user_registration }        
end

context "valid data" do

  before(:each) do
    expect(registration_form).to receive(:valid?) { true }
    post :create, params  
  end

  it "executes registration" do
    expect(user_registration).to have_received(:register!).with(registration_form)
  end

  it "redirects to root path" do
    expect(response).to redirect_to root_path
  end

end

context "invalid data" do

  before(:each) do
    expect(registration_form).to receive(:valid?) { false }
    post :create, params  
  end

  it "renders registration form" do
    expect(response).to render_template :new
  end

end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Well, it is not really clear, that's the problem with testing controllers and they should be as thin as possible. We need to implement the <code>assign_attributes</code>
 method in form object to fill models' attributes with params and implement the actual <code>UserRegistration</code> usecase. In tests I use <code>instance_double</code> 
 instead of simple <code>double</code> to make sure I'm not stubbing non-existent methods or with wrong number of arguments - that's a great feature introduced in RSpec 3, which comes from <a href="https://github.com/xaviershay/rspec-fire" target="_blank">rspec-fire</a> gem. Also, I'm stubbing responses so that I can spy on them using <code>have_received</code> method - It's much cleaner and easier to read. Compare these two examples:</p>


<p>``` ruby</p>

<p>before(:each) do
  expect(registration_form).to receive(:valid?) { true }
  post :create, params<br/>
end</p>

<p>it &ldquo;executes registration&rdquo; do
  expect(user_registration).to have_received(:register!).with(registration_form)
end</p>

<p>it &ldquo;redirects to root path&rdquo; do
  expect(response).to redirect_to root_path
end</p>

<p>```</p>

<p>and</p>


<p>``` ruby</p>

<p>before(:each) do
  expect(registration_form).to receive(:valid?) { true }
end</p>

<p>it &ldquo;executes registration&rdquo; do
  expect(user_registration).to receive(:register!).with(registration_form)
  post :create, params
end</p>

<p>it &ldquo;redirects to root path&rdquo; do
  post :create, params
  expect(response).to redirect_to root_path
end</p>

<p>```</p>

<p>I really encourage you to spy on a stubbed method, I will make your tests much more readable and DRY them up.</p>




<p> I made also some non-standard design decisions here: why not to implement the persistence logic in the form object and use it like:</p>


<p><code>ruby
if @registration_form.persist(user_params) # populate data, perform validation and persist data if is valid
  # happy paths
else
  # failure path
end
</code></p>

<p>For simple persistence logic I would probably go with that approach but we will also need to send some confirmation instructions, admin notifications etc., I'm not really comfortable with the idea of form object knowing something about sending notifications, persistence alone would be ok, it would be quite convenient to use but this is too complex, I would leave form object for data aggregation and validation. Let's write code for the controller:</p>


<p>``` ruby app/controllers/users_controller.rb</p>

<p>class UsersController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>@registration_form = registration_form.assign_attributes(params[:user])

if @registration_form.valid?
  UserRegistration.new.register!(@registration_form)
  redirect_to root_path, notice: "You have register. Please, check your email for confimartion instructions"
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)
end
</code></pre>

<p>end</p>

<p>```</p>

<p>We need to implement <code>assign_attributes</code> method (we have nice failure message thanks to <code>instance_double</code> that informs us about it):</p>


<p>``` ruby
Failure/Error: allow(registration_form).to receive(:assign_attributes)
  UserRegistrationForm does not implement:</p>

<pre><code>assign_attributes
</code></pre>

<p>```</p>

<p>and UserRegistration. Let's start from test for <code>assign_attributes</code> method. It looks like, besides assigning params, it should return itself:</p>


<p>``` ruby spec/forms/user_registration_form_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistrationForm do</p>

<p>  let(:user) { User.new }
  let(:profile) { UserProfile.new }</p>

<p>  subject { UserRegistrationForm.new(user: user, profile: profile) }</p>

<p>  describe &ldquo;#assign_attributes&rdquo; do</p>

<pre><code>it "populates models' attributes with params" do
  subject.assign_attributes("email" =&gt; "email@example.com", "country" =&gt; "Poland")
  expect(subject.user.email).to eq "email@example.com"
  expect(subject.profile.country).to eq "Poland"
end

it "assigns profile to user" do
  subject.assign_attributes({})
  expect(user.profile).to eq profile
end

it "returns self" do
  expect(subject.assign_attributes({})).to eq subject
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And the code for implementation:</p>


<p>``` ruby app/forms/user_registration_form.rb</p>

<p>def assign_attributes(params)
  from_hash(params)
  save_to_models
  self
end</p>

<p>```</p>

<p>It uses some Reform::Form private methods that I found in source code so this implementation might not be stable but fortunately we have it covered in tests so we will know breaking changes if it happens in next versions. And there's a gotcha here: The keys in hash must be stringified, symbols won't work (applies to 0.2.4 version of Reform).</p>




<p>Let's write some minimal implementation for <code>UserRegistration</code> to satisfy controller's specs:</p>


<p>``` ruby app/usecases/user_registration.rb
class UserRegistration</p>

<p>  def register!(aggregate)</p>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And what the <code>UserRegistration</code> should be responsible for? Let's start with persistence logic: user with it's profile must be created and the encrypted password should be assigned to the user. We will also need registration profile to be created.</p>


<p>``` ruby spec/usecases/user_registration_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistration do</p>

<p>  let(:user) { FactoryGirl.build_stubbed(:user) }
  let(:profile) { FactoryGirl.build_stubbed(:user_profile) }</p>

<p>  let(:form) { double(:form, user: user, profile: profile,</p>

<pre><code>password: "password") }
</code></pre>

<p>  subject { UserRegistration.new(encryption: encryption) }</p>

<p>  let(:encrypted_password) { &ldquo;encrypted_password&rdquo; }</p>

<p>  let(:encryption) { instance_double(Encryption,</p>

<pre><code> generate_password: encrypted_password) }
</code></pre>

<p>  context &ldquo;persistence is success&rdquo; do</p>

<pre><code>before(:each) do
  allow(user).to receive(:save!) { true }
  allow(profile).to receive(:save!) { true }
  allow(user).to receive(:create_registration_profile!) { true }
end

before(:each) do
  subject.register!(form)
end

specify "user gets encrypted password" do  
  expect(user.encrypted_password).to eq encrypted_password
end

it "saves user" do
  expect(user).to have_received(:save!)
end

it "creates profile for user" do
  expect(profile).to have_received(:save!)
end

it "create registration profile for user" do
  expect(user).to have_received(:create_registration_profile!)
end
</code></pre>

<p>  end</p>

<p>  context &ldquo;persistence fails&rdquo; do</p>

<pre><code>it "raises RegistrationFailed error" do
  allow(user).to receive(:save!) { raise_error ActiveRecord::RecordInvalid }
   expect do
    UserRegistration.new.register!(form)
  end.to raise_error UserRegistration::RegistrationFailed
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Note: keep in mind that you should write one test and then write minimal implementation to make it pass and then another test. I gave the several tests and the actual <code>UserRegistration</code> in advance, just to make it easier to read and follow.</p>




<p>It is quite clear from the tests what should be expected from this class: creation of user, profile, registration profile and assigning encrypted password. Data aggregate (<code>form</code>) is just a <code>double</code> with profile and user, we don't care what it actually is, it should just implement the stubbed interface. I also use FactoryGirl and <code>build_stubbed</code> method for initializing models - I find it more convenient than to use <code>instance_double</code> because instance doubles don't cover attributes from database tables.</p>




<p>The factories for User and profiles would look like that:</p>


<p>``` ruby spec/factories.rb</p>

<p>  FactoryGirl.define do</p>

<p>  factory :user do</p>

<pre><code>email "email@example.com"
# I'll explain that later, why it is that long
encrypted_password "$2a$10$bcMccS3q2egnNICPLYkptOoEyiUpbBI5Q.GAKe0or2QB7ij6yCeOa" 
</code></pre>

<p>  end</p>

<p>  factory :user_profile do</p>

<pre><code>age 22
country "Poland"
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And the actual implementation:</p>


<p>``` ruby app/usecases/user_registration.rb</p>

<p>class UserRegistration</p>

<p>  class RegistrationFailed &lt; StandardError ; end</p>

<p>  attr_reader :encryption
  private :encryption</p>

<p>  def initialize(options={})</p>

<pre><code>@encryption = options.fetch(:encryption, Encryption.new)
</code></pre>

<p>  end</p>

<p>  def register!(aggregate)</p>

<pre><code>user = aggregate.user
profile = aggregate.profile
user.encrypted_password = encrypted_password(aggregate.password)
ActiveRecord::Base.transaction do
  begin
    user.save!
    profile.save!
    user.create_registration_profile!
  rescue ::ActiveRecord::StatementInvalid, ::ActiveRecord::RecordInvalid =&gt; e
    raise_registration_error(e)
  end
end  
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def raise_registration_error(errors)
  message =  "Registration Failed due to the following errors: #{errors}"      
  raise UserRegistration::RegistrationFailed, message
end

def encrypted_password(password)
  encryption.generate_password(password)
end
</code></pre>

<p>end</p>

<p>```</p>

<p>Let's discuss some design decisions: the constructor accepts options hash so that we can inject dependencies like <code>encryption</code> and to provide defaults if it's injected. The persistence logic is wrapped in transaction block so that e.g. user won't be created if profile creation fails. If it fails, <code>RegistrationFailed</code> error is raised with a descriptive message. Also, the <code>encryption</code> is private: we don't need it to be public.</p>




<p>To satisfy tests, the <code>create_registration_profile!</code> must be implemented and <code>generate_password</code> for encryption. Fortunately, we just need to setup associations for <code>UserRegistrationProfile</code> to have <code>create_registration_profile!</code> implemented. But we need to generate the model first:</p>


<p><code>ruby
rails generate model UserRegistrationProfile confirmed_at:datetime confirmation_instructions_sent_at:datetime confirmation_token user_id:integer
</code></p>

<p>let's set up some database constraints in generated migration:</p>


<p>``` ruby</p>

<p>class CreateUserRegistrationProfiles &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :user_registration_profiles do |t|
  t.datetime :confirmed_at
  t.datetime :confirmation_instructions_sent_at
  t.string :confirmation_token
  t.integer :user_id, null: false

  t.timestamps
end

add_index :user_registration_profiles, :user_id
add_index :user_registration_profiles, :confirmation_token, unique: true
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>and then write the associations:</p>


<p>``` ruby app/models/user.rb</p>

<p>class User &lt; ActiveRecord::Base</p>

<p>  has_one :registration_profile, class_name: &ldquo;UserRegistrationProfile&rdquo;, inverse_of: :user</p>

<p>end</p>

<p>```</p>

<p>``` ruby app/models/user_registration_profile.rb</p>

<p>class UserRegistrationProfile &lt; ActiveRecord::Base</p>

<p>  belongs_to :user, inverse_of: :registration_profile</p>

<p>  validates :user, presence: true</p>

<p>end</p>

<p>```</p>

<p>The minimal implementation for <code>Encryption</code> to make the <code>UserRegistration</code> tests happy is the following:</p>


<p>``` ruby app/usecases/encryption.rb</p>

<p>class Encryption</p>

<p>  def generate_password(phrase)
  end</p>

<p>end</p>

<p>```</p>

<p>To finish the user creation we have to implement the password generation. Bcrypt and it's <code>create</code> password method is a reasonable choice here. Let's write the tests:</p>


<p>``` ruby spec/usecases/encryption_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe Encryption do</p>

<p>  subject { Encryption.new }</p>

<p>  let(:password) { &ldquo;password&rdquo; }
  let(:encypted_password) { &ldquo;$2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa&rdquo; }
  let(:password_generator) { class_double(BCrypt::Password).as_stubbed_const }</p>

<p>  before(:each) do</p>

<pre><code>allow(password_generator).to receive(:create).with(password) { encypted_password }
</code></pre>

<p>  end</p>

<p>  it &ldquo;creates password using Bcrypt as default&rdquo; do</p>

<pre><code>expect(subject.generate_password(password)).to eq encypted_password
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The <code>encrypted_password</code> doesn't have to be that long but looks more genuine that way. The BCrypt::Password is also a class double so that we make sure we don't stub a non-existent method. And the implementation of <code>Encryption</code> class:</p>


<p>``` ruby app/usecases/encryption.rb</p>

<p>class Encryption</p>

<p>  attr_reader :password_generator
  private :password_generator</p>

<p>  def initialize(args={})</p>

<pre><code>@password_generator = args.fetch(:password_generator, BCrypt::Password)
</code></pre>

<p>  end</p>

<p>  def generate_password(phrase)</p>

<pre><code>password_generator.create(phrase)
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The pattern for constructor is similar to the one from <code>UserRegistration</code>. The <code>password_generator</code> is also made private - the rule of thumb is that everything should be private unless it needs to be public, just to keep the interfaces clean.</p>




<p>Now we have the basic implementation for user creation with it's profiles. Still, we need confirmation stuff and notification to tje admin. It is beyond the <code>UserRegistration</code> responsibilities, we also don't need always to a notification or confirmation instructions or to confirm user at all, just to have the interface flexible enough. Maybe we will have some additional things that will take place during registration - like third party API notification. To keep the responsibilities separate and <code>UserRegistration</code> easy to use, we can implement all the additional actions as the listeners that are being passed to the constructor of <code>UserRegistration</code>. Let's write specs for it first:</p>


<p>``` ruby spec/usecases/user_registration_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistration do</p>

<p>  # same code a before</p>

<p>  context &ldquo;persistence is success&rdquo; do</p>

<pre><code># same code a before

# and this is new:

context "with listeners" do

  let(:user_confirmation) { double(:user_confirmation, 
    notify: true) }
  let(:admin_notification) { double(:admin_notification,
    notify: true) }

  before(:each) do
    UserRegistration.new(user_confirmation, admin_notification,
      encryption: encryption).register!(form)
  end

  it "notifies user_confirmation listener" do
    expect(user_confirmation).to have_received(:notify).with(user)
  end

  it "notifies admin_notificaiton listener" do
    expect(admin_notification).to have_received(:notify).with(user)
  end

end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>We don't actually care what the listeners are, the only requirement is that they must implement the same interface: <code>notify</code> method which takes <code>user</code> argument. And the implementation:</p>


<p>``` ruby app/usecases/user_registration.rb</p>

<p>class UserRegistration</p>

<p>  class RegistrationFailed &lt; StandardError ; end</p>

<p>  attr_reader :encryption, :listeners
  private :encryption, :listeners</p>

<p>  def initialize(*listeners, **options)</p>

<pre><code>@listeners = listeners
@encryption = options.fetch(:encryption, Encryption.new)
</code></pre>

<p>  end</p>

<p>  def register!(aggregate)</p>

<pre><code>user = aggregate.user
profile = aggregate.profile
user.encrypted_password = encrypted_password(aggregate.password)
ActiveRecord::Base.transaction do
  begin
    user.save!
    profile.save!
    user.create_registration_profile!
  rescue ::ActiveRecord::StatementInvalid, ::ActiveRecord::RecordInvalid =&gt; e
    raise_registration_error(e)
  end
end  
notify_listeners(user)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def raise_registration_error(errors)
  message =  "Registration Failed due to the following errors: #{errors}"      
  raise UserRegistration::RegistrationFailed, message
end

def encrypted_password(password)
  encryption.generate_password(password)
end

def notify_listeners(user)
  listeners.each do |listener|
    listener.notify(user)
  end
end
</code></pre>

<p>end</p>

<p>```</p>

<p>These changes are not that noticeable but they are huge. The constructor now takes some listeners (splat) - we can pass one listener, several or none, it will always be an array. Also, the options is now a keyword argument introduced in Ruby 2.0 which makes the changes really smooth. And the new method: <code>notify_listeners</code> which sends <code>notify</code> message to all the listeners with <code>user</code> argument.</p>




<p>To handle the user confirmation stuff we will need, well, <code>UserConfirmation</code> and <code>UserRegistrationAdminNotification</code> to handle the notifcations.</p>




<p>Let's start with <code>UserConfirmation</code>. We need <code>notify</code> method which will take care of: assigning confirmation token, which must be unique, setting date when the confirmation instructions were sent and sending the instructions. We will need some mailer here (<code>UserConfirmationMailer</code>), clock (<code>DateTime</code>) and something to generate token - <code>SecureRandom</code> will be a good fit here with it's <code>base64</code> method. Let's translate the specification to the tests:</p>


<p>``` ruby spec/factories.rb</p>

<p>FactoryGirl.define do</p>

<p>  # same as before</p>

<p>  factory :user_registration_profile do # this in new here</p>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>``` ruby spec/usecases/user_confirmation_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserConfirmation do</p>

<p>  describe &ldquo;#notify&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user, 
  registration_profile: FactoryGirl.build_stubbed(:user_registration_profile)) }

let(:mailer_stub) { double(:mailer, deliver: true) }

let!(:mailer) { class_double(UserConfirmationMailer,
  send_confirmation_instructions: mailer_stub).as_stubbed_const }

let(:confirmation_instructions_sent_date) { DateTime.new(2014, 2, 23, 21, 0, 0)}
let(:clock) { double(:clock, now: confirmation_instructions_sent_date) }

subject { UserConfirmation.new(mailer: mailer, clock: clock) }

before(:each) do
  allow(user).to receive(:save_with_profiles!)
  allow(SecureRandom).to receive(:base64) { "token" }
  subject.notify(user)
end

it "assigns confirmation token to user" do
  expect(user.confirmation_token).to eq "token"
end

it "sends email with confirmation instructions" do
  expect(mailer).to have_received(:send_confirmation_instructions).with(user)
end

it "sets date when the confirmation instructions have been sent" do
  expect(user.confirmation_instructions_sent_at).to eq confirmation_instructions_sent_date
end

it "persists new data" do
  expect(user).to have_received(:save_with_profiles!)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>Like before, we should start with one test, make it pass and then write the next one. Here is the implementation for it:</p>


<p>``` ruby app/usecases/user_confirmation.rb</p>

<p>class UserConfirmation</p>

<p>  attr_reader :mailer, :clock
  private :mailer, :clock</p>

<p>  def initialize(args={})</p>

<pre><code>@mailer = args.fetch(:mailer, UserConfirmationMailer)
@clock = args.fetch(:clock, DateTime)
</code></pre>

<p>  end</p>

<p>  def notify(user)</p>

<pre><code>assign_confirmation_token(user)
user.confirmation_instructions_sent_at = clock.now
mailer.send_confirmation_instructions(user).deliver
user.save_with_profiles!
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def assign_confirmation_token(user)
  begin
    user.confirmation_token = SecureRandom.base64(20)
  end while User.find_by_confirmation_token(user.confirmation_token).present?
end
</code></pre>

<p>end</p>

<p>```</p>

<p>The pattern for constructor is similar to the previous ones: provide the way to inject dependencies and some defaults if they are not specified so it is more flexible, less coupled and the testing becomes easier as a bonus. We have while loop to ensure the confirmation token is unique amongst users. The <code>find_by_attribute</code> methods are deprecated since Rails 4.0.0 and the <code>activerecord-deprecated_finders</code> will be removed from dependencies in 4.1.0 so we have to implement our own finder method. Here are also some important design decisions - we assign both <code>confirmation_instructions_sent_at</code> and <code>confirmation_token</code> to the user, not the registration profile. How is that? The important question is: do we need to expose that the user has registration profile? What if we change our mind and decide to put this data in "normal" profile, not registration profile? Or we didn't make a decision to create a registration profile at all in a first place and these attributes belonged to the user since the beginning and we later decided to move them to a separated table? From the <code>UserConfirmation</code> perspective, it is just an implementation detail. The <code>save_with_profiles!</code> is provided to make user's data persistence more convenient. We need to implement mailer as well but let's start with user's related stuff.</p>


<p>``` ruby spec/models/user.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe User do</p>

<p>  subject { User.new(email: &ldquo;<a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x65;&#109;&#97;&#x69;&#108;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#x65;&#x6d;&#97;&#105;&#x6c;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a>&rdquo;,</p>

<pre><code>encrypted_password: "password") }
</code></pre>

<p>  describe &ldquo;.find_by_confirmation_token&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.create(:user) }

before(:each) do
  FactoryGirl.create(:user_registration_profile,
    confirmation_token: "token", user_id: user.id)
end

it "finds user with specified confirmation token" do
  expect(User.find_by_confirmation_token("token")).to eq user
end
</code></pre>

<p>  end</p>

<p>  describe &ldquo;#confirmation_token=&rdquo; do</p>

<pre><code>it "assigns confirmation token to user" do
  subject.confirmation_token = "token"
  expect(subject.confirmation_token).to eq "token"
end
</code></pre>

<p>  end</p>

<p>  describe &ldquo;#confirmation_instructions_sent_at=&rdquo; do</p>

<pre><code>it "assigns confirmation instructions sent date to user" do
  date = DateTime.now
  subject.confirmation_instructions_sent_at = date
  expect(subject.confirmation_instructions_sent_at).to eq date
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The <code>find_by_confirmation_token</code> finder method is pretty easy but it involves another table with registration profile so I decided to write test for it. The tests also suggest that we need readers for these attributes, not only the writers. Let's use <code>delegate</code> macro from ActiveSupport for it:</p>


<p>``` ruby app/models/user.rb</p>

<p>class User &lt; ActiveRecord::Base</p>

<p>  # the same code as before</p>

<p>  # new code</p>

<p>  delegate :confirmation_token, :confirmation_instructions_sent_at, :confirmed_at,</p>

<pre><code> to: :registration_profile, allow_nil: true
</code></pre>

<p>  def self.find_by_confirmation_token(token)</p>

<pre><code>joins(:registration_profile)
  .where("user_registration_profiles.confirmation_token = ?", token)
  .first
</code></pre>

<p>  end</p>

<p>  def confirmation_token=(token)</p>

<pre><code>ensure_registration_profile_exists
registration_profile.confirmation_token = token
</code></pre>

<p>  end</p>

<p>  def confirmation_instructions_sent_at=(date)</p>

<pre><code>ensure_registration_profile_exists
registration_profile.confirmation_instructions_sent_at = date
</code></pre>

<p>  end</p>

<p>  def save_with_profiles!</p>

<pre><code>User.transaction do
  save!
  profile.save! if profile
  registration_profile.save! if registration_profile
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def ensure_registration_profile_exists
  build_registration_profile if registration_profile.blank?
end
</code></pre>

<p>```</p>

<p>Before making any assignment, we have to make sure that the registration profile exists. The same applies to the persistence, which is again wrapped in a transaction. And let's implement the mailer for sending confirmation instructions:</p>


<p><code>ruby
rails generate mailer UserConfirmationMailer send_confirmation_instructions
</code></p>

<p>Some basic tests to prove that the mailer actually works:</p>


<p>``` ruby spec/mailers/user_confirmation_mailer_spec.rb</p>

<p>require &ldquo;spec_helper&rdquo;</p>

<p>describe UserConfirmationMailer do</p>

<p>  describe &ldquo;#send_confirmation_instructions&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user, email: "email@example.com",
  registration_profile: FactoryGirl.build_stubbed(:user_registration_profile,
  confirmation_token: "token"))
}

let(:mail) { UserConfirmationMailer.send_confirmation_instructions(user) }

it "has proper subject" do
  expect(mail.subject).to eq("Confirmation Instructions")
end

it "sends email to the user" do
  expect(mail.to).to eq([user.email])
end

it "has link to confirm account" do
  url = "/confirmations/#{user.confirmation_token}"
  expect(mail.body.encoded).to match(url)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The setup with FactoryGirl may seem to be complex but I like doing this kind of setup manually, not to rely on predefined attributes for the factory so that I know where the data comes from. We also assume that there will be some controller action for confirmations so we will need to define routes to make the tests pass:</p>


<p>``` ruby app/mailers/user_confirmation_mailer.rb</p>

<p>  class UserConfirmationMailer &lt; ActionMailer::Base</p>

<p>  default from: &ldquo;<a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#x6e;&#116;&#x61;&#x63;&#x74;&#64;&#x65;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d;">&#x63;&#111;&#x6e;&#116;&#x61;&#99;&#x74;&#x40;&#x65;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a>&rdquo;</p>

<p>  def send_confirmation_instructions(user)</p>

<pre><code>@user = user
mail(to: user.email, subject: "Confirmation Instructions")
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>``` html app/views/user_confirmation_mailer/send_confirmation_instructions.html.erb</p>

<p>To complete the registration process, click the link below:</p>


<p>&lt;%= link_to &ldquo;Confirm&rdquo;, user_confirmation_path(token: @user.confirmation_token) %></p>

<p>```</p>

<p>And the route with a controller action:</p>


<p>``` ruby config/routes.rb</p>

<p>  get &lsquo;/confirmations/:token&rsquo;, to: &ldquo;confirmations#confirm&rdquo;, as: :user_confirmation</p>

<p>```</p>

<p>``` ruby app/controllers/confirmations_controller.rb</p>

<p>class ConfirmationsController &lt; ApplicationController</p>

<p>  def confirm</p>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>And add the listener in <code>UsersController</code>:</p>


<p>``` ruby app/controllers/users_controller.rb</p>

<p>  def create</p>

<pre><code>@registration_form = registration_form.assign_attributes(params[:user])

if @registration_form.valid?
  UserRegistration.new(
    UserConfirmation.new
  ).register!(@registration_form)
  redirect_to root_path, notice: "You have register. Please, check your email for confimartion instructions"
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)   
end
</code></pre>

<p>```</p>

<p>To make all the tests happy, we need some to send a notification to the admin. It looks like <code>UserRegistrationAdminNotification</code> will be just an adapter layer for <code>NewUserAdminNotificationMailer</code> to provide the listener interface. The tests and the implementation are quite simple:</p>


<p>``` ruby spec/usecases/user_registration_admin_notification_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe UserRegistrationAdminNotification do</p>

<p>  describe &ldquo;#notify&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user) }

let(:mailer_stub) { double(:mailer, deliver: true) }

let!(:mailer) { class_double(NewUserAdminNotificationMailer,
  notify: mailer_stub).as_stubbed_const }

subject { UserRegistrationAdminNotification.new(mailer: mailer) }

before(:each) do
  subject.notify(user)
end

it "sends email to admin about new user being registered" do
  expect(mailer).to have_received(:notify).with(user)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The implementation:</p>


<p>``` ruby app/usecases/user_registration_admin_notification.rb</p>

<p>class UserRegistrationAdminNotification</p>

<p>  attr_reader :mailer
  private :mailer</p>

<p>  def initialize(args={})</p>

<pre><code>@mailer = args.fetch(:mailer, NewUserAdminNotificationMailer)
</code></pre>

<p>  end</p>

<p>  def notify(user)</p>

<pre><code>mailer.notify(user).deliver
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>We also need to generate the mailer with <code>notify</code> method (yes, the same as for the listener but it is good enough here):</p>


<p><code>ruby
rails generate mailer NewUserAdminNotificationMailer notify
</code></p>

<p>and the simple implementation to make the tests green:</p>


<p>``` ruby app/mailers/new_user_admin_notification_mailer.rb</p>

<p>class NewUserAdminNotificationMailer &lt; ActionMailer::Base</p>

<p>  default from: &ldquo;<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#99;&#111;&#x6e;&#116;&#97;&#x63;&#x74;&#64;&#x65;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#99;&#111;&#x6e;&#116;&#x61;&#99;&#x74;&#64;&#101;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a>&rdquo;</p>

<p>  def notify(user)</p>

<pre><code>@user = user
mail(to: "admin@example.com", subject: "New User Registration")
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Now the tests for the mailer and we are almost finished with the registration:</p>


<p>``` ruby spec/mailers/new_user_admin_notification_mailer_spec.rb</p>

<p>require &ldquo;spec_helper&rdquo;</p>

<p>describe NewUserAdminNotificationMailer do</p>

<p>  describe &ldquo;#notify&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user, email: "email@example.com") }

let(:mail) { NewUserAdminNotificationMailer.notify(user) }

it "sends email to the admin" do
  expect(mail.to).to eq(["admin@example.com"])
end

it "has link to confimartion in the body" do
  expect(mail.body.encoded).to match(user.email)
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>The views for the mailer:</p>


<p>``` ruby app/views/new_user_admin_notification_mailer/notify.html.erb</p>

<p><p>New user with email: &lt;%= @user.email %> has registered</p></p>

<p>```</p>

<p><p>And the listener for <code>UserRegistrationAdminNotification</code> in <code>UserRegistrationAdminNotification.new</code>:</p></p>

<p>``` ruby app/controllers/users_controller.rb</p>

<p>  def create</p>

<pre><code>@registration_form = registration_form.assign_attributes(params[:user])

if @registration_form.valid?
  UserRegistration.new(
    UserConfirmation.new,
    UserRegistrationAdminNotification.new
  ).register!(@registration_form)
  redirect_to root_path, notice: "You have register. Please, check your email for confimartion instructions"
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, profile: UserProfile.new)   
end
</code></pre>

<p>```</p>

<p><p>Hell yeah, all tests are happy now, we have completed the user registration feature. Let&rsquo;s add account confirmation feature and simple sign in. We don&rsquo;t need acceptance test or integration test in controller for that feature, it&rsquo;s pretty simple and unit test for controller would be enough. We probably need to find user by confirmation token, confirm the account and redirect to some page. Also, we should return 404 error if there&rsquo;s no match for confirmation token. In a real world application it would probably need some expiration date for token and other features but keep in a mind it&rsquo;s just for demonstration purposes, not writing the complete devise-like solution.</p></p>

<p>``` ruby spec/controllers/confirmations_controller_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe ConfirmationsController do</p>

<p>  describe &ldquo;#confirm&rdquo; do</p>

<pre><code>let!(:user) { FactoryGirl.build_stubbed(:user,
  registration_profile: FactoryGirl.build_stubbed(:user_registration_profile,
    confirmation_token: "token")) }
let(:factory) { class_double(User).as_stubbed_const }

before(:each) do
  allow(factory).to receive(:find_by_confirmation_token!)
    .with(user.confirmation_token) { user }
end

it "it confirms user and redirects to root path" do
  expect(user).to receive(:confirm!) { true }
  get :confirm, token: user.confirmation_token
  expect(response).to redirect_to root_path
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>We find the user with bang method so, by convention, it raises ActiveRecord::RecordNotFound if the resource is not found &ndash; we won&rsquo;t write test for the failure path. Then the  <code>confirm!</code> method is used which needs to be implemented and redirect to root path. The implementation for the controller is the following:</p></p>

<p>``` ruby app/controllers/confirmations_controller.rb</p>

<p>class ConfirmationsController &lt; ApplicationController</p>

<p>  def confirm</p>

<pre><code>user = User.find_by_confirmation_token!(params[:token]) 
user.confirm!
redirect_to root_path, notice: "You have confirmed you account. Now you can login."
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>Now we need to implement <code>confirm!</code> and <code>find_by_confirmation_token!</code> methods:</p></p>

<p>``` ruby spec/models/user_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe User do</p>

<p>  subject { User.new(email: &ldquo;<a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#x65;&#109;&#x61;&#105;&#108;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#109;">&#101;&#x6d;&#x61;&#105;&#108;&#x40;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;</a>&rdquo;,</p>

<pre><code>encrypted_password: "password") }
</code></pre>

<p>  # some old code</p>

<p>  describe &ldquo;#confirm!&rdquo; do</p>

<pre><code>let(:date) { DateTime.new(2014, 02, 23, 22, 6, 0) }

before(:each) do
  allow(DateTime).to receive(:now) { date }
  subject.confirm!
end

it "assigns confirmation date with current date" do
  expect(subject.confirmed_at).to eq date
end

it "persists user and the profile" do
  expect(subject.registration_profile.persisted?).to eq true
  expect(subject.persisted?).to eq true
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>It would be quite convenient to use <code>confirm!</code> method for new user and make it persisted. I don&rsquo;t feel a need to write test for <code>find_by_confirmation_token!</code> as it is really simple and will use <code>find_by_confirmation_token</code>.</p></p>

<p>``` ruby app/models/user.rb</p>

<p>class User &lt; ActiveRecord::Base</p>

<p>  def self.find_by_confirmation_token!(token)</p>

<pre><code>user = find_by_confirmation_token(token)
if user.blank?
  raise ActiveRecord::RecordNotFound
else
  user
end
</code></pre>

<p>  end</p>

<p>  def confirm!</p>

<pre><code>ensure_profile_exists
registration_profile.confirmed_at = DateTime.now
save_with_profiles!
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def ensure_registration_profile_exists
  build_registration_profile if registration_profile.blank?
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>It&rsquo;s another method in <code>User</code> model, shouldn&rsquo;t the models be thin? Well, it&rsquo;s not business logic involving some complex actions, these are just domain methods for user to handle it&rsquo;s own state (or the profile&rsquo;s state which is rather an implementation detail in this case), it looks like a model&rsquo;s responsibility so it&rsquo;s a right place to add this kind of logic, much better than using e.g. <code>update</code> method on registration profile outside the models.</p></p>

<p><p>We completed another feature: user can confirm his/her account. There&rsquo;s only one feature left: sign in. Let&rsquo;s test drive it starting from acceptance test again: when the user exists and is confirmed, we let the user sign in, if exists but is not confirmed yet we render proper info and if the email/password combination is invalid we also want to display proper info. Capybara test for these specs may look like this:</p></p>

<p>``` ruby spec/features/sign_in_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>feature &ldquo;Sign In&rdquo; do</p>

<p>  context &ldquo;user is confirmed&rdquo; do</p>

<pre><code>given!(:user) { FactoryGirl.create(:user, 
registration_profile: FactoryGirl.build(:user_registration_profile,
  confirmed_at: DateTime.now)) }

describe "with valid data" do

  background do
    visit sign_in_path
    fill_in_sign_in_form_with_valid_data(user)
    sign_in
  end

  scenario "user signs in and and shows success message" do
    expect(page).to have_content "You have successfully signed in"    
  end

  scenario "after sign in user sees it's email" do        
    expect(page).to have_content user.email  
  end

end

describe "with invalid data" do

  scenario "signin is prohibited and user sees error message
    with wrong email/password combination" do
    visit sign_in_path
    fill_in_sign_in_form_with_invalid_data(user)
    sign_in
    expect(page).to have_content "Wrong email/password combination"    
  end

end
</code></pre>

<p>  end</p>

<p>  context &ldquo;user is not confirmed&rdquo; do</p>

<pre><code>given!(:user) { FactoryGirl.create(:user, 
registration_profile: FactoryGirl.build(:user_registration_profile)) }

background do
  visit sign_in_path
  fill_in_sign_in_form_with_valid_data(user)
  sign_in
end

scenario "signin is prohibited and user sees info about unconfirmed account" do
  expect(page).to have_content "You must confirm your account"    
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>def fill_in_sign_in_form_with_valid_data(user)
  fill_in &ldquo;email&rdquo;, with: user.email
  fill_in &ldquo;password&rdquo;, with: &ldquo;password&rdquo;
end</p>

<p>def fill_in_sign_in_form_with_invalid_data(user)
  fill_in &ldquo;email&rdquo;, with: user.email
  fill_in &ldquo;password&rdquo;, with: &ldquo;wrong_password&rdquo;
end</p>

<p>def sign_in
  click_button &ldquo;Sign in&rdquo;
end</p>

<p>```</p>

<p><p>The structure is similar to the one from registration process: there are some helper methods for filling forms and signing in. For the happy path, we also want to verify that the user is actually signed in so we will display it&rsquo;s email. This test will work because in <code>User</code> factory in <code>spec/factories.rb</code> the <code>encrypted_password</code> value is an encrypted form of &ldquo;password&rdquo; phrase. Let&rsquo;s start from defining routes and creating controller for the user signin:</p></p>

<p>``` ruby config/routes.rb</p>

<p>resources :sessions, except: [:new]</p>

<p>get &lsquo;/sign_in&rsquo;, to: &ldquo;sessions#new&rdquo;, as: :sign_in</p>

<p>```</p>

<p>``` ruby app/controllers/sessions_controller.rb</p>

<p>class SessionsController &lt; ApplicationController</p>

<p>  def new</p>

<p>  end</p>

<p>  def create</p>

<p>  end</p>

<p>```</p>

<p><p>and the view layer:</p></p>

<p>``` ruby app/views/sessions/new.html.haml</p>

<p>= display_messages</p>

<p>%h1 Sign In</p>

<p>= simple_form_for :sign_in, url: :sessions, method: :post do |f|
  = f.input :email, label: &ldquo;email&rdquo;
  = f.input :password, label: &ldquo;password&rdquo;
  = f.submit &ldquo;Sign in&rdquo;</p>

<p>```</p>

<p><p>Where does the <code>display_messages</code> helper comes from? It&rsquo;s a simple helper for displaying flash messages which can be implemented as follows:</p></p>

<p>``` ruby app/helpers/application_helper.rb</p>

<p>module ApplicationHelper</p>

<p>  def display_messages</p>

<pre><code>case
when flash[:notice]
  display_flash_message(flash[:notice], "alert-success")
when flash[:error]
  display_flash_message(flash[:error], "alert-error")
when flash[:alert]
  display_flash_message(flash[:alert], "alert-error")
end
</code></pre>

<p>  end</p>

<p>  def display_flash_message(message, class_name)</p>

<pre><code>content_tag(:div, class: "alert centerize-text #{class_name}") do
  message
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>Let&rsquo;s also update the root page:</p></p>

<p>``` ruby app/views/static_pages/home.html.haml</p>

<p>= display_messages
&ndash; if current_user
  %h1 Welcome
  = current_user.email</p>

<p>```
<p>Let&rsquo;s stick to the convention and name the helper method with current user the <code>current_user</code>. The signin process is already covered by acceptance test so we won&rsquo;t benefit much from writing controller&rsquo;s test. To keep track of current user, we will store it&rsquo;s id in a session. The implementation might be following:</p></p>

<p>``` ruby app/controllers/sessions_controller.rb</p>

<p>class SessionsController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>user = User.find_by(email: sign_in_params[:email])

return wrong_combination_of_email_or_password if user.blank?
return user_not_confirmed if !user.confirmed?

if Authentication.authenticate(user.encrypted_password, sign_in_params[:password])
  sign_in(user)
  redirect_to root_path, notice: "You have successfully signed in"
else
  wrong_combination_of_email_or_password
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def sign_in_params
  params.require(:sign_in).permit(:email, :password)
end

def sign_in(user)
  session[:user_id] = user.id
end

def wrong_combination_of_email_or_password
  flash.now[:error] = "Wrong email/password combination"
  render :new
end

def user_not_confirmed
  flash.now[:error] = "You must confirm your account"
  render :new
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>And for the <code>current_user</code>:</p></p>

<p>``` ruby app/controllers/application_controller.rb</p>

<p>class ApplicationController &lt; ActionController::Base
  # Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  protect_from_forgery with: :exception</p>

<p>  helper_method :current_user</p>

<p>  private</p>

<pre><code>def current_user
  @current_user ||= User.find(session[:user_id]) if session[:user_id].present?
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>The last step is to implement <code>Authentication</code> module with authenticate method, which compares encrypted password with plain password. Let&rsquo;s start with a test:</p></p>

<p>``` ruby spec/usecases/authentication_spec.rb</p>

<p>require &lsquo;spec_helper&rsquo;</p>

<p>describe Authentication do</p>

<p>  describe &ldquo;.authenticate&rdquo; do</p>

<pre><code>let(:encrypted_password) { "$2a$10$bcMccS3q2egnNICPLYkptOoEyiUpbBI5Q.GAKe0or2QB7ij6yCeOa" }

it "returns true if encrypted password is specified password" do
  expect(Authentication.authenticate(encrypted_password,
    "password")).to eq true
end

it "returns false if encrypted password in not specified password" do
  expect(Authentication.authenticate(encrypted_password,
    "wrong_password")).to eq false
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p> I don&rsquo;t need to create an instance of <code>Authentication</code>, there is no need to make it a class. And to make all the tests green we just need to implement comparison of passwords using Bcrypt:</p></p>

<p>``` ruby app/usecases/authentication.rb</p>

<p>module Authentication</p>

<p>  def self.authenticate(encrypted_password, password)</p>

<pre><code>BCrypt::Password.new(encrypted_password) == password
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><h2>Wrapping up</h2></p>

<p><p>That&rsquo;s all! All the tests now pass. And they run pretty fast (on Ruby 2.1.0), about 1.6 s. That was quite long: the user registration, confirmation and sign in features have been test drived and some not obvious design decisions were made. That gives some basic ideas how I apply Test Driven Development / Behavior Driven Development techniques in everyday Rails programming. The aim of these tests wasn&rsquo;t to have 100% coverage (e.g. I didn&rsquo;t test ActiveModel validations, using Reform DSL to make <code>UserRegistrationForm</code> composition, delegations in <code>User</code> model) but they give me sufficient level of confidence to assume that the application works correctly and they helped with some design choices, which is a great advantage of unit tests. When TDDing, keep in mind what Kent Beck says about his way of writing tests:
  <blockquote>I get paid for code that works, not for tests so my philosophy is to test as little as possible to reach a given level of confidence (I suspect this level of confidence is high compared to industry standards but that could just be hubris). If I don&rsquo;t typically make a kind of mistake (like setting the wrong variables in a constructor), I don&rsquo;t test for it.</blockquote>
</p></p>

<p><p class="meta small-p">Changelog: 04-03-2013 &ndash; Add missing code for <code>UserRegistrationAdminNotification</code> implementation.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Structuring Rails applications]]></title>
    <link href="https://karolgalanciak.com/blog/2013/10/06/structuring-rails-applications/"/>
    <updated>2013-10-06T15:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2013/10/06/structuring-rails-applications</id>
    <content type="html"><![CDATA[<p>There've been a lot of discussions recently about applying Object Oriented Programming in Rails applications, how ActiveRecord callbacks make testing painful and how Rails makes it hard to do OOP the right way. Is it really true? Rails makes everything easy - you can easily write terrible code, which will be a maintenance nightmare, but is also easy to apply good practices, especially with available gems. What is the good way then to extract logic in Rails applications and the best place to put it?</p>




<!--more-->


<p></p>

<h2>Standard structure</h2>




<p>By default we have four directories where we can put our code: models, views, controllers and helpers. The basic explanation of them is following:</p>




<ul>  
  <li>Models - dealing with database, validations, repository, persistence.</li>
  <li>Controllers - parsing requests, sessions, rendering views etc.</li> 
  <li>Views - user interface, data presenting.</li>
  <li>Helpers - place to put reusable methods for views.</li>
</ul>




<p>Does it mean these are the only places where you can put your code? No! It's just a default structure with basic parts of your application. You can easily extend it by creating new directories and then adding them to autoload paths, e.g.: </p>


<p><code>ruby
  config.autoload_paths += Dir["#{AppName::Application.config.root}/app/usecases"]
</code></p>

<h2>How about lib directory?</h2>




<p>Unless you are extracting something to a gem, I would discourage you from putting anything there. Some developers put in the lib all the code that doesn't belong to models/controllers/helpers, but if something is part of your application why not add it to the app directory?</p>




<h2>Skinny controllers, fat models</h2>




<p>The design mantra for the last few years in Rails was to move logic from controllers to models. Well, it's partially a good thing - skinny controllers are clear, easy to test and maintain, but why should models be like 1000 lines of code with tens of responsibilities (and no, everything concerning User is not a single responsibility)? It makes models in most cases the most problematic layer in Rails applications. They often include a lot of unrelated methods, conditional validations, cross-models operations, callbacks etc. - all the things that ActiveRecord makes really easy to add. So, the important question is:</p>




<h2>Is ActiveRecord evil?</h2>




<p><p>ActiveRecord is a wonderful ORM, which indeed makes everythings easy. But with great power comes great responsibility. Think about callbacks: you can add new logic in a blink of an eye and it does the job. So you keep adding other callbacks until you discover that there are some cases where you don&rsquo;t want them to be executed. So you add conditionals or bypass-like methods. After some time, the logic in callbacks is so complexed that you waste few hours with other developers to understand why something was executed at all. If other developers join the project, it is even harder for them to understand what model class really does. But it isn&rsquo;t the worst part. Think about some gems and their integration with Rails. Often it means extending models with another callbacks. Here are some real world problems:</p>

<p><p>Imagine the situation where you need to implement the ability for admin to register other users and the application uses Devise gem for authentication. Furthermore, the <code> Confirmable</code> module is included in the <code>User</code>  class. Accidentally, you forgot to pass a date to <code>:confirmed_at</code> field or use <code>confirm!</code>  method. What happens then? The confirmation email is sent to all registered users. Oops, welcome to the wonderful world of callbacks. I don&rsquo;t want to criticize Devise, because it is a great gem, which I use in almost every project, but I am not sure if sending emails being directly coupled to the model layer was a good design decision. In docs you can read about the <code>skip_confirmation!</code> method and if you use external gem for such a critical part of your application, you should read the entire docs, but it can be really suprising, that the confirmation email is sent in all cases, even if you create user from Rails Console. Oh, and guess what happens if you want to change one&rsquo;s email from the console and <code> reconfirmable</code> option is enabled? The confirmation email is sent&hellip; Well, remember about reading docs, especially when the gem may include callbacks.</p></p>

<p><p>Any other examples? Of course. So, you want to implement a generic forum. There is a gem called Forem, which provides you with basic forum functionality. And one day you want to change state of some posts to be approved. So you enter Rails Console and using <code> update</code>  or <code>update_attributes</code> you perform the update. What happens then? There is a callback in <code>Forem::Post</code>  model:</p></p>

<p><code>ruby
  after_save :email_topic_subscribers, :if =&gt; Proc.new { |p| p.approved? &amp;&amp; !p.notified? }
</code></p>

<p><p>A lot of emails have been just sent! That was really unexpected. If you are used to  skipping callbacks in such situatons by using <code>update_columns</code> method or any other way, you are safe, but callbacks are so tighly coupled to models, that you cannot be sure if you are safe, even in console. What is the conslusion? Beware of callbacks. And read docs and code of the gems you use :).</p></p>

<p><p>So, how to avoid unexpected situations and have clean and understandable code?</p></p>

<p><h2>Structuring Rails applications &ndash; my way</h2></p>

<p><p>I&rsquo;ve been working on several projects and the best solution in terms of maintenance, understandability and ease of testing is the following:</p></p>

<p><h3>Models</h3></p>

<p><p>I use models for: factory methods, queries, scopes, general validations, which are always applicable e.g. presence and uniqueness validations for fields with <code>null: false</code>  and / or <code>unique: true</code> constraints, also &ldquo;domain constraints&rdquo;, especially with many-to-many associations. The example of domain constraint is assigning users, who belong to the same organization, to some subgroups &ndash; assigning users from other organizations is prohibited. Putting this kind of logic in controllers' before_filters or permission classes is not enough for me, I want to ensure the integrity of the data and make it impossible to bypass this restriction. Here is an example: we have <code>User</code>  model and <code>Group</code> model and the many-to-many relationship between them, which is established by <code>has_many , through: </code> macro with <code>GroupsUsers</code>  join model. Also, users and groups belong to <code>Organization</code>. Here is a validation for creating relation in join model:</p></p>

<p>``` ruby
class GroupsUsers &lt; ActiveRecord::Base</p>

<p>  belongs_to :group
  belongs_to :user</p>

<p>  validates :group, presence: true
  validates :user,  presence: true
  validate :ensure_valid_organization</p>

<p>  private</p>

<pre><code>def ensure_valid_organization
  if user.organization != group.organization
    raise InvalidOrganizationError, "User's organization does not match Group's organization."
  end
end
</code></pre>

<p>end
```
<p>Other example of domain constraint is validation of inclusion.</p></p>

<p><p>Sometimes I do use callbacks. The basic rule when applying callbacks for me is to use them for processing some data, which should always take place. In most cases, it is limited to three callbacks:</p></p>

<p><code>ruby
before_save   :create_parameterized_name
after_save    :calculate_statistics
after_destroy :calculate_statistics
</code></p>

<p><p>Pretty easy to understand: everytime the record is saved, I want to have parameterized form of name, e.g. for a slug. Also, after the record is saved or destroyed, I want the statistics to be updated. For instance, in real estate search engine application, investment has many apartments and I want to keep track of total count of apartments, average price, minimum and maximum price etc. without performing calculations each time. And one more callback concerning associations: <code>dependent: :destroy</code>  option. It is pretty useful and keeps the integrity of data, but you have to be sure when using it. If you think for a moment, these are &ldquo;low-level&rdquo; callbacks &ndash; they don&rsquo;t concern business logic and are something that you would like to have on a database level. It can be also achieved by using trigger functions in the database, but Rails callbacks are much easier to handle.</p></p>

<p><p>This is not the only right way for using callbacks, if you are absolutely sure that something should really be executed as callback, feel free to use them, but please, don&rsquo;t send notifications, don&rsquo;t connect with Facebook API or download files from Dropbox in callbacks. You will be safe, the logic will be easy to understand and testing will be much easier.</p></p>

<p><p>Sometimes I use model as an interface for some service objects / usecases / whatever you call it. Here is an example: </p></p>

<p>``` ruby
class Article &lt; ActiveRecord::Base</p>

<p>  def publish(publisher = DefaultPublisher)</p>

<pre><code>publisher.new(self).publish
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><p>It is a great way to have a flexibility in publishing articles &ndash; by dependency injection we can control, how it is being published &ndash; just pass publisher class as a strategy. Having default publisher makes it easy to use: just call <code>article.publish</code> . Also, calling <code>article.publish</code> in e.g. controller feels much better than calling <code>DefaultPublisher(article).publish</code>. If you have very simple logic, like this one:</p></p>

<p><code>ruby
def publish
  self.published_at = DateTime.now if self.published_at.blank?
  self.save
end
</code></p>

<p><p>don&rsquo;t bother with extracting it to external class, it would be pointless.</p></p>

<p><h3>Controllers</h3></p>

<p><p>Everything related to parsing requests, sessions, rendering templates, redirecting and flash messages should be put in controllers. What about application logic? In most cases it should be limited to a control-flow, for example:</p></p>

<p>``` ruby
class ArticlesController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>@article = Article.find(params[:id])

if @article.save
  flash[:notice] = "You have successfully created an article."
  redirect_to articles_path
else
  render :new
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><p>Depending on the action, it could be much more complex. Consider the following:</p></p>

<p>``` ruby</p>

<p>class OrdersController &lt; ApplicationController</p>

<p>  def buy</p>

<pre><code>order = Order.new(order_params)
order_proccesor = BooksOrderProcessor.new(order, current_user)

begin
  order_processor.pay
rescue BooksOrderProcessor::InsufficientAmount
  flash.now[:error] = "Not enough books are available."
  render :new
rescue BooksOrderProcessor::InsufficientFounds
  flash[:error] = "You have run out of funds."
  redirect_to profile_path(current_user)
else
  flash[:notice] = "You have bought a book."
  redirect_to books_path
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def order_params
  params.require(:order).permit!
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>It is still good, such control-flow can take place in a controller, but order processing logic cannot. But what should be done with creating articles and sending notification or logging action? If it is only one additional line of code with method call like <code>Tracker.register(&ldquo;create&rdquo;, @article)</code> or <code>NewArticleNotfier.delay.notify</code>, for example:</p></p>

<p>``` ruby</p>

<p>class ArticlesController &lt; ApplicationController</p>

<p>  def create</p>

<pre><code>@article = Article.find(params[:id])

if @article.save
  NewArticleNotfier.delay.notify
  flash[:notice] = "You have successfully created an article."
  redirect_to articles_path
else
  render :new
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```
<p>don&rsquo;t extract it to usecase or service object, it is ok to keep it in a controller.</p></p>

<p><h3>Cells</h3></p>

<p><p>You have probably had many situations with setting up the same instance variables in several controller actions for some widgets like: tags cloud, recent articles, recent comments, top visited articles etc. and it can be really inconvenient. Fortunately, there&rsquo;s a great gem: Cells, which are like mini controllers. Consider the following:</p></p>

<p>``` ruby
class ArticlesCell &lt; Cell::Rails</p>

<p>  def top_visited</p>

<pre><code>@articles = Article.top_visited
render
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>In cells/articles/top_visited.html.haml/erb you put the related markup and invoke cells from views by:</p>

<p>``` ruby</p>

<p>= render_cell :articles, :top_five</p>

<p>```</p>

<p><p>Another great thing about cells is that you can inject a dependency: </p></p>

<p><code>ruby
= render_cell :widgets, :newsletter, newsletter_form: @newsletter_form
</code></p>

<p><p>You can easily create a widget with newsletter submission form with enabled remote: true option and then render error messages or notice message that the email has been submitted.</p></p>

<p><h3>Helpers</h3></p>

<p><p>In most cases I use helpers to extract some things that aren&rsquo;t related to any particular model &ndash; rendering flash messages, titles, html templates etc., so nothing really fancy. Everything else should be extracted to the presenters/decorators. The good example of helper is the following:</p></p>

<p>``` ruby
def section_marker(text)
  content_tag(:h2, class: &ldquo;section-marker&rdquo;) do</p>

<pre><code>"&lt;i class='icon-align-left'&gt;&lt;/i&gt; #{text}".html_safe
</code></pre>

<p>  end
end
```</p>

<p><p>Before each section I had to insert header with nested icon and some text, so instead of writing the same thing several times, I extracted it to a helper, which is much cleaner. It doesn&rsquo;t belong to any model, so helper is a good place to put this kind of code. If you use Boostrap a lot, you may consider writing <code>modal_activator</code> method:</p></p>

<p><code>ruby
def modal_activator(text, path, options)
  link_to(text, path, options.merge(role: "button", "data-toggle" =&gt; "modal"))
end
</code></p>

<p><h3>Presenters/Decorators</h3></p>

<p><p>Helpers aren&rsquo;t the best place to extract logic related to models &ndash; the code in helpers tends to be messy and difficult to maintain and test. The good solution would be to use Presenters &ndash; objects that encapsulate presentation logic in a neat way. There&rsquo;s a gem that is perfect for this kind of problems: Draper. Just create a decorator class, like <code>UserDecorator</code>: </p></p>

<p>``` ruby
class UserDecorator &lt; Draper::Base</p>

<p>  delegate_all
  decorates :user</p>

<p>  def link_to_edit</p>

<pre><code>h.link_to("Edit", user_path(model))
</code></pre>

<p>  end</p>

<p>  def full_name</p>

<pre><code>if model.name.present? and model.surname.present?
  "#{model.name} #{model.surname}"
end
</code></pre>

<p>  end</p>

<p>  def display</p>

<pre><code>full_name || model.email
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>Looks great! You don&rsquo;t have to keep presentation logic in helpers or even worse in models.
You have an access to Rails helpers via h, also all method calls are delegated to model if it isn&rsquo;t implemented in a decorator. To decorate model just use <code>decorate</code> method:</p></p>

<p><code>ruby
@user = User.find(params[:id]).decorate
</code></p>

<p><p>You can also decorate collection by using <code>decorate</code> method.</p></p>

<p><h3>Forms</h3></p>

<p><p>Imagine a situation where you need a form concerning more than one model. Also, some conditional validation is required. What would you do? Probably use nested attributes and add some complex validations, which would make model messy and maybe cause some bugs. There&rsquo;s much better way to do it: use form object and Reform gem. Then you can create following objects:</p></p>

<p>``` ruby
require &lsquo;reform/form/coercion&rsquo;
require &lsquo;reform/rails&rsquo;</p>

<p>class UserRegistrationForm &lt; Reform::Form</p>

<p>  include DSL
  include Reform::Form::ActiveRecord
  include Reform::Form::Coercion</p>

<p>  properties [:email, :name, :country_id],  on: :user
  property :birth_date,        on: :user_profile, type: Date
  properties [:age, :photo],   on: :user_profile</p>

<p>  validates :email, :photo, :birth_date, :name, :age, presence: true
  validates :age, numericality: true
  validates :email, uniqueness: { case_sensitive: false }</p>

<p>  model :user</p>

<p>  def countries_collection</p>

<pre><code>Country.all.pluck(:id, :name)
</code></pre>

<p>  end</p>

<p>  def persist!(params)</p>

<pre><code>if validate(params)
  begin
    save do |data, map|
      UserRegistration.new.register!(
        User.new(map[:user]),
        UserProfile.new(map[:user_profile])
      )
    end
  rescue UserRegistration::RegistrationFailed
    false
  end
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>By using Reform gem, you can easily create clean form objects, which would deal with validations, coercions (thanks to Virtus) and persisting data concerning multiple models. Also, you can put some form interface logic here &ndash; consider <code>countries_collection</code> method: instead of passing: <code>collection: Country.all.pluck(:id, :name)</code> to the select field, you can just pass <code>form_object.countries_collection</code>. This example is trivial, but if you had some filtering and ordering logic needed to display collection, then it would be great way to keep everything clean. Using form objects doesn&rsquo;t change control-flow in controllers:</p></p>

<p>``` ruby
class UsersController &lt; ApplicationController</p>

<p>  def new</p>

<pre><code>@registration = registration_form
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>@registration = registration_form

if @registration.persist!(user_params)
  redirect_to root_path
else
  render :new
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def registration_form
  UserRegistrationForm.new(user: User.new, user_profile: UserProfile.new)
end

def user_params
  params.require(:user).permit!
end
</code></pre>

<p>end
```</p>

<p><p>Form objects are also great way to extract search forms and logic related to filtering. Reform can deal with <code>has_many</code> associations and nested collections, so it is pretty powerful. However, there are some cases where you would still want to use <code>accepts_nested_attributes_for</code> &ndash; when you need funcionality provided by nested_form gem. It is not really clean to use <code>accepts_nested_attributes_for</code> macro, but the benefits are great. In other cases, form object is a way to go.</p></p>

<p><h3>Uploaders</h3></p>

<p><p>For file uploading I use Carrierwave where the uploaders' configuration is kept in the /uploaders directory. That&rsquo;s a really good approach, because thumb-processing strategy etc. has nothing to do with ActiveRecord model, so there&rsquo;s no reason to keep this kind of information there. Here is an example of general uploader:</p></p>

<p>``` ruby
class ApplicationUploader &lt; CarrierWave::Uploader::Base</p>

<p>  include CarrierWave::MiniMagick</p>

<p>  storage :file</p>

<p>  CarrierWave::SanitizedFile.sanitize_regexp = /[^[:word:].-+]/</p>

<p>  def store_dir</p>

<pre><code>"system/#{Rails.env}/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"
</code></pre>

<p>  end</p>

<p>  def extension_white_list</p>

<pre><code>%w(jpg jpeg gif png pdf tiff tif eps bmp ps)
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def rgbify
  begin
    manipulate! do |img|  
      img.colorspace "sRGB"
      img
    end
  end
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>And example of some images uploader:</p></p>

<p>``` ruby</p>

<p>class LogoUploader &lt; ApplicationUploader</p>

<p>  def filename</p>

<pre><code>"original.#{model.logo.file.extension}" if original_filename
</code></pre>

<p>  end</p>

<p>  version :thumb do</p>

<pre><code>process :rgbify
process :resize_to_fill =&gt; [100, 100]
process :convert =&gt; 'jpg'
def full_filename(for_file)
  "thumb.jpg"
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p><p>Looks great and doesn&rsquo;t clutter models with unrelated image-processing configuration options.</p></p>

<p><h3>Services</h3></p>

<p><p>You may expect that in /services directory so called service-objects would be placed. Well, not really. I prefer to call them (service objects) usecases and in /services I put some wrappers concerning third party APIs. In one application I&rsquo;ve been working on, I had to deal with Google Calendar integration and the adapter layer for performing requests to GC was a service, for instance:</p></p>

<p>``` ruby</p>

<p>module GoogleCalendar
  class Calendars</p>

<pre><code>attr_reader :client
def initialize(client)
  @client = client
end

#some other methods

def patch(calendar_id, calendar_data)
  client.execute(api_method: client.service.calendars.patch), body: calendar_data,
    parameters: { "calendarId" =&gt; calendar_id }, headers: {'Content-Type' =&gt; 'application/json'})      
end
</code></pre>

<p>  end<br/>
end</p>

<p>```</p>

<p><p>In smaller applications you won&rsquo;t probably need this layer, otherwise it is a neat way to separate services from the rest of the application.</p></p>

<p><h3>Usecases</h3></p>

<p><p>This is a place where most of the business logic should be extracted &ndash; almost everything that would be in models, according to &ldquo;skinny controllers, far models&rdquo;. The benefits of using usecase objects / service objects are great &ndash; they area easy to undestand and maintain, testing is simple and don&rsquo;t lead to unexpected actions (like the ones I pointed out in callbacks). Let&rsquo;s take a look again at the user registration process from form object, the implementation of <code>UserRegistration</code> could be following:</p></p>

<p>``` ruby</p>

<p>class UserRegistration</p>

<p>  attr_reader :admin_notifier, :external_service_notifier
  def initialize(notifiers = {})</p>

<pre><code>@admin_notifier = notifiers.fetch(:admin_notifier) { AdminNotifier.new }
@external_service_notifier = notifiers.fetch(:external_service_notifier) { ExternalServiceNotifier.new }
</code></pre>

<p>  end</p>

<p>  def register!(user, profile)</p>

<pre><code>profile.user = user
ActiveRecord::Base.transaction do
  begin
    user.save!
    profile.save!
  rescue
    raise UserRegistration::RegistrationFailed
  end
end
notify_admin
notify_external_service
</code></pre>

<p>  end</p>

<p>  def notify_admin</p>

<pre><code>admin_notifier.notify(user)
</code></pre>

<p>  end</p>

<p>  def notify_external_service</p>

<pre><code>external_service_notifier.new_user(user, profile)
</code></pre>

<p>  end</p>

<p>  class RegistrationFailed &lt; Exception
  end</p>

<p>end</p>

<p>```</p>

<p><p>Let&rsquo;s discuss some design choices here: in the constructor I added a possibility to inject some notifiers and provide reasonable defaults using <code>Hash#fetch</code> method to avoid nils. In <code>register</code> method I wrap the persistence process in <code>ActiveRecord::Base.transaction</code>, to ensure that user is not created without the profile if any error occurs (notice the bang methods), if it fails, the exception is raised. Then, some notifiers are called, one is a mailer, the other one connects with an external service and does some stuff. They should be executed asynchronously, in Delayed Job, Resque or Sidekiq to make sure they are completed if failure occurs &ndash; there might be a temporary problem with connecting to Gmail, Facebook, Twitter etc. but it&rsquo;s not a reason for an entire registration process to fail.</p></p>

<p><h3>Policies</h3></p>

<p><p>Policy objects are a bit special &ndash; it&rsquo;s a decorator, but Draper decorators are not the best place to put them, because they concern presentation logic. Models, except small applications, are also wrong place to write policy logic as they encapsulate important domain logic which can be quite complex. So it is a good idea to create separate objects &ndash; policy objects. Depending on the size of your application, you may have several policy objects or just one for a model, here is an example:</p></p>

<p>``` ruby</p>

<p>class InvestmentPromotionPolicy</p>

<p>  attr_reader :investment, :clock
  def initialize(investment, clock = DateTime)</p>

<pre><code>@investment = investment
@clock = clock
</code></pre>

<p>  end</p>

<p>  def promoted?</p>

<pre><code>valid_promotion_date? and owner_promotable?
</code></pre>

<p>  end</p>

<p>  def owner_promotable?</p>

<pre><code>investment.owner.active_for_promotion?
</code></pre>

<p>  end</p>

<p>  def promotion_status</p>

<pre><code>case
when promoted?
  :promoted
when valid_promotion_date? and !owner_promotable?
  :pending_for_promotion
else
  :not_promoted
end
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def valid_promotion_date?
  (investment.promotion_starts_at..investment.promotion_ends_at).cover? clock.now
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>In the constructor I pass an investment and the clock, which by default is <code>DateTime</code>. I had some issues with concept of time, especially in policy objects where I had to implement own <code>Clock</code>, because <code>DateTime</code> was not sufficient, so just to be on a safe side, I add a possibility for a dependency injection. It doesn&rsquo;t increase a complexity of the class and I wouldn&rsquo;t consider it as a premature optimization. Then we have some methods that encapsulate promotion logic and one that returns proper status. You will probably use policy objects in many cases &ndash; e.g. <code>promotion_status</code> method looks like it could be used in a presenter, which would display proper content, depending on the returned status and the <code>promoted?</code> method could be used in the usecases or in a model class method that would return promoted investments. You can use policy objects in many ways: inject into a model and delegate method calls:</p></p>

<p>``` ruby</p>

<p>class Investment &lt; ActiveRecord::Base</p>

<p>  delegate :promoted?, :owner_promotable?, :promotion_status to: :promotion_policy</p>

<p>  # some methods</p>

<p>  private</p>

<pre><code>def promotion_policy
  @promotion_policy ||= InvestmentPromotionPolicy.new(self)
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>In the same way you can use them in presenters if you don&rsquo;t want to keep it in the model layer. They can also be injected as a dependency into a usecase. Choose whatever suits you better and the complexity of the application.</p></p>

<p><h3>Value objects</h3></p>

<p><p>In many applications you may encounter a situation where a concept deserves own abstraction and whose equality isn&rsquo;t based on identity but on the value, some examples would be Ruby&rsquo;s <code>Date</code> or <code>Money</code> concept, typical for e-commerce applications. Extraction to a value object (or domain model) is a great convenience. Imagine a situation where you have a hierarchy of roles of users &ndash; you will probably want to compare the roles if one is &ldquo;greater&rdquo; than another to decide, if some action can be performed &ndash; the <code>RoleRank</code> would solve this problem:</p></p>

<p>``` ruby</p>

<p>class RoleRank</p>

<p>  include Comparable</p>

<p>  ROLES = %w(superadmin admin junior_admin user guest)</p>

<p>  attr_reader :value
  def initialize(role)</p>

<pre><code>check_role_existence(role)
@value = value
</code></pre>

<p>  end</p>

<p>  def &lt;=>(other_role)</p>

<pre><code>ROLES.index(other_role.value) &lt;=&gt; ROLES.index(value)
</code></pre>

<p>  end</p>

<p>  def to_s</p>

<pre><code>value
</code></pre>

<p>  end</p>

<p>  class InvalidRole &lt; Exception
  end</p>

<p>  private</p>

<pre><code>def check_role_existence(specified_role)
  unless ROLES.include? specified_role
    raise RoleRank::InvalidRole, "Specified Role Doesn't Exist"
  end
end
</code></pre>

<p>end</p>

<p>```</p>

<p><p>Looks great. The <code>Comparable</code> module and <code>&lt;=></code> takes care of implementing comparison operators. You can add a method with ranked role to the user model: </p></p>

<p>``` ruby
class User &lt; ActiveRecord::Base</p>

<p>  def role</p>

<pre><code>@role ||= RoleRank.new(permission_level)
</code></pre>

<p>  end</p>

<p>end
```</p>

<p><p>and then compare users' roles:</p></p>

<p><code>ruby
user = User.new(permission_level: "superadmin")
other_user = User.new(permission_level: "admin")
user.role &gt; other_user.role =&gt; true
</code>
<h3>What about Observers and Concerns?</h3></p>

<p><p>There are two more ways to extract logic &ldquo;the standard way&rdquo;: observers (removed from Rails 4) and concerns. Observers aren&rsquo;t really different from callbacks, except they are more difficult to deal with &ndash; you will probably forget that you&rsquo;ve used them and debugging or following the application logic would be even harder than in callbacks and I&rsquo;m glad they were removed. And the new thing in Rails 4: concerns. They are great, expecially for shared behaviour. When you need to parameterize field name in several models, you can extract it to a module in concerns, and then include Parameterizable concern, some custom finders and factory methods also can be extracted into concerns. If you use the same before_filters in more than controller, extracting them to the concerns would be a good idea. In Presenters, such concern as <code>Presenters::Publishable</code> would be beneficial when you have articles, posts and some other models that act in a similar way, so introducing concerns and encouragement to extract similar behaviour was definitely a good idea.</p></p>

<p><h3>Any other application layers?</h3></p>

<p><p>Depending on your application, you may introduce additional layers like JSON representations of models, jobs that should be done in a background or XML importers, but they can be considered as presentation logic (jsons) or usecases / services (importers, background jobs). If XML importers are important part of your business logic, then maybe extracting them from usecases and treating in a special way would be beneficial.</p></p>

<p><h2>Wrapping up</h3></p>

<p><p>The concepts mentioned here might not be popular among some developers and be considered as over-engineering. When writing simple CMS, introducing services, form objects etc. probably is a premature optimization and models / contollers / helpers and maybe presenters would be sufficient, including writing business logic in ActiveRecord callbacks. But in more complex application applying some OOP techniques can save you (and other developers you work with) from a lot of problems.</p></p>

<p><h2>Further reading</h2></p>

<p><ul>
  <li><a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models" target="_blank">7 Patterns to Refactor Fat ActiveRecord Models</a></li>
  <li><a href="http://samuelmullen.com/2013/05/the-problem-with-rails-callbacks/" target="_blank">The Problem With Rails Callbacks</a></li>
  <li><a href="http://blog.steveklabnik.com/posts/2011-09-06-the-secret-to-rails-oo-design" target="_blank">The Secret to Rails OO Design</a></li>
  <li><a href="http://objectsonrails.com" target="_blank">Objects On Rails</a></li>
  <li><a href="http://solnic.eu/2011/08/01/making-activerecord-models-thin.html" target="_blank">Making ActiveRecord Models Thin</a></li>
  <li><a href="http://blog.arkency.com/2013/09/services-what-they-are-and-why-we-need-them/" target="_blank">Services &ndash; what are they and why we need them?</a></li>
</ul></p>

<p><p class="meta small-p">Changelog: 09-10-2013 &ndash; Use <code>Comparable</code> module and <code>&lt;=></code> method for implementing comparison operators in RankedRole. Provide better example in <code>OrdersController</code>. Thanks <a href="http://www.reddit.com/user/yxhuvud" rel="nofollow" target="_blank">yxhuvud</a> for suggestions.</p></p>
]]></content>
  </entry>
  
</feed>
