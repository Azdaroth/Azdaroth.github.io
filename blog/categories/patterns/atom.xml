<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Patterns | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/patterns/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2018-09-29T15:41:00+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Keeping Data Integrity In Check: Conditional Unique Indexes For Soft Delete]]></title>
    <link href="https://karolgalanciak.com/blog/2016/11/01/keeping-data-integrity-in-check-conditional-unique-indexes-for-soft-delete/"/>
    <updated>2016-11-01T00:30:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2016/11/01/keeping-data-integrity-in-check-conditional-unique-indexes-for-soft-delete</id>
    <content type="html"><![CDATA[<p><strong>Soft delete</strong> is a pretty common feature in most of the applications. It may increase complexity of the queries, nevertheless, not deleting anything might be a <strong>right default</strong> as the data might prove to be useful in the future: for restoring if a record was removed by mistake, to derive some conclusions based on statistics and plenty of other purposes. It may seem like it's a pretty trivial thing: just adding a column like <code>deleted_at</code> and filtering out records that have this value present. But what happens when you need to do some proper <strong>uniqueness validation</strong> on both model layer and database level? Let's take a look what kind of problem can easily be overlooked and how it can be solved with a <strong>conditional index</strong>.</p>




<!--more-->




<h2>Case study: daily prices for vacation rentals</h2>




<p>Let's imagine we are developing a <strong>vacation rental</strong> software. Most likely the pricing for each day will depend on some complex set of rules, but we may want to have some denormalized representation of base prices for each day to make things more obvious and have some possiblity of sharing this kind of data with other applications, which is quite common in this domain. We may start with adding a <code>DailyPrice</code> model having a reference to a <code>rental</code>, having <code>price</code> value and of course <code>date</code> for which the price is applicable.</p>




<h2>Ensuring uniqueness</h2>




<p>Obviously, we don't want to have any duplicated <code>daily_prices</code> for any rental, so we need to add a uniqueness validation for <code>rental_id</code> and <code>date</code> attributes:</p>


<p><code>ruby app/models/daily_price.rb
validates :rental_id, presence: true, uniqueness: { scope: :date }
</code></p>

<p>To ensure <strong>integrity of the data</strong> and that we are protected against race conditions and potental validation bypassing, we need to add a <strong>unique index</strong> on the database level:</p>


<p><code>ruby db/migrate/20161030120000_add_unique_index_for_daily_prices.rb
  add_index :daily_prices, [:rental_id, :date], unique: true
</code></p>

<h2>Adding soft delete functionality</h2>




<p>We have some nice setup already. But it turned out that for recalculating <code>daily_prices</code> if some rules or values influencing the price change it's much more convenient to just remove them all and recalculate from scratch than checking if the price for given date needs to be recalculated. To be on the safe side, we may decide not to hard remove these rates, but do a soft delete instead.</p>




<p>To implement this feature we could add <code>deleted_at</code> column, drop the previous index and a new one which will respect the new column. We should also update the validation in model in such case:</p>


<p><code>ruby app/models/daily_price.rb
validates :rental_id, presence: true, uniqueness: { scope: [:date, :deleted_at] }
</code></p>

<p>And the migration part:</p>


<p><code>ruby db/migrate/20161030120000_add_deleted_at_to_daily_prices.rb
  remove_index :daily_prices, [:rental_id, :date], unique: true
  add_column :daily_prices, :deleted_at, :datetime
  add_index :daily_prices, [:rental_id, :date, :deleted_at], unique: true
</code></p>

<p>Everything should be fine with that, right? What could possibly go wrong here?</p>




<h2>Adding index the right way</h2>




<p>Let's play with Rails console and check it out:</p>


<p>``` ruby</p>

<blockquote><p>time_now = Time.current
 => Sun, 23 Oct 2016 09:44:46 UTC +00:00
DailyPrice.create!(price: 100, date: Date.current, rental_id: 1, deleted_at: time_now)
  COMMIT
DailyPrice.create!(price: 100, date: Date.current, rental_id: 1)
  COMMIT
DailyPrice.create!(price: 100, date: Date.current, rental_id: 1)
  ROLLBACK
ActiveRecord::RecordInvalid: Validation failed: Rental has already been taken
```</p></blockquote>

<p>Nah, there can't be any problem, looks like we have the expected behaviour - we couldn't create a non-soft-deleted <strong>daily_price</strong> for given date and rental. But let's check one more thing:</p>


<p>``` ruby</p>

<blockquote><p>price = DailyPrice.new(price: 100, date: Date.current, rental_id: 1)
price.save(validate: false)
  COMMIT
```</p></blockquote>

<p>Whoops! Something looks very wrong here. But how is it possible? The index looks exactly like the validation in our model, yet it didn't work like that when we bypassed the validation.</p>




<p>Let's consult <strong>PostgreSQL</strong> <a href="https://www.postgresql.org/docs/9.0/static/indexes-unique.html" target="_blank">docs</a>. There is something mentioned about null values: </p>


<p><blockquote><p>Null values are not considered equal</p></blockquote></p>

<p>That is our problem: ActiveRecord considered it as a unique value, but it doesn't work quite like that in <strong>PostgreSQL</strong>.</p>




<p>Our index should be in fact <strong>conditional</strong> and look the following way:</p>


<p><code>ruby
add_index :nightly_rates, [:rental_id, :date], unique: true, where: "deleted_at IS NULL"
</code></p>

<p>We could optionally improve the validation in our model to make it look much closer to what we have in database and use <code>conditions</code> option:</p>


<p><code>ruby app/models/daily_price.rb
validates :rental_id, presence: true, uniqueness: { scope: :date, conditions: -&gt; { where(deleted_at: nil) } }
</code></p>

<p>And that's it! There's no way we could compromise <strong>data integrity</strong> now!</p>




<h2>Wrapping Up</h2>




<p>Keeping data integrity in check is essential for most of the applications to not cause some serious problems, especially when implementing soft delete. Fortunately, simply by adding PostgreSQL conditional unique indexes we can protect ourselves from such issues.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[When validation is not enough: PostgreSQL triggers for data integrity]]></title>
    <link href="https://karolgalanciak.com/blog/2016/05/06/when-validation-is-not-enough-postgresql-triggers-for-data-integrity/"/>
    <updated>2016-05-06T19:45:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2016/05/06/when-validation-is-not-enough-postgresql-triggers-for-data-integrity</id>
    <content type="html"><![CDATA[<p>Is <strong>validation</strong> in your models or form objects enough to ensure <strong>integrity of the data</strong>? Well, seems like you can't really persist a record when the data is <strong>not valid</strong> unless you intentionally try to bypass validation using <code>save: false</code> option when calling <code>save</code> or using <code>update_column</code>. What about <strong>uniqueness validation</strong>?
A classic example would be a unique <code>email</code> per user. To make sure the email is truly unique we could add a unique index in database - not only would it prevent saving non-unique users when <strong>bypassing validation</strong>, but also it would raise extra error when 2 <strong>concurrent requests</strong> would attempt to save user with the same email. However, some validations are more complex that ensuring  a value is unique and index won't really help much. Fortunately, PostgreSQL is powerful enough to provide a perfect solution to such problem. Time to meet your new friend: <strong>PostgreSQL triggers</strong>.</p>




<!--more-->




<h2>Anatomy of PostgreSQL triggers and procedures</h2>




<p>PostgreSQL trigger is like a callback: it's a function that is called on specific event: <code>before</code> or <code>after</code> <code>insert</code>, <code>update</code>, <code>delete</code> or <code>truncate</code> in case of tables and views and for views you can also run a function <code>instead of</code> those events. Triggers can be run either <code>for each row</code> (tables only) and <code>for each statement</code> (both tables and views). The difference between them is quite simple: <code>for each row</code> is run for every modified row and <code>for each statement</code> is run only once per statement. The important thing to keep in mind regarding <code>for each row</code> is that you have a reference to the row being modified, which will be essential in upcoming example.</p>




<p>By running <code>\h CREATE TRIGGER;</code> from <strong>psql</strong> we can get a generalized syntax for creating triggers:</p>


<p>```
Command:     CREATE TRIGGER
Description: define a new trigger
Syntax:
CREATE [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR &hellip; ] }</p>

<pre><code>ON table_name
[ FROM referenced_table_name ]
[ NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } ]
[ FOR [ EACH ] { ROW | STATEMENT } ]
[ WHEN ( condition ) ]
EXECUTE PROCEDURE function_name ( arguments )
</code></pre>

<p>where event can be one of:</p>

<pre><code>INSERT
UPDATE [ OF column_name [, ... ] ]
DELETE
TRUNCATE
</code></pre>

<p>```</p>

<p>You can also add a <b>condition</b> for running <strong>triggers</strong> and timing option, which I'm not going to discuss in greater details, you can find more about them in official <a href="http://www.postgresql.org/docs/9.5/static/sql-createtrigger.html" target="_blank">docs</a>.</p>




<p>What about <code>function_name</code>? It's a user-defined function returning <code>trigger</code>. Here's a dummy example to give an idea about the syntax for defining functions:</p>


<p>```
CREATE FUNCTION dummy() RETURNS trigger AS $$
DECLARE</p>

<pre><code>some_integer_variable int;
</code></pre>

<p>BEGIN</p>

<pre><code>some_integer_variable := 1;
NEW.counter := some_integer_variable;
RETURN NEW;
</code></pre>

<p>END;
$$ language plpgsql;
```</p>

<p>We started with defining <code>dummy</code> function taking no arguments returning type of <strong>trigger</strong>. Next, we have a <code>DECLARE</code> block where we declare temporary variables, in our case it's <code>some_integer_variable</code> of type <code>int</code>. Within <code>BEGIN / END</code> block we define the actual function body: we assign a dummy value to <code>some_integer_variable</code> variable using <code>:=</code> operator and then we do some assignment using implicit <code>NEW</code> variable which is basically a row referenced by given statement. This variable is available only when running a trigger <code>for each row</code>, otherwise it will return <code>NULL</code>. Any trigger has to return either a <strong>row</strong> or <code>NULL</code> - in this example we return <code>NEW</code> row. At the end we have a declaration of writing function in <code>plpgsql</code> language.</p>




<p>Let's take a look at some real world code to see triggers in action.</p>




<h2>Using triggers for data integrity</h2>




<p>A good example where we could use a trigger for more complex validation could be a calendar event: we need to ensure that no other event exists between some <code>begins_at</code> time and <code>finishes_at</code> time. We should also scope it only to a given calendar and exclude id of event being updated - when creating new events it wouldn't matter, but without excluding id we wouldn't be able to update any event. So what we actually want to achieve is to create a trigger that will be run <code>before insert or update</code> on <b>events</b> table <code>for each row</code>.</p>




<p>Let's start with generating <code>Calendar</code> model and <code>Event</code> model with reference to <code>calendar</code> and <code>begins_at</code> and <code>finishes_at</code> attributes:</p>


<p><code>
rails generate model Calendar
rails generate model Event calendar_id:integer begins_at:datetime finishes_at:datetime
</code></p>

<p>and also generate extra migration adding <strong>trigger</strong> and <strong>procedure</strong> ensuring that only one event can be created for given period of time for a calendar:</p>


<p><code>
rails generate migration add_validation_trigger_for_events_availability
</code></p>

<p>add the SQL code :</p>


<p>``` ruby
class AddValidationTriggerForEventsAvailability &lt; ActiveRecord::Migration
  def change</p>

<pre><code>execute &lt;&lt;-CODE
  CREATE FUNCTION validate_event_availability() returns trigger as $$
  DECLARE
    events_count int;
  BEGIN
    events_count := (SELECT COUNT(*) FROM events WHERE (
      events.calendar_id = NEW.calendar_id AND events.begins_at &lt; NEW.finishes_at AND events.finishes_at &gt; NEW.begins_at AND events.id != NEW.id
    ));
    IF (events_count != 0) THEN
      RAISE EXCEPTION 'Period between % and % is already taken', NEW.begins_at, NEW.finishes_at;
    END IF;
    RETURN NEW;
  END;
  $$ language plpgsql;

  CREATE TRIGGER validate_event_availability_trigger BEFORE INSERT OR UPDATE ON events
  FOR EACH ROW EXECUTE PROCEDURE validate_event_availability();
CODE
</code></pre>

<p>  end
end
```</p>

<p>Our <code>validate_event_availability</code> function performs query to count all events that are between given time period for specified calendar excluding own id (so that the row being updated is not considered here, which would prevent updating any event). If any other event is found, the exception is raised with an error message - <code>%</code> characters are used for interpolation of <code>begins_at</code> and <code>finishes_at</code> attributes. If no other event is found, we simply return the row.</p>




<p>We want to define a trigger running this function before creating any new event or updating existing ones, so we need to run it <code>BEFORE INSERT OR UPDATE</code> <code>FOR EACH ROW</code>.</p>




<p>It might be a good idea to switch also to <code>:sql</code> schema format - the standard <code>:ruby</code> format can't handle triggers at this point. Add this line in <code>config/application.rb</code>:</p>


<p>``` ruby</p>

<h1>config/application.rb</h1>

<p>config.active_record.schema_format = :sql
```</p>

<p>Now we can run migrations:</p>


<p><code>
rake db:migrate
</code></p>

<p>After changing the schema format, new <code>structure.sql</code> file should be created. It's not going to look that nice like <code>schema.rb</code>, but at least it contains all the details. Let's try creating some events from <code>rails console</code>:</p>


<p><code>ruby
calendar = Calendar.create
begins_at = "2016-05-02 12:00:00"
finishes_at =  "2016-05-02 16:00:00"
Event.create(calendar_id: calendar.id, begins_at: begins_at, finishes_at: finishes_at)
</code></p>

<p>Creating first event obviously works, but what's going to happen when we try to create an event with exactly the same dates?</p>


<p>``` ruby
Event.create(calendar_id: calendar.id, begins_at: begins_at, finishes_at: finishes_at)</p>

<p>ActiveRecord::StatementInvalid: PG::RaiseException: ERROR:  Period between 2016-05-02 12:00:00 and 2016-05-02 16:00:00 is already taken
```</p>

<p>Awesome (haha, doesn't happen that often to be happy when an error occurs ;)), that's exactly what we wanted to achieve - the trigger keeps our data safe making sure that we won't have any duplicated events or events covering the same time period. The last thing we should do is to mimic such validation and add it to form object or model for better user experience, but it's beyond the scope of this article. It's going to duplicate some logic between the code in the application and the database, but in this case there's no way to <strong>DRY</strong> it up.</p>




<h2>Wrapping up</h2>




<p>PostgreSQL triggers and procedures are not something that you will often want to use in Rails applications, but sometimes there's no other solution, especially when you have more complex rules for data integrity. In such cases, triggers and procedures are the right tool for the job.</p>



]]></content>
  </entry>
  
</feed>
