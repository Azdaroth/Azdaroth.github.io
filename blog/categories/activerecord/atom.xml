<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ActiveRecord | Karol Galanciak - Ruby on Rails and Ember.js consultant]]></title>
  <link href="https://karolgalanciak.com/blog/categories/activerecord/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2018-12-09T19:46:51+01:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Problems With Validating ActiveRecord Models And Why State Validation Is a Bad Idea]]></title>
    <link href="https://karolgalanciak.com/blog/2018/09/30/the-problems-with-validating-activerecord-models-and-why-state-validation-is-a-bad-idea/"/>
    <updated>2018-09-30T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/09/30/the-problems-with-validating-activerecord-models-and-why-state-validation-is-a-bad-idea</id>
    <content type="html"><![CDATA[<p>In the typical <strong>Rails application</strong>, you can find the most of the validations in the <strong>ActiveRecord models</strong>, which is nothing surprising &ndash; ActiveRecord models are used for multiple things. Whether it is a good thing, or a bad thing (in most cases it&rsquo;s the latter) deserves a separate book or at least blog post-series as it&rsquo;s not a simple problem, there is one specific thing that can cause <strong>a lot of issues</strong> that are <strong>difficult to solve</strong> and go beyond <strong>design decisions</strong> and ease of maintenance of the application, something that impacts the behavior of the model &ndash; <strong>the validations</strong>.</p>

<p>Just to give you a real-world example of what validation in ActiveRecord model looks like (as impossible as it seems, it really did happen) &ndash; when updating the check-in time of the reservation, which is a simple attribute on Reservation model, the record turned out to be invalid because&hellip; the format of guest&rsquo;s phone didn&rsquo;t match some regexp.</p>

<p>There are multiple ways to bypass this problem: use <code>validate: false</code> flag with <code>save</code> method: <code>save(validate: false)</code> or use <code>update_columns</code> method, but this is definitely not something that can be applied in a &ldquo;normal&rdquo; use case. In a typical scenario, this will be the error message displayed in the UI/returned to API consumer, and it will be confusing.</p>

<p>However, this is the expected behavior of ActiveRecord (or in general, ActiveModel-style) validations, which is <strong>a validation of the state</strong> of the model. And judging from this example, it&rsquo;s evident that it leads to <strong>problematic scenarios</strong>. What kind of design then would be the most appropriate to <strong>prevent such issues</strong>?</p>

<!--more-->


<h2>Forget State Validation</h2>

<p>Based on the previous example, it&rsquo;s clear that the real problem is the idea of a model&rsquo;s state validation. And the more complex state of the models can be (especially if there are some cross-validations between several models, which is not uncommon in complex applications), the more problems you will get.</p>

<p>Just wanted to update some <code>notes</code> attribute to add some quick info about something? Forget it &ndash; you will get three different validation errors that will tell you that someone&rsquo;s email has an invalid format, description is too short, a discount amount of something is invalid.</p>

<p>Sadly, this is the typical Rails Way of handling validations. In the initial phase of the application, this is certainly convenient &ndash; adding new validations is super easy, there is no need to discuss the design of potential alternatives and how it fits the bigger picture, and there is very little overhead. Unless you are ok with such problems, at some point, you will probably need to migrate validations to some other solution. What would be the potential alternative for validations?</p>

<h2>Validate The Actual Use Case</h2>

<p>The answer to that question is straight-forward (although it doesn&rsquo;t mean that achieving it will be simple) &ndash; just validate the thing you are doing, the actual use case. If you want to update <code>description</code>, you should only be concerned with the description &ndash; if it&rsquo;s present or not, it&rsquo;s length, etc., whether <code>headline</code> is too short or not (this can happen when you change the validation rules and don&rsquo;t somehow migrate the data) is not the subject of that use case.</p>

<p>There are a lot of implications of such approach &ndash; indeed, it will result in different sets of validators per creation and per update, since for creation we usually need way more data, and for an update, we may merely want to update a single attribute. Effectively, it will result in different validation pipelines for create and update actions. For creating, we may always need to apply specific validators (e.g., presence validators for some attributes), but for updating it will make more sense to apply only the validators for what we are trying to do &ndash; when we want to update email, we apply the presence and format validation for an email, if we want to update a description, we apply presence and length validators for a description.</p>

<h2>Potential Implementation</h2>

<p>What would be the way to implement it? The specific design is out of the scope of this article as it might require building mini-framework for validations and consider some design implications on the entire application (especially if we are escaping the traditional Rails Way). However, one thing is sure here &ndash; there will be dedicated validator objects, probably different for create and update action, and the validations will need to be removed from ActiveRecord models.</p>

<p>A potential way of interacting with such objects could look like this:</p>

<p><code>rb
validation_result = Reservation::CreateValidator.call(params)
if validation_result.success?
  # handle happy path here
else
  puts validation_result.errors.messages # for convenience and familiarity, `errors` object could have a similar interface to ActiveModel::Errors
end
</code></p>

<p>What if we need the model itself in the validator due to some complex business rules, like cross-model validation? We could either reuse <code>id</code> from <code>params</code> or just provide <code>model</code> as an argument:</p>

<p><code>rb
validation_result = Reservation::CreateValidator.call(record, params)
</code></p>

<h2>Side-Effects Of Such Design</h2>

<p>The implications of such design go far deeper than just moving things from one place to another to prevent some edge cases (and naturally increasing the complexity of the design, but it seems to be a fair price to pay for what we get as a result). Since it would make the most sense to have validations per use case, then&hellip; maybe we can have use case as objects that would expose their constraints, and the validators would take the rules from those objects and apply some specific logic on top of it to achieve the desired result? Maybe we could even create value objects composed of a single or multiple attributes, e.g. <code>Client::Email</code> object that would enforce its constraints and also, move some logic specific to the email itself in the context of a hypothetical <code>Client</code> model? And if we can identify the use cases themselves, aren&rsquo;t they domain events? And how hard would it be to build event-based architecture, or even apply Event Sourcing?</p>

<p>These are not trivial questions, however, doing one change in the design opens
the door to a holistic architectural approach where all parts of the domain fit together and the interaction between them is way more intentional comparing to ad hoc duct-tape-like solutions.</p>

<h2>Wrapping Up</h2>

<p>Putting <strong>too much logic</strong> in <strong>ActiveRecord models</strong> has a lot of disadvantages, most of them being problematic on the <strong>design level</strong>. However, things like validations can result in some nasty issues that go beyond the maintenance and cause actual business problems. Fortunately, by keeping that in mind and putting the <strong>validation logic</strong> in a <strong>separate object(s)</strong>, we can easily avoid such issues and as a nice side-effect, have a design that is way more flexible, extendible and eventually simpler to maintain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails And Conditional Validations In Models]]></title>
    <link href="https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models/"/>
    <updated>2018-06-24T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/06/24/rails-and-conditional-validations-in-models</id>
    <content type="html"><![CDATA[<p>Adding consents for accepting Terms of Service/Privacy Policies must have been a top popular feature in the majority of the applications due to enforcement of <strong>GDPR</strong> in May ;). From the technical aspects that GDPR requires, there is a proof of consent for processing the personal information. In that case, you need to have some actual attributes in the database that would confirm the fact that some user has indeed accepted Terms of Service/Privacy Policy.</p>

<p>That makes a significant impact on how we approach this kind of features. However, in the past, such things were quite often not stored in a database at all &ndash; it just took some UI <strong>acceptance validation</strong> or maybe a <strong>validation of the virtual attribute</strong> on the backend to be on the safe side.</p>

<p>Let&rsquo;s focus on the latter case where we don&rsquo;t need to store anything in DB and see what the possible solutions to that problems are. As <strong>trivial</strong> as this problem initially sounds, it will get <strong>quite interesting</strong> ;).</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>We want to make sure a user accepts Terms of Service during the signup process and to be sure that it is indeed validated, even if JavaScript validation fails in UI, we want to validate that fact on the backend.</p>

<h2>Solution 1 &ndash; Just add a virtual attribute to the model and validate it</h2>

<p>It is probably the most straightforward approach to that problem and most likely the least elegant. That&rsquo;s how we could implement it:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Well, it does work, no doubt about that. But currently, the validation will always be triggered, even during updates, which doesn&rsquo;t make much sense. We need to find a better solution.</p>

<h2>Solution 2 &ndash; Add a virtual attribute to the model and validate it only during the creation of a user</h2>

<p>A minor improvement over the previous version, we make sure that the validation is not triggered by updates, but only when creating a user:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :create
end
```</p>

<p>Even if it solves the actual problem, there is a big issue about that &ndash; the validation will always be triggered during a creation, even when creating users from factories! What other options do we have?</p>

<h2>Solution 3 &ndash; Add a virtual attribute to the model and validate it only for a specific context</h2>

<p>What is interesting in ActiveModel validations is that <code>on</code> option is not limited to <code>:create</code> or <code>:update</code> contexts &ndash; those are merely the ones that ActiveRecord sets by default depending on the persistence status of the model. We can provide a custom context for both <code>valid?</code> and <code>save</code> methods:</p>

<p><code>rb
user.valid?(:registration)
user.save(context: :registration)
</code></p>

<p>In that case, we could replace <code>:create</code> context with <code>:registration</code> context for the acceptance validation:</p>

<p>``` rb</p>

<h1>app/models/user.rb</h1>

<p>class User &lt; ApplicationRecord
  attr_accessor :terms_of_service_accepted</p>

<p>  validates :terms_of_service_accepted, acceptance: true, on: :registration
end
```</p>

<p>However, this is still not ideal &ndash; a global model which is used in multiple contexts has some logic that only applies to just one use case, and what is even worse, it&rsquo;s for an UI concern.</p>

<p>Let&rsquo;s try to find a solution that doesn&rsquo;t add any unnecessary mess to a model.</p>

<h2>Solution 4 &ndash; Use form object</h2>

<p>Using form object is probably the cleanest solution to our problem &ndash; we don&rsquo;t introduce any additional concerns to a model which should not be there, and we handle everything in a dedicated object. The are multiple ways how to implement a form object: we could create another ActiveModel model and take advantage of <a href="https://github.com/Azdaroth/active_model_attributes">ActiveModel Attributes</a> to make it smoother. We could use <a href="http://dry-rb.org/gems/dry-validation/basics/working-with-schemas/">dry-validation</a> gem for that. Or we could use my favorite tool for that purpose: <a href="https://github.com/trailblazer/reform">reform</a> gem from <a href="http://trailblazer.to">Trailblazer</a> stack.</p>

<p>Explaining the entire API of <code>reform</code> gem is way beyond the scope of this article, but the following implementation should be quite self-explanatory:</p>

<p>``` rb</p>

<h1>app/forms/user/registration_form.rb</h1>

<p>require &ldquo;reform/form/coercion&rdquo;</p>

<p>class User::RegistrationForm &lt; Reform::Form
  # other property declarations and validations</p>

<p>  property :terms_of_service_accepted, virtual: :true, type: Types::Form::Boolean</p>

<p>  validates :terms_of_service_accepted, acceptance: true
end
```</p>

<p>Besides handling other properties (most likely <code>email</code>, <code>password</code> and <code>password confirmation</code>), we are adding a virtual <code>terms_of_service_accepted</code> attribute with explicit type and adding acceptance validation using ActiveModel validator.</p>

<p>Even though using form objects is the cleanest approach, it requires some extra overhead, mostly with the setup, and sometimes it might be painful to add that setup, especially when extending third party&rsquo;s logic, e.g. <a href="https://github.com/scambra/devise_invitable">devise_invitable</a>. In such case, we would need some heavy customization which could potentially break when updating a gem and we would also need extra test coverage for the custom solution. It might still be worth introducing a form object, but it would be a good idea to consider other potential solutions. What option do we have left?</p>

<h2>Solution 5 &ndash; Extend user&rsquo;s instance with a custom logic</h2>

<p>Have you ever heard of DCI (Data Context Interaction) paradigm? If yes, you might have seen something like that:</p>

<p><code>rb
user = User.find(id)
user.extend(User::RegistrationContext)
</code></p>

<p>What this code does is adding extra functionality from <code>User::RegistrationContext</code> module to user&rsquo;s singleton class. Effectively, it means that we are not adding any additional logic to all User class instances, but only to that particular instance. Sounds like exactly what we need! That way, we can solve our problem achieving all the other goals as well &ndash; ease of extending the logic without too much overhead and without making a mess in the model.</p>

<p>Here is how our implementation of <code>User::RegistrationContext</code> context module could look like:</p>

<p>``` rb</p>

<h1>app/models/user/registration_context.rb</h1>

<p>module User::RegistrationContext
  def self.extended(model)</p>

<pre><code>class &lt;&lt; model
  validates :terms_of_service_accepted, acceptance: true
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :terms_of_service_accepted
end
```</p>

<p>The interesting thing about this implementation is that there is some singletons' inception going on there &ndash; first, we are using <code>extend</code> itself on the model, and then, in <code>extended</code> module hook we are opening singleton class of the model and declaring validation there. However, this is necessary since <code>validates</code> method is not defined in the context of that module, and we need to do that in the context of the model.</p>

<p>Let&rsquo;s try our fancy solution in action:</p>

<p><code>rb
user = User.new
user.extend(User::RegistrationContext)
user.terms_of_service_accepted = "0"
user.valid?
=&gt; false
user.errors.messages[:terms_of_service_accepted]
=&gt; ["must be accepted"]
</code></p>

<p>Perfect, that&rsquo;s exactly what we needed!</p>

<h2>Wrapping Up</h2>

<p>There are multiple ways in Rails (or Ruby in general) to handle <strong>conditional validation</strong>, and thanks to the flexibility of the framework and the language, we can pick whatever seems best for our particular problem &ndash; from adding additional validations in a model with <strong>extra ActiveModel context</strong>, through using <strong>form objects</strong>, ending with arcane DCI-style object&rsquo;s extensions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Quick Tips: Temporarily Disabling Touching with ActiveRecord.no_touching]]></title>
    <link href="https://karolgalanciak.com/blog/2018/02/25/rails-quick-tips-temporarily-disabling-touching-with-activerecord-dot-no-touching/"/>
    <updated>2018-02-25T20:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2018/02/25/rails-quick-tips-temporarily-disabling-touching-with-activerecord-dot-no-touching</id>
    <content type="html"><![CDATA[<p><strong>Touching</strong> <strong>ActiveRecord models</strong> is quite a common thing in most of the <strong>Rails applications</strong>, especially useful for cache invalidation. By default, it updates <code>updated_at</code> timestamp with the current time, Here&rsquo;s a typical example of using <a href="https://apidock.com/rails/ActiveRecord/Persistence/touch">touch</a> in a model:</p>

<p>``` ruby</p>

<h1>app/models/photo.rb</h1>

<p>class Photo &lt; ApplicationRecord
  belongs_to :user, touch: true
end
```</p>

<p>Whenever a new photo is created, or the existing one is updated/destroyed, the <code>updated_at</code> attribute of the associated user will be updated with the current time. In the majority of the cases, this is the desired behavior (it&rsquo;s one of those rare ActiveRecord callbacks that is not that bad ;)). However, it might happen that you may not want <code>touch</code> to be executed for some reason. Is there any built-in solution that could solve that problem?</p>

<!--more-->


<h2>Anatomy Of The Problem</h2>

<p>Temporarily disabling <code>touch</code>ing can useful either for performance reasons (when updating a large number of records) or simply to prevent <code>after_touch</code> or <code>after_commit</code> from being executed multiple times. The latter might indicate that there is a deeper problem in the design as putting any important logic causing side-effects beyond the record&rsquo;s internal state in those <strong>ActiveRecord callbacks</strong> can easily go south (especially if you trigger email notifications), but the reality is that a lot of Rails applications use those callbacks in such cases.</p>

<h2>The Solution</h2>

<p>Fortunately, a heavy refactoring or a rewrite is not necessary. Instead, we can take advantage of <a href="http://api.rubyonrails.org/classes/ActiveRecord/NoTouching/ClassMethods.html">ActiveRecord.no_touching</a> which temporarily disables touching inside the block.</p>

<p>Imagine that you need to update all photos belonging to some user and <code>touch</code> this user only after all photos are updated. Here&rsquo;s how it could be handled:</p>

<p>``` ruby
user = User.find(user_id)</p>

<p>ActiveRecord::Base.transaction do
  User.no_touching do</p>

<pre><code>user.photos.find_each do |photo|
  # user won't be `touch`ed
  photo.update!(some_attributes)
end
</code></pre>

<p>  end</p>

<p>  user.touch
end
```</p>

<p>If for some reason disabling touching is necessary for all models, you could just call it on <code>ActiveRecord::Base</code>:</p>

<p>``` ruby
user = User.find(user_id)</p>

<p>ActiveRecord::Base.transaction do
  ActiveRecord::Base.no_touching do</p>

<pre><code>user.photos.find_each do |photo|
  # no model will be `touch`ed
  photo.update!(some_attributes)
end
</code></pre>

<p>  end</p>

<p>  user.touch
end
```</p>

<p>And that&rsquo;s it!</p>

<h2>Summary</h2>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/NoTouching/ClassMethods.html"><code>ActiveRecord.no_touching</code></a> is certainly a quick solution to a potentially tricky issue. However, it is also a dirty hack that indicates a potential problem with the design of the application that should be addressed sooner than later.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSQL Quick Tips: Working With Dates Using EXTRACT function]]></title>
    <link href="https://karolgalanciak.com/blog/2018/01/30/postgresql-quick-tips-working-with-dates-using-extract-function/"/>
    <updated>2018-01-30T04:30:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2018/01/30/postgresql-quick-tips-working-with-dates-using-extract-function</id>
    <content type="html"><![CDATA[<p>Imagine that you are implementing an e-commerce platform and want to grab all orders from the <strong>current year</strong>. What would be the simplest way of doing it in Rails? Probably writing a query looking like this:</p>

<p><code>ruby
Order.where("created_at &gt;= ? AND created_at &lt; ?", Date.today.beginning_of_year, Date.today.beginning_of_year.next_year)
</code></p>

<p>It gets the job done but requires unnatural filtering by a range for a use case generic enough that it should be handled just using some native functions. Is it possible?</p>

<p>Apparently, it is! We can use <a href="https://www.postgresql.org/docs/10/static/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT" target="_blank"><code>EXTRACT</code></a>  and <a href="https://www.postgresql.org/docs/10/static/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT" target="_blank"><code>now()</code></a> functions &ndash; the former could be used for extracting the current <strong>year</strong> from a timestamp and the latter could be used for getting the current time.</p>

<p>With those two functions, the query could look like the following one:</p>

<p><code>ruby
Order.where("EXTRACT(year FROM created_at) = EXTRACT(year FROM now())")
</code></p>

<p>Much cleaner! And the great thing is that you can also create a functional index for <code>EXTRACT(year FROM created_at)</code> to avoid sequential scanning and get much better performance.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to ActiveRecord and ActiveModel Attributes API]]></title>
    <link href="https://karolgalanciak.com/blog/2016/12/04/introduction-to-activerecord-and-activemodel-attributes-api/"/>
    <updated>2016-12-04T22:00:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2016/12/04/introduction-to-activerecord-and-activemodel-attributes-api</id>
    <content type="html"><![CDATA[<p><strong>Rails 5.0</strong> is without a doubt a great release with plenty of useful changes and additions. The most notable change was probably <strong>ActionCable</strong> - the layer responsible for integrating your app with websockets. However, there were also other additions that could bring some <strong>substantial improvements</strong> to your Rails apps, but were a bit outshined by bigger changes. One of such features is <strong>Attributes API</strong>.</p>




<!--more-->




<h2>ActiveRecord Attributes And Defaults - The Old Way</h2>




<p>Imagine that you are in a vacation rental industry and you are adding a new model for handling reservations for rentals, let's call it <code>Reservation</code>. To keep it simple for the purpose of this example, let's assume that we need <code>start_date</code> and <code>end_date</code> date fields for handling the duration of the reservations and <code>price</code> field, which is pretty useful unless you are developing an app for a charity organization ;). Let's say we want to provide some defaults for the <code>start_date</code> and <code>end_date</code> attributes to be 1 day from now and 8 days from know accordingly when initializing a new instance of <code>Reservation</code> and the price should be converted to integer, so in fact it is going to be <code>price in cents</code>, and the expected format of the input is going to look like <code>"$1000.12"</code>. How could we handle it inside ActiveRecord models?</p>




<p>For default values, one option would be to add <code>after_initialize</code> callbacks which would assign the given defaults unless the values were already set in the initializer. For <code>price</code> we can simply override the attribute writer which is <code>Reservation#price=</code> method. We would most likely end up with something looking like this:</p>


<p>``` rb app/models/reservation.rb
class Reservation &lt; ApplicationRecord
  after_initialize :set_default_start_date
  after_initialize :set_default_end_date</p>

<p>  def price=(value)</p>

<pre><code>return super(0) if !value.to_s.include?('$')

price_in_dollars = value.gsub(/\$/, '').to_d
super(price_in_dollars * 100)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def set_default_start_date</p>

<pre><code>self.start_date = 1.day.from_now if start_date.blank?
</code></pre>

<p>  end</p>

<p>  def set_default_end_date</p>

<pre><code>self.end_date = 8.days.from_now if end_date.blank?
</code></pre>

<p>  end
end
```</p>

<p>Well, the above code works, but it can get repetitive across many models and doesn't read that well, would be much better to handle it with more of a declarative approach. But is there any built-in solution for that problem in <code>ActiveRecord</code>?</p>




<p>Then answer is yes! Time to meet your new friend in Rails world: <code>ActiveRecord Attributes API</code>.</p>




<h2>ActiveRecord Attributes And Defaults - The New Way - Attributes API</h2>




<p>Since Rails 5.0 we can use awesome Attributes API in our models. Just declare the name of the attribute with <code>attribute</code> class method, its <code>type</code> and provide optional default (either a raw value or a lambda). The great thing is that you are not limited only to attributes <strong>backed by database</strong>, you can use it for virtual attributes as well!</p>




<p>For our <code>Reservation</code> model, we could apply the following refactoring with <strong>Attributes API</strong>:</p>


<p>``` rb app/models/reservation.rb
class Reservation &lt; ApplicationRecord
  attribute :start_date, :date, default: &ndash;> { 1.day.from_now }
  attribute :end_date, :date, default: &ndash;> { 8.days.from_now }</p>

<p>  def price=(val)</p>

<pre><code>return super(0) if !value.to_s.include?('$')

price_in_dollars = value.gsub(/\$/, '').to_d
super(price_in_dollars * 100)
</code></pre>

<p>  end
end
```</p>

<p>Looks much cleaner now! Let's see how it works:</p>


<p><code>
2.3.1 :001 &gt; reservation = Reservation.new
 =&gt; #&lt;Reservation id: nil, start_date: "2016-12-03", end_date: "2016-12-10", price: nil, created_at: nil, updated_at: nil&gt;
2.3.1 :002 &gt; reservation.start_date
 =&gt; Sat, 03 Dec 2016
2.3.1 :003 &gt; reservation.end_date
 =&gt; Sat, 10 Dec 2016
2.3.1 :004 &gt; reservation = Reservation.new(start_date: 3.days.from_now)
 =&gt; #&lt;Reservation id: nil, start_date: "2016-12-05", end_date: "2016-12-10", price: nil, created_at: nil, updated_at: nil&gt;
2.3.1 :005 &gt; reservation.start_date
 =&gt; Mon, 05 Dec 2016
</code></p>

<p>That's exactly what we needed. What about our conversion for <code>price</code>? As we can specify the type for given attribute, we may expect that it would be possible to define our own types. Turns out it is possible and quite simple actually. Just create a class inheriting from <code>ActiveRecord::Type::Value</code> or already existing type, e.g. <code>ActiveRecord::Type::Integer</code>, define <code>cast</code> method and register the new type. In our use case let's register a new <code>price</code> type:</p>


<p>``` rb app/types/price_type.rb
class PriceType &lt; ActiveRecord::Type::Integer
  def cast(value)</p>

<pre><code>return super if value.kind_of?(Numeric)
return super if !value.to_s.include?('$')

price_in_dollars = BigDecimal.new(value.gsub(/\$/, ''))
super(price_in_dollars * 100)
</code></pre>

<p>  end
end
```</p>

<p><code>rb config/initializers/types.rb
ActiveRecord::Type.register(:price, PriceType)
</code></p>

<p>Let's use Attributes API for <code>price</code> attribute:</p>


<p><code>ruby app/models/reservation.rb
class Reservation &lt; ApplicationRecord
  attribute :start_date, :date, default: -&gt; { 1.day.from_now }
  attribute :end_date, :date, default: -&gt; { 8.days.from_now }
  attribute :price, :price
end
</code></p>

<p>And let's test if it indeed works as expected:</p>


<p><code>
2.3.1 :001 &gt; reservation = Reservation.new
 =&gt; #&lt;Reservation id: nil, start_date: "2016-12-03", end_date: "2016-12-10", price: nil, created_at: nil, updated_at: nil&gt;
2.3.1 :002 &gt; reservation.price = "$100.12"
 =&gt; "$100.12"
2.3.1 :003 &gt; reservation.price
 =&gt; 10012
</code></p>

<p>Nice! Much cleaner and easy to reuse.</p>




<p>Attributes API comes also with some other features, you could e.g. provide <code>array</code> or range <code>option</code> and work with arrays and ranges for given type:</p>


<p><code>rb app/models/reservation.rb
class Reservation &lt; ApplicationRecord
  attribute :start_date, :date, default: -&gt; { 1.day.from_now }
  attribute :end_date, :date, default: -&gt; { 8.days.from_now }
  attribute :price, :money
  attribute :virtual_array, :integer, array: true
  attribute :virtual_range, :date, range: true
end
</code></p>

<p><code>
2.3.1 :001 &gt; reservation = Reservation.new(virtual_array: ["1.0", "2"], virtual_range: "[2016-01-01,2017-01-1]")
 =&gt; #&lt;Reservation id: nil, start_date: "2016-12-03", end_date: "2016-12-10", price: nil, created_at: nil, updated_at: nil&gt;
2.3.1 :002 &gt; reservation.virtual_array
 =&gt; [1, 2]
2.3.1 :003 &gt; reservation.virtual_range
 =&gt; Fri, 01 Jan 2016..Sun, 01 Jan 2017
</code></p>

<p>Attributes API is already looking great, but it's not the end of the story. You can use your custom types for querying a database, you just need to define <code>serialize</code> method for your own types:</p>


<p>``` rb app/types/price_type.rb
class PriceType &lt; ActiveRecord::Type::Integer
  def cast(value)</p>

<pre><code>return super if value.kind_of?(Numeric)
return super if !value.to_s.include?('$')

price_in_dollars = BigDecimal.new(value.gsub(/\$/, ''))
super(price_in_dollars * 100)
</code></pre>

<p>  end</p>

<p>  def serialize(value)</p>

<pre><code>cast(value)
</code></pre>

<p>  end
end
```</p>

<p>That way we could simply give prices in original format as arguments and they are going to be converted to price in cents before performing a query.</p>


<p><code>rb
Reservation.where(price: "$100.12")
 =&gt; Reservation Load (0.3ms)  SELECT "reservations".* FROM "reservations" WHERE "reservations"."price" = $1  [["price", 10012]]
</code></p>

<p>As expected, the price used for query was the one after serialization.</p>




<p>If you want to check the list of built-in types or learn more, check the official <a href="http://edgeapi.rubyonrails.org/classes/ActiveRecord/Attributes/ClassMethods.html" target="_blank">docs</a>.</p>




<h2>What About ActiveModel?</h2>




<p>So far I've discussed only the <strong>ActiveRecord Attributes API</strong>, but the title clearly mentions <code>ActiveModel</code> part, so what about it? There is a bad news and good news.</p>




<p>The bad news is that it is not <a href="https://github.com/rails/rails/pull/26728" target="_blank">yet</a> supported in Rails core, but most likely it is going to be the part of <strong>ActiveModel</strong> eventually.</p>




<p>The good news is that you can use it today, even though it's not a part of Rails! I've released <a href="https://github.com/Azdaroth/active_model_attributes" target="_blank">ActiveModelAttributes</a> gem which provides Attributes API for ActiveModel and it works in a very similar way to <strong>ActiveRecord Attributes</strong>.</p>




<p>Just define your <strong>ActiveModel model</strong>, include <code>ActiveModel::Model</code> and ActiveModelAttributes</code> modules and define attributes and their types using <code>attribute</code> class method:</p>


<p>``` rb app/models/my_awesome_model.rb
class MyAwesomeModel
  include ActiveModel::Model
  include ActiveModelAttributes</p>

<p>  attribute :description, :string, default: &ldquo;default description&rdquo;
  attribute :start_date, :date, default: &ndash;> { Date.new(2016, 1, 1) }
end
```</p>

<p>You can also add your custom types. Just create a class inheriting from <code>ActiveModel::Type::Value</code> or already existing type, e.g. <code>ActiveModel::Type::Integer</code>, define <code>cast</code> method and register the new type:</p>


<p>``` rb app/types/money_type.rb
class MoneyType &lt; ActiveModel::Type::Integer
  def cast(value)</p>

<pre><code>return super if value.kind_of?(Numeric)
return super if !value.to_s.include?('$')

price_in_dollars = BigDecimal.new(value.gsub(/\$/, ''))
super(price_in_dollars * 100)
</code></pre>

<p>  end
end
```</p>

<p><code>rb config/initializers/types.rb
ActiveModel::Type.register(:money, MoneyType)
</code></p>

<p>``` rb app/models/my_awesome_model.rb
class MyAwesomeModel
  include ActiveModel::Model
  include ActiveModelAttributes</p>

<p>  attribute :price, :money
end
```</p>

<p>And that's it! Check the <a href="https://github.com/Azdaroth/active_model_attributes" target="_blank">docs</a>, start using it today and enjoy ;)</p>




<h2>Wrapping up</h2>




<p><strong>ActiveRecord Attributes API</strong> is defintely a great feature introduced in <strong>Rails 5.0</strong>. Even though it is not yet supported in ActiveModel in Rails core, <a href="https://github.com/Azdaroth/active_model_attributes" target="_blank">ActiveModelAttributes</a> can be easily added to your Rails apps to provide almost the same functionality.</p>

]]></content>
  </entry>
  
</feed>
