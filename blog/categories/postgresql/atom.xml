<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PostgreSQL | Karol Galanciak - Distributed Systems Architect and Ruby on Rails expert]]></title>
  <link href="https://karolgalanciak.com/blog/categories/postgresql/atom.xml" rel="self"/>
  <link href="https://karolgalanciak.com/"/>
  <updated>2019-09-08T08:40:20+02:00</updated>
  <id>https://karolgalanciak.com/</id>
  <author>
    <name><![CDATA[Karol Galanciak]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Indexes on Rails: How to make the most of your Postgres database]]></title>
    <link href="https://karolgalanciak.com/blog/2018/08/19/indexes-on-rails-how-to-make-the-most-of-your-postgres-database/"/>
    <updated>2018-08-19T20:00:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2018/08/19/indexes-on-rails-how-to-make-the-most-of-your-postgres-database</id>
    <content type="html"><![CDATA[<p>Optimizing <strong>database queries</strong> is arguably one of the fastest ways to improve the <strong>performance</strong> of the Rails applications. There are multiple ways how you can approach it, depending on the kind of a problem. <strong>N+1 queries</strong> seem to be a pretty common issue, which is, fortunately, <strong>easy to address</strong>. However, sometimes you have some relatively <strong>simple-looking queries</strong> that seem to take way longer than they should be, indicating that they might require some optimization. The best way to improve such queries is adding a <strong>proper index</strong>.</p>

<p>But what does &ldquo;proper index&rdquo; mean? How to figure out what kind of index is exactly needed for a given query? Here are some essential facts and tips that should cover a majority of the queries you may encounter and make your database no longer a bottleneck.</p>

<!--more-->


<h2>Why index at all?</h2>

<p>Simple &ndash; to have faster queries. But why are indexes faster? The alternative to index is a sequential scanning of the entire table. That might not sound like a bad idea, but imagine you are performing a search over a huge table. What would be the fastest way to retrieve all records you are looking for &ndash; by scanning the entire table, or maybe having a way to store a subset of the records, based on some specific criteria, and then retrieve them from that place? Obviously, it&rsquo;s the second option. And that&rsquo;s roughly how indexes work.</p>

<p>As trivial as it sounds, there is a valuable lesson to learn from it: to achieve a good performance, the index must be selective enough. And the more specific you will be about those criteria, the better.</p>

<h2>Index Types</h2>

<p>Although Postgres by defaults creates <code>B-Tree</code> index when using <code>CREATE INDEX</code> command, there are a couple of more indexes that will be certainly useful in many use cases. Let&rsquo;s check them all out:</p>

<h3>B-Tree Index</h3>

<p><code>B-Tree</code> is a self-balancing tree data structure which keeps data ordered and easy to search. This index is appropriate for equality and range queries (using operators like <code>&gt;=</code>,  <code>&lt;</code> etc.) and will work great with text, timestamp and number fields.</p>

<p>B-Tree indexes are a reasonable default for most of the queries, but not for all of them. The limitation comes from the underlying structure. Discussing the details of the B-Tree data structure itself is beyond the scope of this article; nevertheless, it&rsquo;s worth keeping in mind that it&rsquo;s a similar data structure to a binary search tree, which has meaningful consequences on what can be indexed with it and how. We will get back to a couple of examples later.</p>

<h3>Hash Index</h3>

<p>Before Postgres 10, the usage of hash indexes was discouraged since they used to be not WAL-logged. Fortunately, it&rsquo;s changed in Postgres 10, and we can use them safely without worrying about rebuilding the index if something goes wrong with our database that would cause a crash. The use cases where hash indexes are useful are very limited, as they work only for equality, but they are a bit more efficient for this kind of queries comparing to b-tree indexes. If you store tokens for example and perform lookups by the token value, hash indexes would be a good way to optimize such queries.</p>

<h3>BRIN Index (Block Range Index)</h3>

<p>BRIN indexes were introduced in Postgres 9.5 which make them a pretty new addition. They tend to work very well for the large sets of ordered data, e.g., statistical data collected with timestamps which are later filtered by the time range. They will perform better than b-tree indexes in such case, although the difference won&rsquo;t be drastic. However, the different of the size of the index will be huge &ndash; BRIN index can be smaller by literally few orders of magnitude comparing to b-tree index.</p>

<h3>GIN Index (Generalized Inverted Index)</h3>

<p>GIN Indexes are the perfect choice for &ldquo;composite values&rdquo; where you perform a query which looks for an element within such &ldquo;composite&rdquo;. That is the index you will most likely want to use for <code>jsonb</code>, <code>array</code> or <code>hstore</code> data structures. They are also an excellent choice for full-text search.</p>

<h3>GiST Index (Generalized Inverted Seach Tree Index)</h3>

<p>GiST Indexes will be a good choice when the records overlap values under the same column. They are commonly used for geometry types and full-text search as well. The difference between GIN and GiST Index when it comes to full-text search is that GiST Index will be less taxing on writes comparing to GIN (as it is faster to build). But since it&rsquo;s a lossy index, there might be some extra overhead involved for reads, which makes GIN index a better choice when you mostly care about reads optimization.</p>

<h2>Optimizing Queries</h2>

<p>Here are some tips that should help you with the majority of the queries:</p>

<h3>Start with EXPLAIN</h3>

<p>With enough experience and knowledge of your app, you will develop an intuition about indexes and where they might be useful, long before having performance problems with queries. Until that happens, it&rsquo;s essential to understand how Postgres is going to execute these queries. The best tool for that purpose is using <code>EXPLAIN</code> command, which will show the execution plan generated by the query planner. <code>ActiveRecord</code> provides a convenient method &ndash; <code>explain</code> &ndash; that you can use on collections to get the query plan:</p>

<p>```</p>

<blockquote><p>Order.where(customer_id: 1).explain
  Order Load (13.8ms)  SELECT &ldquo;orders&rdquo;.<em> FROM &ldquo;orders&rdquo; WHERE &ldquo;orders&rdquo;.&ldquo;customer_id&rdquo; = $1  [[&ldquo;customer_id&rdquo;, 1]]
=> EXPLAIN for: SELECT &ldquo;orders&rdquo;.</em> FROM &ldquo;orders&rdquo; WHERE &ldquo;orders&rdquo;.&ldquo;customer_id&rdquo; = $1 [[&ldquo;customer_id&rdquo;, 1]]</p>

<pre><code>                                       QUERY PLAN
</code></pre>

<hr />

<p> Index Scan using index_orders_on_customer_id on orders  (cost=0.15..19.62 rows=50 width=1417)
   Index Cond: (customer_id = 1)
(2 rows)
```</p></blockquote>

<p>Unfortunately, <code>EXPLAIN ANALYZE</code>, which provides even more insight, as it performs a real query, is not supported out of the box by ActiveRecord. However, it can be added using an extra gem. You can check out <a href="https://pawelurbanek.com/slow-rails-queries">this blog post</a> to learn more about it.</p>

<h3>How to tell a good query plan from a bad one?</h3>

<p>This is not that simple as it sounds, as the sequential scan can be sometimes more efficient than using an index, especially if not kept in memory, but stored entirely on disk, and even worse, an HDD one. Usually, a preferable query plan is the one that looks simpler and utilizes the least possible number of indexes, which means that it&rsquo;s better to use one index instead of two of them, like in the following example:</p>

<p>```</p>

<blockquote><p>Product.where(warehouse_id: 1).where(category_id: 1).explain
  Product Load (0.5ms)  SELECT &ldquo;products&rdquo;.<em> FROM &ldquo;products&rdquo; WHERE &ldquo;products&rdquo;.&ldquo;warehouse_id&rdquo; = $1 AND &ldquo;products&rdquo;.&ldquo;category_id&rdquo; = $2  [[&ldquo;warehouse_id&rdquo;, 1], [&ldquo;category_id&rdquo;, 1]]
=> EXPLAIN for: SELECT &ldquo;products&rdquo;.</em> FROM &ldquo;products&rdquo; WHERE &ldquo;products&rdquo;.&ldquo;warehouse_id&rdquo; = $1 AND &ldquo;products&rdquo;.&ldquo;category_id&rdquo; = $2 [[&ldquo;warehouse_id&rdquo;, 1], [&ldquo;category_id&rdquo;, 1]]</p>

<pre><code>                                                   QUERY PLAN
</code></pre>

<hr />

<p> Bitmap Heap Scan on products  (cost=9.08..13.10 rows=1 width=1417)
   Recheck Cond: ((warehouse_id = 1) AND (category_id = 1))
   &ndash;>  BitmapAnd  (cost=9.08..9.08 rows=1 width=0)</p>

<pre><code>     -&gt;  Bitmap Index Scan on index_products_on_warehouse_id_and_name_and_something_else  (cost=0.00..4.31 rows=5 width=0)
           Index Cond: (warehouse_id = 1)
     -&gt;  Bitmap Index Scan on index_products_on_category_id  (cost=0.00..4.52 rows=50 width=0)
           Index Cond: (category_id = 1)
</code></pre>

<p>(7 rows)
```</p></blockquote>

<p>It doesn&rsquo;t necessarily mean that this query plan is a bad one &ndash; it could be totally the case that such query is fast enough. However, if read speed is more important for us than the index size and extra overhead on writes which will make them slower, the best way to deal with such query would be adding a compound index on both <code>warehouse_id</code> and <code>category_id</code>.</p>

<p>One statement that is especially worth keeping an eye on (besides <code>Seq Scan</code> which stands for a sequential scan) is <code>Filter</code> statement which indicates that the records required extra filtering and the index was not enough. Here is one example:</p>

<p><code>
 Index Scan using index_products_on_category_id on products
   Index Cond: (category = 1)
   Filter: (created_at = '2018-08-11'::date)
</code></p>

<p>Ideally, <code>created_at</code> part would appear in <code>Index Cond</code> and be fully covered by the index. Usually, adding a compound index on multiple columns solves the issue which in this example would mean having an index on both <code>category_id</code> and <code>created_at</code>, not only on <code>category_id</code>.</p>

<h3>Sequence of the columns in B-Tree index does matter</h3>

<p>The sequence of the columns in a multi-column index is critical. Imagine that you created a following index: <code>create_index :tag_items, [:taggable_type, :taggable_id]</code> and want to perform a couple of queries. For sure this index is going to be efficient for searching by both <code>taggable_type</code> and <code>taggable_id</code>. It will also work great for search by <code>taggable_type</code>. It won&rsquo;t, however, be efficient when performing a search just by <code>taggable_id</code>. The reason why it is like that is quite simple though &ndash; try to imagine how the data would be stored in a hypothetical B-Tree. First, the nodes will be organized based on the leftmost column and then, by another one. Traversing such tree when you do a search based on <code>taggable_type</code> or both <code>taggable_type</code> and <code>taggable_id</code> will be simple. However, you can&rsquo;t do the same with just <code>taggable_id</code>. Postgres might use this index anyway as it might turn out to be still more efficient than a sequential scan, but this is going to be suboptimal. If it happens that you need to perform queries by <code>taggable_id</code> only, it would be a good idea to add a separate index on that field.</p>

<h3>Unique Indexes</h3>

<p>The biggest need behind unique indexes is ensuring data integrity (since most uniqueness validations, including ActiveRecord one, don&rsquo;t enforce anything and are more useful for having a nice error message and not raising an exception than for data integrity). However, a nice side effect of a unique index is also a better performance comparing to a non-unique one.</p>

<h3>Partial Indexes</h3>

<p>Imagine that you have some Articles in your application and you want to add <code>published_at</code> datetime field indicating whether and when the article was published, and then, filter published articles by a given author. We can most likely expect a need for an index on <code>author_id</code> column in such case. What about our second condition? We could for sure add a compound index on both <code>author_id</code> and <code>published_at</code>. However, there is a better choice. We could add a partial index for <code>author_id</code> which covers only published articles, i.e., covers <code>WHERE published_at IS NOT NULL</code>!</p>

<p>Fortunately, this is supported by Rails (although writing a SQL command wouldn&rsquo;t be that difficult), we just need to use <code>where</code> option for that:</p>

<p><code>rb
add_index :articles, :author_id, where: "published_at IS NOT NULL"
</code></p>

<h3>Expression Indexes</h3>

<p>Imagine that you need to search users by their first name which comes from some input provided by a user. However, to avoid issues with figuring out whether the name provided by a user starts with a capital letter or not or how the names were stored in the database in the first place, you perform a query like this:</p>

<p><code>rb
User.where("lower(first_name) = ?", name.downcase)
</code></p>

<p>This query will obviously work, however, if you have a lot of users, a query plan will indicate that it is suboptimal and instead of seeing something like <code>Index Scan using index_users_on_first_name on users</code>, you will see <code>Seq Scan on users</code>.</p>

<p>There is no need to worry though. Postgres allows creating expression indexes where you can apply some functions, which in our case is <code>lower</code>. A proper index for this scenario would need to be created that way:</p>

<p><code>rb
add_index :users, "lower(first_name)", name: "index_users_on_lower_first_name"
</code></p>

<h3>Optimizing LIKE queries</h3>

<p>Optimizing queries with <code>LIKE</code> clause is simple; you just need to remember about two things:</p>

<ol>
<li>Forget about B-Tree Index for this case.</li>
<li>Take advantage of trigram matching provided by <a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">pg_trgm</a> extension.</li>
</ol>


<p>To avoid sequential scans and utilize index that will drastically improve the performance of this kind of queries, enable the extension and create a GIN or GiST index:</p>

<p><code>
execute "CREATE EXTENSION pg_trgm;"
execute "CREATE INDEX CONCURRENTLY index_products_on_description_trigram ON clients USING gin(description gin_trgm_ops);"
</code></p>

<p>Thanks to this index, this is a query plan you might expect when filtering <code>Products</code> by <code>descriptions</code> containing some text, with wildcards on both the beginning and the end:</p>

<p>```
EXPLAIN for: SELECT &ldquo;products&rdquo;.* FROM &ldquo;products&rdquo; WHERE (products.description ILIKE &lsquo;%some text with wildacards%&rsquo;)</p>

<pre><code>                                            QUERY PLAN
</code></pre>

<hr />

<p> Bitmap Heap Scan on products
   Recheck Cond: (description ~~* &lsquo;%some text with wildacards%&rsquo;::text)
   &ndash;>  Bitmap Index Scan on index_products_on_description_trigram</p>

<pre><code>     Index Cond: (description ~~* '%some text with wildacards%'::text)
</code></pre>

<p>```</p>

<h3>Ordering</h3>

<p>B-tree indexes are sorted in an ascending order which we can use to our advantage to avoid performing sorting in memory. However, we also need to keep in mind the limitation of the data structure itself. A rule of thumb for efficient ordering would be: order by the same columns you perform filtering by. It is going to be the case by default when you don&rsquo;t explicitly add any <code>ORDER</code> clause since the indexes are ordered. But if it happens that you need to apply different ordering criteria, you can take advantage of <code>order</code> option and explicitly specify the order:</p>

<p><code>
add_index :products, :created_at, order: { created_at: :desc }
</code></p>

<h3>Adding indexes concurrently</h3>

<p>The way how the indexes are added doesn&rsquo;t impact the performance once they are created; however, it&rsquo;s good to keep in mind that just simple <code>CREATE INDEX</code> will block concurrent writes (inserts, updates, and deletes) until it&rsquo;s finished. It can lead to some issues, including deadlocks, especially when the index is getting created for a huge table under massive write operations.</p>

<p>To prevent such a problem, it&rsquo;s worth creating indexes <a href="https://www.postgresql.org/docs/10/static/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY">concurrently</a> instead. You can do that in Rails using <code>algorithm: :concurrently</code> option and by making sure that the index creation will run outside of a transaction by calling <code>disable_ddl_transaction!</code>.</p>

<p>``` rb
class AddIndexToAsksActive &lt; ActiveRecord::Migration[5.0]
  disable_ddl_transaction!</p>

<p>  def change</p>

<pre><code>add_index :users, :active, algorithm: :concurrently
</code></pre>

<p>  end
end
```</p>

<p>There is one caveat here though. If you attempt to create a unique index concurrently, there is a possibility that something will go wrong, e.g., when a non-unique record is created during the index creation. Since the command is run outside the transaction, it won&rsquo;t be rolled back, and you will end up with an invalid index. Nevertheless, that is not a big problem &ndash; should it ever happen, just drop the invalid index and try creating it concurrently one more time.</p>

<h2>Wrapping up</h2>

<p>Optimizing <strong>PostgreSQL queries</strong> might not look a trivial task, but if you keep these rules in mind, you will have much easier time with your database, and you will enjoy fast queries for a long time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSQL Quick Tips: Working With Dates Using EXTRACT function]]></title>
    <link href="https://karolgalanciak.com/blog/2018/01/30/postgresql-quick-tips-working-with-dates-using-extract-function/"/>
    <updated>2018-01-30T04:30:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2018/01/30/postgresql-quick-tips-working-with-dates-using-extract-function</id>
    <content type="html"><![CDATA[<p>Imagine that you are implementing an e-commerce platform and want to grab all orders from the <strong>current year</strong>. What would be the simplest way of doing it in Rails? Probably writing a query looking like this:</p>

<p><code>ruby
Order.where("created_at &gt;= ? AND created_at &lt; ?", Date.today.beginning_of_year, Date.today.beginning_of_year.next_year)
</code></p>

<p>It gets the job done but requires unnatural filtering by a range for a use case generic enough that it should be handled just using some native functions. Is it possible?</p>

<p>Apparently, it is! We can use <a href="https://www.postgresql.org/docs/10/static/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT" target="_blank"><code>EXTRACT</code></a>  and <a href="https://www.postgresql.org/docs/10/static/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT" target="_blank"><code>now()</code></a> functions &ndash; the former could be used for extracting the current <strong>year</strong> from a timestamp and the latter could be used for getting the current time.</p>

<p>With those two functions, the query could look like the following one:</p>

<p><code>ruby
Order.where("EXTRACT(year FROM created_at) = EXTRACT(year FROM now())")
</code></p>

<p>Much cleaner! And the great thing is that you can also create a functional index for <code>EXTRACT(year FROM created_at)</code> to avoid sequential scanning and get much better performance.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keeping Data Integrity In Check: Conditional Unique Indexes For Soft Delete]]></title>
    <link href="https://karolgalanciak.com/blog/2016/11/01/keeping-data-integrity-in-check-conditional-unique-indexes-for-soft-delete/"/>
    <updated>2016-11-01T00:30:00+01:00</updated>
    <id>https://karolgalanciak.com/blog/2016/11/01/keeping-data-integrity-in-check-conditional-unique-indexes-for-soft-delete</id>
    <content type="html"><![CDATA[<p><strong>Soft delete</strong> is a pretty common feature in most of the applications. It may increase complexity of the queries, nevertheless, not deleting anything might be a <strong>right default</strong> as the data might prove to be useful in the future: for restoring if a record was removed by mistake, to derive some conclusions based on statistics and plenty of other purposes. It may seem like it's a pretty trivial thing: just adding a column like <code>deleted_at</code> and filtering out records that have this value present. But what happens when you need to do some proper <strong>uniqueness validation</strong> on both model layer and database level? Let's take a look what kind of problem can easily be overlooked and how it can be solved with a <strong>conditional index</strong>.</p>




<!--more-->




<h2>Case study: daily prices for vacation rentals</h2>




<p>Let's imagine we are developing a <strong>vacation rental</strong> software. Most likely the pricing for each day will depend on some complex set of rules, but we may want to have some denormalized representation of base prices for each day to make things more obvious and have some possiblity of sharing this kind of data with other applications, which is quite common in this domain. We may start with adding a <code>DailyPrice</code> model having a reference to a <code>rental</code>, having <code>price</code> value and of course <code>date</code> for which the price is applicable.</p>




<h2>Ensuring uniqueness</h2>




<p>Obviously, we don't want to have any duplicated <code>daily_prices</code> for any rental, so we need to add a uniqueness validation for <code>rental_id</code> and <code>date</code> attributes:</p>


<p><code>ruby app/models/daily_price.rb
validates :rental_id, presence: true, uniqueness: { scope: :date }
</code></p>

<p>To ensure <strong>integrity of the data</strong> and that we are protected against race conditions and potental validation bypassing, we need to add a <strong>unique index</strong> on the database level:</p>


<p><code>ruby db/migrate/20161030120000_add_unique_index_for_daily_prices.rb
  add_index :daily_prices, [:rental_id, :date], unique: true
</code></p>

<h2>Adding soft delete functionality</h2>




<p>We have some nice setup already. But it turned out that for recalculating <code>daily_prices</code> if some rules or values influencing the price change it's much more convenient to just remove them all and recalculate from scratch than checking if the price for given date needs to be recalculated. To be on the safe side, we may decide not to hard remove these rates, but do a soft delete instead.</p>




<p>To implement this feature we could add <code>deleted_at</code> column, drop the previous index and a new one which will respect the new column. We should also update the validation in model in such case:</p>


<p><code>ruby app/models/daily_price.rb
validates :rental_id, presence: true, uniqueness: { scope: [:date, :deleted_at] }
</code></p>

<p>And the migration part:</p>


<p><code>ruby db/migrate/20161030120000_add_deleted_at_to_daily_prices.rb
  remove_index :daily_prices, [:rental_id, :date], unique: true
  add_column :daily_prices, :deleted_at, :datetime
  add_index :daily_prices, [:rental_id, :date, :deleted_at], unique: true
</code></p>

<p>Everything should be fine with that, right? What could possibly go wrong here?</p>




<h2>Adding index the right way</h2>




<p>Let's play with Rails console and check it out:</p>


<p>``` ruby</p>

<blockquote><p>time_now = Time.current
 => Sun, 23 Oct 2016 09:44:46 UTC +00:00
DailyPrice.create!(price: 100, date: Date.current, rental_id: 1, deleted_at: time_now)
  COMMIT
DailyPrice.create!(price: 100, date: Date.current, rental_id: 1)
  COMMIT
DailyPrice.create!(price: 100, date: Date.current, rental_id: 1)
  ROLLBACK
ActiveRecord::RecordInvalid: Validation failed: Rental has already been taken
```</p></blockquote>

<p>Nah, there can't be any problem, looks like we have the expected behaviour - we couldn't create a non-soft-deleted <strong>daily_price</strong> for given date and rental. But let's check one more thing:</p>


<p>``` ruby</p>

<blockquote><p>price = DailyPrice.new(price: 100, date: Date.current, rental_id: 1)
price.save(validate: false)
  COMMIT
```</p></blockquote>

<p>Whoops! Something looks very wrong here. But how is it possible? The index looks exactly like the validation in our model, yet it didn't work like that when we bypassed the validation.</p>




<p>Let's consult <strong>PostgreSQL</strong> <a href="https://www.postgresql.org/docs/9.0/static/indexes-unique.html" target="_blank">docs</a>. There is something mentioned about null values: </p>


<p><blockquote><p>Null values are not considered equal</p></blockquote></p>

<p>That is our problem: ActiveRecord considered it as a unique value, but it doesn't work quite like that in <strong>PostgreSQL</strong>.</p>




<p>Our index should be in fact <strong>conditional</strong> and look the following way:</p>


<p><code>ruby
add_index :nightly_rates, [:rental_id, :date], unique: true, where: "deleted_at IS NULL"
</code></p>

<p>We could optionally improve the validation in our model to make it look much closer to what we have in database and use <code>conditions</code> option:</p>


<p><code>ruby app/models/daily_price.rb
validates :rental_id, presence: true, uniqueness: { scope: :date, conditions: -&gt; { where(deleted_at: nil) } }
</code></p>

<p>And that's it! There's no way we could compromise <strong>data integrity</strong> now!</p>




<h2>Wrapping Up</h2>




<p>Keeping data integrity in check is essential for most of the applications to not cause some serious problems, especially when implementing soft delete. Fortunately, simply by adding PostgreSQL conditional unique indexes we can protect ourselves from such issues.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scaling Up Rails Applications With PostgreSQL Table Partitioning - Part 3]]></title>
    <link href="https://karolgalanciak.com/blog/2016/07/10/scaling-up-rails-applications-with-postgresql-table-partitioning-part-3/"/>
    <updated>2016-07-10T23:50:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2016/07/10/scaling-up-rails-applications-with-postgresql-table-partitioning-part-3</id>
    <content type="html"><![CDATA[<p>After publishing recent blog posts about table partitioning - its <a href="https://karolgalanciak.com/blog/2016/06/05/scaling-up-rails-applications-with-postgresql-table-partitioning-part-1/" target="_blank">SQL basics part</a> and <a href="https://karolgalanciak.com/blog/2016/06/12/scaling-up-rails-applications-with-postgresql-table-partitioning-part-2/" target="_blank">how to use in in Rails application</a> I was asked quite a few times what is the real <b>performance gain</b> when using <strong>table partitioning</strong>. This is a great question, so let's answer it by performing some benchmarks.</p>




<!--more-->




<h2>Setting up data for benchmarking</h2>




<p>As the table partitioning is intended to be used in Rails application, it makes most sense to perform benchmark with ActiveRecord's overhead as well - we want to have some real-world comparison.</p>




<p>In the two previous parts we were discussing <code>orders</code> example, so let's do the same here. We can start with generating model:</p>


<p><code>rb
rails generate Order
</code></p>

<p>For benchmarking use case without table partitioning we don't really need to change much, just add an index for <code>created_at</code> column:</p>


<p>``` rb
class CreateOrders &lt; ActiveRecord::Migration
  def change</p>

<pre><code>create_table :orders do |t|
  t.timestamps null: false
end

add_index :orders, :created_at
</code></pre>

<p>  end
end
```</p>

<p>In case of partitioning, however, we need to set up some extra tables. We can reuse the examples from <a href="https://karolgalanciak.com/blog/2016/06/12/scaling-up-rails-applications-with-postgresql-table-partitioning-part-2/" target="_blank">part 2</a>. Let's add the partitoned gem to the Gemfile:</p>


<p><code>rb
gem 'activerecord-redshift-adapter',  git: "git@github.com:arp/activerecord-redshift-adapter.git", branch: "rails4-compatibility"
gem 'partitioned', git: "git@github.com:dkhofer/partitioned.git", branch: "rails-4-2"
</code></p>

<p>And set up <code>Order</code> model with the base class for partitioning by year (all the details are explained in <a href="https://karolgalanciak.com/blog/2016/06/12/scaling-up-rails-applications-with-postgresql-table-partitioning-part-2/" target="_blank">part 2</a>):</p>


<p>``` rb
class PartitionedByCreatedAtYearly &lt; Partitioned::ByYearlyTimeField
  self.abstract_class = true</p>

<p>  def self.partition_time_field</p>

<pre><code>:created_at
</code></pre>

<p>  end</p>

<p>  partitioned do |partition|</p>

<pre><code>partition.index :id, unique: true
</code></pre>

<p>  end
end
```</p>

<p><code>rb
class Order &lt; PartitionedByCreatedAtYearly
end
</code></p>

<p>Finally, we can set up the migration:</p>


<p>``` rb
class CreateOrders &lt; ActiveRecord::Migration
  def up</p>

<pre><code>create_table :orders do |t|
  t.timestamps null: false
end

add_index :orders, :created_at

Order.create_infrastructure
dates = Order.partition_generate_range(Date.today, Date.today + 4.year)
Order.create_new_partition_tables(dates)
</code></pre>

<p>  end</p>

<p>  def down</p>

<pre><code>Order.delete_infrastructure
drop_table :orders
</code></pre>

<p>  end
end
```</p>

<p>For sample data let's start with creating 1 million orders for every year from 2016 to 2020. This should be enough to make the tables moderately big for real-world example and perform some meaningful benchmarking. Here's the code to create these records with random date from given year: </p>


<p>``` rb
[2016, 2017, 2018, 2019, 2020].each do |current_year|
  dates_range = Date.new(current_year, 1, 1)..Date.new(current_year, 12, 31)
  Order.transaction do</p>

<pre><code>1000000.times do
  Order.create(created_at: dates_range.to_a.sample)
end
</code></pre>

<p>  end
end
```</p>

<p>Don't expect this one to finish fast ;).</p>




<p>To get even better idea about the performance difference, we could also test the queries with different amount of data. After each benchmark we could create additional 250 000 records for each year and rerun benchmarks. This could be reapeated until we reach 2 mln records in each table (10 mln in total) so that way we would have data for 5 different orders' amount.</p>




<h2>Benchmark methodology</h2>




<p>To have a meaningful benchmark that can be applicable to some real-world app, we need to test the queries that are likely to happen. For that purpose we can try selecting all orders, orders from particular year, from several years, from past few months and we could also try finding some orders with random id. We should also limit the amount of records we return, well, unless we want to kill the local machine ;). Counting the amount of orders for different date ranges would also be a nice addition. For partitioned tables we could also throw in some additional benchmarks comparing the performance between selecting orders from given partitioned child table and from master table and letting the PostgreSQL figure out how to handle the query (i.e. using constraint exclusion for filtering tables).</p>




<p>In this case we don't really care about exact time for each query, but rather the ratio of query time (or iterations per seconds) for partitioned and not-partitioned table. Counting iterations per seconds for every query with <a href="https://github.com/evanphx/benchmark-ips">banchmark-ips</a> will be perfect for that. To calculate this ratio (let's call it Partioned To Not Partioned Ratio) we would just need to divide the result from partitioned table by the result from non-partitioned table.</p>




<p>The amount of data is quite an important factor for this benchmark, especially with comparison to some <strong>PostgreSQL</strong> config settings. The size of orders table for different amount is the following:</p>


<p><code>
1,00 mln orders each -  5,00 mln total) - 249 MB
1,25 mln orders each -  6,25 mln total) - 311 MB
1,50 mln orders each -  7,50 mln total) - 373 MB
1,75 mln orders each -  8,75 mln total) - 436 MB
2,00 mln orders each - 10,00 mln total) - 498 MB
</code></p>

<p>These are the most essential config settings on my local machine which were used during the benchmark:</p>


<p><code>
shared_buffers = 128MB
temp_buffers = 8MB
work_mem = 4MB
maintenance_work_mem = 64MB
constraint_exclusion = partition
</code></p>

<p>From our benchmark's perspective, <code>shared_buffers</code> and <code>constraint_exclusion</code> parameters are the crucial ones - <code>shared_buffers</code>determines how much memory can be used for caching tables and <code>constraint_exclusion</code> will prevent scanning all child tables if the query conditions make it clear it is not required.</p>




<p>Here's the final benchmark code, for patitioned tables:</p>


<p>``` rb
require &lsquo;benchmark/ips&rsquo;</p>

<p>Benchmark.ips do |x|
  x.config(time: 45, warmup: 2)</p>

<p>  x.report(&ldquo;select_all&rdquo;) { Order.limit(1000) }
  x.report(&ldquo;select_all_count&rdquo;) { Order.count }
  x.report(&ldquo;select_2016&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2016-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2016_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2016-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2016_partitioned&rdquo;) {  Order.from_partition(Date.new(2016)).limit(1000) }
  x.report(&ldquo;select_2016_partitioned_count&rdquo;) {  Order.from_partition(Date.new(2016)).count }
  x.report(&ldquo;select_2018&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2018-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2018_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2018-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2018_partitioned&rdquo;) { Order.from_partition(Date.new(2018)).limit(1000) }
  x.report(&ldquo;select_2018_partitioned_count&rdquo;) { Order.from_partition(Date.new(2018)).count }
  x.report(&ldquo;select_2020&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2020-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).limit(100) }
  x.report(&ldquo;select_2020_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2020-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2020_partitioned&rdquo;) { Order.from_partition(Date.new(2020)).limit(1000) }
  x.report(&ldquo;select_2020_partitioned_count&rdquo;) { Order.from_partition(Date.new(2020)).count }
  x.report(&ldquo;select_2016_2019&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2019-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2016_2019_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2019-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2018_2020&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2018_2020_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_last_3_months&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 3.months.ago).limit(1000) }
  x.report(&ldquo;select_last_3_months_count&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 3.months.ago).count }
  x.report(&ldquo;select_last_6_months&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 6.months.ago).limit(1000) }
  x.report(&ldquo;select_last_6_months_count&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 6.months.ago).count }
  x.report(&ldquo;select_random_order&rdquo;) { Order.find(rand(5000000)) }</p>

<p>  x.compare!
end
```</p>

<p>and for tables without partitioning:</p>


<p>``` rb
require &lsquo;benchmark/ips&rsquo;</p>

<p>Benchmark.ips do |x|
  x.config(time: 45, warmup: 2)</p>

<p>  x.report(&ldquo;select_all&rdquo;) { Order.limit(1000) }
  x.report(&ldquo;select_all_count&rdquo;) { Order.count }
  x.report(&ldquo;select_2016&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2016-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2016_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2016-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2018&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2018-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2018_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2018-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2020&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2020-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).limit(100) }
  x.report(&ldquo;select_2020_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2020-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2016_2019&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2019-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2016_2019_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2016-01-01&rsquo; AND created_at &lt;= &lsquo;2019-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_2018_2020&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).limit(1000) }
  x.report(&ldquo;select_2018_2020_count&rdquo;) { Order.where(&ldquo;created_at >= &lsquo;2018-01-01&rsquo; AND created_at &lt;= &lsquo;2020-12-31&rsquo;&rdquo;).count }
  x.report(&ldquo;select_last_3_months&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 3.months.ago).limit(1000) }
  x.report(&ldquo;select_last_3_months_count&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 3.months.ago).count }
  x.report(&ldquo;select_last_6_months&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 6.months.ago).limit(1000) }
  x.report(&ldquo;select_last_6_months_count&rdquo;) { Order.where(&ldquo;created_at >= ?&rdquo;, 6.months.ago).count }
  x.report(&ldquo;select_random_order&rdquo;) { Order.find(rand(5000000)) }</p>

<p>  x.compare!
end
```</p>

<p>Each operation will run for 45 seconds. We also need to include some warmup, otherwise the results would be less accurate.</p>




<h2>Benchmark results</h2>




<p>Here are the results of the benchmarks:</p>


<p>```
partitioned with 5 mln orders (1 mln orders per table)</p>

<p>Comparison:</p>

<p>select_all:                     74897.5 i/s
select_all_count:               1.9 i/s &ndash; 40047.58x slower
select_2016:                    44578.5 i/s &ndash; 1.68x slower
select_2016_count:              4.8 i/s &ndash; 15640.07x slower
select_2016_partitioned:        57904.0 i/s &ndash; 1.29x slower
select_2016_partitioned_count:  12.7 i/s &ndash; 5882.06x slower
select_2018:                    45989.3 i/s &ndash; 1.63x slower
select_2018_count:              4.9 i/s &ndash; 15263.65x slower
select_2018_partitioned:        58718.1 i/s &ndash; 1.28x slower
select_2018_partitioned_count:  13.7 i/s &ndash; 5475.04x slower
select_2020:                    49474.6 i/s &ndash; 1.51x slower
select_2020_count:              5.3 i/s &ndash; 14206.52x slower
select_2020_partitioned:        64135.2 i/s &ndash; 1.17x slower
select_2020_partitioned_count:  14.1 i/s &ndash; 5310.68x slower
select_2016_2019:               49829.4 i/s &ndash; 1.50x slower
select_2016_2019_count:         1.3 i/s &ndash; 58027.53x slower
select_2018_2020:               49869.1 i/s &ndash; 1.50x slower
select_2018_2020_count:         1.7 i/s &ndash; 43108.82x slower
select_last_3_months:           3904.2 i/s &ndash; 19.18x slower
select_last_3_months_count:     1.3 i/s &ndash; 55527.51x slower
select_last_6_months:           3909.1 i/s &ndash; 19.16x slower
select_last_6_months_count:     1.3 i/s &ndash; 56307.51x slower
select_random_order:            2629.8 i/s &ndash; 28.48x slower
```</p>

<p>```
no partitions with 5 mln orders</p>

<p>Comparison:
select_all:                   81600.5 i/s
select_all_count:             2.6 i/s &ndash; 31546.89x slower
select_2016:                  50899.1 i/s &ndash; 1.60x slower
select_2016_count:            2.4 i/s &ndash; 34118.71x slower
select_2018:                  49785.5 i/s &ndash; 1.64x slower
select_2018_count:            2.3 i/s &ndash; 35518.36x slower
select_2020:                  50353.3 i/s &ndash; 1.62x slower
select_2020_count:            2.2 i/s &ndash; 36477.64x slower
select_2016_2019:             50161.9 i/s &ndash; 1.63x slower
select_2016_2019_count:       1.2 i/s &ndash; 69940.19x slower
select_2018_2020:             50317.3 i/s &ndash; 1.62x slower
select_2018_2020_count:       1.4 i/s &ndash; 59057.02x slower
select_last_3_months:         3907.2 i/s &ndash; 20.88x slower
select_last_3_months_count:   1.5 i/s &ndash; 55355.65x slower
select_last_6_months:         3904.1 i/s &ndash; 20.90x slower
select_last_6_months_count:   1.5 i/s &ndash; 54201.25x slower
select_random_order:          2395.9 i/s &ndash; 34.06x slower
```</p>

<p>```
partitioned with 6,25 mln orders (1,25 mln orders per table)</p>

<p>Comparison:
select_all:                     73717.9 i/s
select_all_count:               1.4 i/s &ndash; 51747.39x slower
select_2016:                    44895.7 i/s &ndash; 1.64x slower
select_2016_count:              3.9 i/s &ndash; 19133.01x slower
select_2016_partitioned:        57672.1 i/s &ndash; 1.28x slower
select_2016_partitioned_count:  10.2 i/s &ndash; 7211.72x slower
select_2018:                    45076.8 i/s &ndash; 1.64x slower
select_2018_count:              3.7 i/s &ndash; 19909.78x slower
select_2018_partitioned:        57480.8 i/s &ndash; 1.28x slower
select_2018_partitioned_count:  10.3 i/s &ndash; 7177.85x slower
select_2020:                    44549.7 i/s &ndash; 1.65x slower
select_2020_count:              3.8 i/s &ndash; 19585.29x slower
select_2020_partitioned:        58816.4 i/s &ndash; 1.25x slower
select_2020_partitioned_count:  10.3 i/s &ndash; 7167.61x slower
select_2016_2019:               45154.9 i/s &ndash; 1.63x slower
select_2016_2019_count:         0.9 i/s &ndash; 78001.75x slower
select_2018_2020:               44243.8 i/s &ndash; 1.67x slower
select_2018_2020_count:         1.3 i/s &ndash; 57270.76x slower
select_last_3_months:           3607.3 i/s &ndash; 20.44x slower
select_last_3_months_count:     1.0 i/s &ndash; 72969.17x slower
select_last_6_months:           3650.9 i/s &ndash; 20.19x slower
select_last_6_months_count:     1.0 i/s &ndash; 73116.36x slower
select_random_order:            2734.6 i/s &ndash; 26.96x slower
```</p>

<p>```
no partitions with 6,25 mln orders</p>

<p>Comparison:
select_all:                    81474.7 i/s
select_all_count:              2.0 i/s &ndash; 40681.89x slower
select_2016:                   51134.3 i/s &ndash; 1.59x slower
select_2016_count:             4.8 i/s &ndash; 17008.37x slower
select_2018:                   51037.4 i/s &ndash; 1.60x slower
select_2018_count:             4.8 i/s &ndash; 16942.96x slower
select_2020:                   51078.8 i/s &ndash; 1.60x slower
select_2020_count:             4.8 i/s &ndash; 17054.96x slower
select_2016_2019:              50950.0 i/s &ndash; 1.60x slower
select_2016_2019_count:        0.9 i/s &ndash; 86364.33x slower
select_2018_2020:              50587.6 i/s &ndash; 1.61x slower
select_2018_2020_count:        1.1 i/s &ndash; 72926.49x slower
select_last_3_months:          3889.7 i/s &ndash; 20.95x slower
select_last_3_months_count:    1.2 i/s &ndash; 67447.88x slower
select_last_6_months:          3917.4 i/s &ndash; 20.80x slower
select_last_6_months_count:    1.2 i/s &ndash; 67757.10x slower
select_random_order:           3052.7 i/s &ndash; 26.69x slower</p>

<p>```</p>

<p>```
partitioned with 7,5 mln orders (1,5 mln orders per table)</p>

<p>Comparison:
select_all:                      73455.4 i/s
select_all_count:                1.2 i/s &ndash; 60875.32x slower
select_2016:                     45358.7 i/s &ndash; 1.62x slower
select_2016_count:               3.2 i/s &ndash; 23066.47x slower
select_2016_partitioned:         57730.7 i/s &ndash; 1.27x slower
select_2016_partitioned_count:   9.0 i/s &ndash; 8161.54x slower
select_2018:                     47094.5 i/s &ndash; 1.56x slower
select_2018_count:               3.3 i/s &ndash; 22478.03x slower
select_2018_partitioned:         59741.3 i/s &ndash; 1.23x slower
select_2018_partitioned_count:   8.9 i/s &ndash; 8289.60x slower
select_2020:                     46247.4 i/s &ndash; 1.59x slower
select_2020_count:               3.2 i/s &ndash; 23056.21x slower
select_2020_partitioned:         58764.7 i/s &ndash; 1.25x slower
select_2020_partitioned_count:   8.8 i/s &ndash; 8318.22x slower
select_2016_2019:                44424.4 i/s &ndash; 1.65x slower
select_2016_2019_count:          0.8 i/s &ndash; 94546.45x slower
select_2018_2020:                45202.2 i/s &ndash; 1.63x slower
select_2018_2020_count:          1.1 i/s &ndash; 68131.10x slower
select_last_3_months:            3530.4 i/s &ndash; 20.81x slower
select_last_3_months_count:      0.8 i/s &ndash; 89367.97x slower
select_last_6_months:            3473.7 i/s &ndash; 21.15x slower
select_last_6_months_count:      0.8 i/s &ndash; 92414.10x slower
select_random_order:             1224.6 i/s &ndash; 59.98x slower
```</p>

<p>```
no partitions with 7,5 mln orders</p>

<p>Comparison:
select_all:                   81357.1 i/s
select_all_count:             1.6 i/s &ndash; 52303.23x slower
select_2016:                  45865.5 i/s &ndash; 1.77x slower
select_2016_count:            3.8 i/s &ndash; 21673.22x slower
select_2018:                  49084.3 i/s &ndash; 1.66x slower
select_2018_count:            3.7 i/s &ndash; 21837.91x slower
select_2020:                  48963.7 i/s &ndash; 1.66x slower
select_2020_count:            3.8 i/s &ndash; 21364.75x slower
select_2016_2019:             49560.5 i/s &ndash; 1.64x slower
select_2016_2019_count:       0.7 i/s &ndash; 109331.83x slower
select_2018_2020:             47704.7 i/s &ndash; 1.71x slower
select_2018_2020_count:       0.8 i/s &ndash; 96387.27x slower
select_last_3_months:         3614.5 i/s &ndash; 22.51x slower
select_last_3_months_count:   0.9 i/s &ndash; 88464.34x slower
select_last_6_months:         3732.7 i/s &ndash; 21.80x slower
select_last_6_months_count:   0.9 i/s &ndash; 85721.04x slower
select_random_order:          2433.7 i/s &ndash; 33.43x slower
```</p>

<p>```
partitioned with 8,75 mln orders (1,75 mln orders per table)</p>

<p>Comparison:
select_all:                      69684.2 i/s
select_all_count:                1.0 i/s &ndash; 68219.96x slower
select_2016:                     44071.1 i/s &ndash; 1.58x slower
select_2016_count:               2.7 i/s &ndash; 26202.73x slower
select_2016_partitioned:         56547.4 i/s &ndash; 1.23x slower
select_2016_partitioned_count:   7.1 i/s &ndash; 9790.82x slower
select_2018:                     44275.5 i/s &ndash; 1.57x slower
select_2018_count:               2.8 i/s &ndash; 25299.18x slower
select_2018_partitioned:         59494.0 i/s &ndash; 1.17x slower
select_2018_partitioned_count:   7.8 i/s &ndash; 8963.99x slower
select_2020:                     48330.6 i/s &ndash; 1.44x slower
select_2020_count:               2.9 i/s &ndash; 24392.21x slower
select_2020_partitioned:         61583.6 i/s &ndash; 1.13x slower
select_2020_partitioned_count:   7.7 i/s &ndash; 9056.91x slower
select_2016_2019:                48135.1 i/s &ndash; 1.45x slower
select_2016_2019_count:          0.7 i/s &ndash; 100006.51x slower
select_2018_2020:                47873.0 i/s &ndash; 1.46x slower
select_2018_2020_count:          1.0 i/s &ndash; 72089.48x slower
select_last_3_months:            3789.7 i/s &ndash; 18.39x slower
select_last_3_months_count:      0.7 i/s &ndash; 93772.85x slower
select_last_6_months:            3743.8 i/s &ndash; 18.61x slower
select_last_6_months_count:      0.7 i/s &ndash; 104123.34x slower
select_random_order:             1594.8 i/s &ndash; 43.70x slower
```</p>

<p>```
no partitions with 8,75 mln orders</p>

<p>Comparison:
select_all:                    78650.3 i/s
select_all_count:              1.4 i/s &ndash; 57896.82x slower
select_2016:                   49334.2 i/s &ndash; 1.59x slower
select_2016_count:             2.8 i/s &ndash; 28319.15x slower
select_2018:                   49795.5 i/s &ndash; 1.58x slower
select_2018_count:             2.8 i/s &ndash; 27838.51x slower
select_2020:                   49627.9 i/s &ndash; 1.58x slower
select_2020_count:             2.9 i/s &ndash; 27517.70x slower
select_2016_2019:              50133.2 i/s &ndash; 1.57x slower
select_2016_2019_count:        0.7 i/s &ndash; 118255.69x slower
select_2018_2020:              49375.8 i/s &ndash; 1.59x slower
select_2018_2020_count:        0.7 i/s &ndash; 108822.92x slower
select_last_3_months:          3574.1 i/s &ndash; 22.01x slower
select_last_3_months_count:    0.8 i/s &ndash; 97753.55x slower
select_last_6_months:          3562.1 i/s &ndash; 22.08x slower
select_last_6_months_count:    0.8 i/s &ndash; 99605.90x slower
select_random_order:           3419.0 i/s &ndash; 23.00x slower
```</p>

<p>```
partitioned with 10 mln orders (2 mln orders per table)</p>

<p>Comparison:
select_all:                      73071.4 i/s
select_all_count:                0.9 i/s &ndash; 77393.87x slower
select_2016:                     46767.5 i/s &ndash; 1.56x slower
select_2016_count:               2.5 i/s &ndash; 29518.12x slower
select_2016_partitioned:         59404.4 i/s &ndash; 1.23x slower
select_2016_partitioned_count:   6.6 i/s &ndash; 11005.71x slower
select_2018:                     47674.2 i/s &ndash; 1.53x slower
select_2018_count:               2.4 i/s &ndash; 30309.30x slower
select_2018_partitioned:         58371.9 i/s &ndash; 1.25x slower
select_2018_partitioned_count:   6.5 i/s &ndash; 11256.61x slower
select_2020:                     46546.0 i/s &ndash; 1.57x slower
select_2020_count:               2.3 i/s &ndash; 31198.92x slower
select_2020_partitioned:         58862.7 i/s &ndash; 1.24x slower
select_2020_partitioned_count:   6.3 i/s &ndash; 11672.16x slower
select_2016_2019:                46781.4 i/s &ndash; 1.56x slower
select_2016_2019_count:          0.6 i/s &ndash; 122988.06x slower
select_2018_2020:                46147.2 i/s &ndash; 1.58x slower
select_2018_2020_count:          0.8 i/s &ndash; 90296.27x slower
select_last_3_months:            3699.8 i/s &ndash; 19.75x slower
select_last_3_months_count:      0.6 i/s &ndash; 116559.31x slower
select_last_6_months:            3716.8 i/s &ndash; 19.66x slower
select_last_6_months_count:      0.6 i/s &ndash; 121600.00x slower
select_random_order:             1548.6 i/s &ndash; 47.19x slower
```</p>

<p>```
no partitions with 10 mln orders</p>

<p>Comparison:
select_all:                    77376.3 i/s
select_all_count:              1.2 i/s &ndash; 66625.00x slower
select_2016:                   46285.5 i/s &ndash; 1.67x slower
select_2016_count:             2.3 i/s &ndash; 33061.51x slower
select_2018:                   47121.7 i/s &ndash; 1.64x slower
select_2018_count:             2.4 i/s &ndash; 32082.74x slower
select_2020:                   50322.0 i/s &ndash; 1.54x slower
select_2020_count:             2.5 i/s &ndash; 31443.35x slower
select_2016_2019:              48615.7 i/s &ndash; 1.59x slower
select_2016_2019_count:        0.6 i/s &ndash; 135045.30x slower
select_2018_2020:              49185.5 i/s &ndash; 1.57x slower
select_2018_2020_count:        0.7 i/s &ndash; 114814.42x slower
select_last_3_months:          3781.1 i/s &ndash; 20.46x slower
select_last_3_months_count:    0.7 i/s &ndash; 106257.71x slower
select_last_6_months:          3737.8 i/s &ndash; 20.70x slower
select_last_6_months_count:    0.7 i/s &ndash; 107643.07x slower
select_random_order:           3655.0 i/s &ndash; 21.17x slower
```</p>

<p>That way we've obtained iterations per second for different queries. Let's calculate now the ratio of query time for partitionied and not partitioned table. To get the better idea about the relation between the ratios for different orders' amount, I put the results on the graph (due to the proportions you may want to see them in better quality by clicking the link below each graph).</p>


<p>```
| Orders amount (mln) | Select All Partitioned To Not Partitioned Ratio |
|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|
|        5,00         |                    0,917                        |
|        6,25         |                    0,905                        |
|        7,50         |                    0,903                        |
|        8,75         |                    0,886                        |
|       10,00         |                    0,944                        |</p>

<p>```
<img src="/images/partitioned_benchmark_graphs/select_all_graph.png" title="&lsquo;select_all_graph&rsquo; &lsquo;select_all_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_all_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select All Count Partitioned To Not Partitioned Ratio |
|---------------------|--------------------------------------------------------|
|        5,00         |                      0,731                             |
|        6,25         |                      0,700                             |
|        7,50         |                      0,750                             |
|        8,75         |                      0,714                             |
|       10,00         |                      0,750                             |
</code>
<img src="/images/partitioned_benchmark_graphs/select_all_count_graph.png" title="&lsquo;select_all_count&rsquo; &lsquo;select_all_count&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_all_count_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016 Partitioned (master table) To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------------|
|        5,00         |                         0,876                                    |
|        6,25         |                         0,878                                    |
|        7,50         |                         0,989                                    |
|        8,75         |                         0,893                                    |
|       10,00         |                         1,010                                    |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016_p_to_np_master_graph.png" title="&lsquo;select_2016_p_to_np_master_graph&rsquo; &lsquo;select_2016_p_to_np_master_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016_p_to_np_master_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016 Partitioned (child table) To Not Partitioned Ratio  |
|---------------------|------------------------------------------------------------------|
|        5,00         |                         1,138                                    |
|        6,25         |                         1,128                                    |
|        7,50         |                         1,259                                    |
|        8,75         |                         1,146                                    |
|       10,00         |                         1,283                                    |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016_p_to_np_child_graph.png" title="&lsquo;select_2016_p_to_np_child_graph&rsquo; &lsquo;select_2016_p_to_np_child_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016_p_to_np_child_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016 Partitioned (child table) To Master Table Ratio       |
|---------------------|--------------------------------------------------------------------|
|        5,00         |                         1,299                                      |
|        6,25         |                         1,285                                      |
|        7,50         |                         1,273                                      |
|        8,75         |                         1,283                                      |
|       10,00         |                         1,270                                      |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016_p_to_p_graph.png" title="&lsquo;select_2016_p_to_p_graph&rsquo; &lsquo;select_2016_p_to_p_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016_p_to_p_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016 Count Partitioned (master table) To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------------------|
|        5,00         |                            2,000                                       |
|        6,25         |                            0,813                                       |
|        7,50         |                            0,842                                       |
|        8,75         |                            0,964                                       |
|       10,00         |                            1,087                                       |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016_count_p_to_np_master_graph.png" title="&lsquo;select_2016_count_p_to_np_master_graph&rsquo; &lsquo;select_2016_count_p_to_np_master_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016_count_p_to_np_master_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016 Count Partitioned (child table) To Not Partitioned Ratio |
|---------------------|-----------------------------------------------------------------------|
|        5,00         |                                5,292                                  |
|        6,25         |                                2,125                                  |
|        7,50         |                                2,368                                  |
|        8,75         |                                2,536                                  |
|       10,00         |                                2,870                                  |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016_count_p_to_np_child_graph.png" title="&lsquo;select_2016_count_p_to_np_child_graph&rsquo; &lsquo;select_2016_count_p_to_np_child_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016_count_p_to_np_child_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016 Count Partitioned (child table) To Master Table Ratio |
|---------------------|--------------------------------------------------------------------|
|        5,00         |                               2,649                                |
|        6,25         |                               2,615                                |
|        7,50         |                               2,813                                |
|        8,75         |                               2,630                                |
|       10,00         |                               2,640                                |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016_count_p_to_p_graph.png" title="&lsquo;select_2016_count_p_to_p_graph&rsquo; &lsquo;select_2016_count_p_to_p_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016_count_p_to_p_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018 Partitioned (master table) To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------------|
|        5,00         |                          0,924                                   |
|        6,25         |                          0,883                                   |
|        7,50         |                          0,959                                   |
|        8,75         |                          0,889                                   |
|       10,00         |                          1,012                                   |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018_p_to_np_master_graph.png" title="&lsquo;select_2018_p_to_np_master_graph&rsquo; &lsquo;select_2018_p_to_np_master_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018_p_to_np_master_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018 Partitioned (child table) To Not Partitioned Ratio |
|---------------------|-----------------------------------------------------------------|
|        5,00         |                           1,179                                 |
|        6,25         |                           1,126                                 |
|        7,50         |                           1,217                                 |
|        8,75         |                           1,195                                 |
|       10,00         |                           1,239                                 |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018_p_to_np_child_graph.png" title="&lsquo;select_2018_p_to_np_child_graph&rsquo; &lsquo;select_2018_p_to_np_child_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018_p_to_np_child_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018 Partitioned (child table) To Master Table Ratio |
|---------------------|--------------------------------------------------------------|
|        5,00         |                           1,277                              |
|        6,25         |                           1,275                              |
|        7,50         |                           1,269                              |
|        8,75         |                           1,344                              |
|       10,00         |                           1,244                              |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018_p_to_p_graph.png" title="&lsquo;select_2018_p_to_p_graph&rsquo; &lsquo;select_2018_p_to_p_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018_p_to_p_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018 Count Partitioned (master table) To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------------------|
|        5,00         |                            2,130                                       |
|        6,25         |                            0,771                                       |
|        7,50         |                            0,892                                       |
|        8,75         |                            1,000                                       |
|       10,00         |                            1,000                                       |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018_count_p_to_np_master_graph.png" title="&lsquo;select_2018_count_p_to_np_master_graph&rsquo; &lsquo;select_2018_count_p_to_np_master_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018_count_p_to_np_master_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018 Count Partitioned (child table) To Not Partitioned Ratio |
|---------------------|-----------------------------------------------------------------------|
|        5,00         |                           5,957                                       |
|        6,25         |                           2,146                                       |
|        7,50         |                           2,405                                       |
|        8,75         |                           2,786                                       |
|       10,00         |                           2,708                                       |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018_count_p_to_np_child_graph.png" title="&lsquo;select_2018_count_p_to_np_child_graph&rsquo; &lsquo;select_2018_count_p_to_np_child_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018_count_p_to_np_child_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018 Count Partitioned (child table) To Master Table Ratio |
|---------------------|--------------------------------------------------------------------|
|        5,00         |                              2,796                                 |
|        6,25         |                              2,784                                 |
|        7,50         |                              2,697                                 |
|        8,75         |                              2,786                                 |
|       10,00         |                              2,708                                 |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018_count_p_to_p_graph.png" title="&lsquo;select_2018_count_p_to_p_graph&rsquo; &lsquo;select_2018_count_p_to_p_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018_count_p_to_p_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2020 Partitioned (master tables) To Not Partitioned Ratio |
|---------------------|-------------------------------------------------------------------|
|        5,00         |                            0,983                                  |
|        6,25         |                            0,873                                  |
|        7,50         |                            0,945                                  |
|        8,75         |                            0,984                                  |
|       10,00         |                            0,925                                  |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2020_p_to_np_master_graph.png" title="&lsquo;select_2020_p_to_np_master_graph&rsquo; &lsquo;select_2020_p_to_np_master_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2020_p_to_np_master_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2020 Partitioned (child table) To Not Partitioned Ratio |
|---------------------|-----------------------------------------------------------------|
|        5,00         |                             1,274                               |
|        6,25         |                             1,151                               |
|        7,50         |                             1,200                               |
|        8,75         |                             1,241                               |
|       10,00         |                             1,170                               |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2020_p_to_np_child_graph.png" title="&lsquo;select_2020_p_to_np_child_graph&rsquo; &lsquo;select_2020_p_to_np_child_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2020_p_to_np_child_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2020 Partitioned (child table) To Master Table Ratio |
|---------------------|--------------------------------------------------------------|
|        5,00         |                            1,296                             |
|        6,25         |                            1,320                             |
|        7,50         |                            1,270                             |
|        8,75         |                            1,274                             |
|       10,00         |                            1,265                             |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2020_p_to_p_graph.png" title="&lsquo;select_2020_p_to_p_graph&rsquo; &lsquo;select_2020_p_to_p_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2020_p_to_p_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2020 Count Partitioned (master table) To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------------------|
|        5,00         |                            2,409                                       |
|        6,25         |                            0,792                                       |
|        7,50         |                            0,842                                       |
|        8,75         |                            1,000                                       |
|       10,00         |                            0,920                                       |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2020_count_p_to_np_master_graph.png" title="&lsquo;select_2020_count_p_to_np_master_graph&rsquo; &lsquo;select_2020_count_p_to_np_master_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2020_count_p_to_np_master_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2020 Count Partitioned (child table) To Not Partitioned Ratio |
|---------------------|-----------------------------------------------------------------------|
|        5,00         |                               6,227                                   |
|        6,25         |                               2,146                                   |
|        7,50         |                               2,316                                   |
|        8,75         |                               2,656                                   |
|       10,00         |                               2,520                                   |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2020_count_p_to_np_child_graph.png" title="&lsquo;select_2020_count_p_to_np_child_graph&rsquo; &lsquo;select_2020_count_p_to_np_child_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2020_count_p_to_np_child_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2020 Count Partitioned (child table) To Master Table Ratio |
|---------------------|--------------------------------------------------------------------|
|        5,00         |                              2,660                                 |
|        6,25         |                              2,711                                 |
|        7,50         |                              2,750                                 |
|        8,75         |                              2,656                                 |
|       10,00         |                              2,739                                 |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2020_count_p_to_p_graph.png" title="&lsquo;select_2020_count_p_to_p_graph&rsquo; &lsquo;select_2020_count_p_to_p_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2020_count_p_to_p_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016-2019 Partitioned To Not Partitioned Ratio |
|---------------------|--------------------------------------------------------|
|        5,00         |                       0,993                            |
|        6,25         |                       0,886                            |
|        7,50         |                       0,896                            |
|        8,75         |                       0,960                            |
|       10,00         |                       0,962                            |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016-2019_p_to_np_graph.png" title="&lsquo;select_2016-2019_p_to_np_graph&rsquo; &lsquo;select_2016-2019_p_to_np_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016-2019_p_to_np_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2016-2019 Count Partitioned To Not Partitioned Ratio |
|---------------------|--------------------------------------------------------------|
|        5,00         |                            1,083                             |
|        6,25         |                            1,000                             |
|        7,50         |                            1,143                             |
|        8,75         |                            1,000                             |
|       10,00         |                            1,000                             |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2016-2019_count_p_to_np_graph.png" title="&lsquo;select_2016-select_2016-2019_count_p_to_np_graph&rsquo; &lsquo;select_2016-2019_count_p_to_np_graph-2019_p_to_np_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2016-2019_count_p_to_np_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018-2020 Partitioned To Not Partitioned Ratio           |
|---------------------|------------------------------------------------------------------|
|        5,00         |                          0,991                                   |
|        6,25         |                          0,875                                   |
|        7,50         |                          0,948                                   |
|        8,75         |                          0,970                                   |
|       10,00         |                          0,938                                   |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018-2020_p_to_np_graph.png" title="&lsquo;select_2018-2020_p_to_np_graph&rsquo; &lsquo;select_2018-2020_p_to_np_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018-2020_p_to_np_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select 2018-2020 Count Partitioned To Not Partitioned Ratio |
|---------------------|--------------------------------------------------------------|
|        5,00         |                          1,214                               |
|        6,25         |                          1,182                               |
|        7,50         |                          1,375                               |
|        8,75         |                          1,429                               |
|       10,00         |                          1,143                               |
</code>
<img src="/images/partitioned_benchmark_graphs/select_2018-2020_count_p_to_np_graph.png" title="&lsquo;select_2018-2020_count_p_to_np_graph&rsquo; &lsquo;2020_count_p_to_np_graph-2020_p_to_np_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_2018-2020_count_p_to_np_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select Last 3 Months Partitioned To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------|
|        5,00         |                            0,999                           |
|        6,25         |                            0,927                           |
|        7,50         |                            0,977                           |
|        8,75         |                            1,060                           |
|       10,00         |                            0,978                           |
</code>
<img src="/images/partitioned_benchmark_graphs/select_last_3_months_graph.png" title="&lsquo;select_last_3_months_graph&rsquo; &lsquo;select_last_3_months_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_last_3_months_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select Last 3 Months Count Partitioned To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------------|
|        5,00         |                            0,867                                 |
|        6,25         |                            0,833                                 |
|        7,50         |                            0,889                                 |
|        8,75         |                            0,875                                 |
|       10,00         |                            0,857                                 |
</code>
<img src="/images/partitioned_benchmark_graphs/select_last_3_months_count_graph.png" title="&lsquo;select_last_3_months_count_graph&rsquo; &lsquo;select_last_3_months_count_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_last_3_months_count_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select Last 6 Months Partitioned To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------|
|        5,00         |                         1,001                              |
|        6,25         |                         0,932                              |
|        7,50         |                         0,931                              |
|        8,75         |                         1,051                              |
|       10,00         |                         0,994                              |
</code>
<img src="/images/partitioned_benchmark_graphs/select_last_6_months_graph.png" title="&lsquo;select_last_3_months_graph&rsquo; &lsquo;select_last_6_months_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_last_6_months_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select Last 6 Months Count Partitioned To Not Partitioned Ratio |
|---------------------|------------------------------------------------------------------|
|        5,00         |                          0,867                                   |
|        6,25         |                          0,833                                   |
|        7,50         |                          0,889                                   |
|        8,75         |                          0,875                                   |
|       10,00         |                          0,857                                   |
</code>
<img src="/images/partitioned_benchmark_graphs/select_last_6_months_count_graph.png" title="&lsquo;select_last_6_months_count_graph&rsquo; &lsquo;select_last_6_months_count_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_last_6_months_count_graph.png" target="_blank">See in better quality</a>
</p>


<p><code>
| Orders amount (mln) |  Select Random Partitioned To Not Partitioned Ratio |
|---------------------|-----------------------------------------------------|
|        5,00         |                          1,098                      |
|        6,25         |                          0,896                      |
|        7,50         |                          0,503                      |
|        8,75         |                          0,466                      |
|       10,00         |                          0,424                      |
</code></p>

<p><img src="/images/partitioned_benchmark_graphs/select_random_graph.png" title="&lsquo;select_random_graph&rsquo; &lsquo;select_random_graph&rsquo;" ></p>

<p class="center">
  <a href="https://karolgalanciak.com/images/partitioned_benchmark_graphs/select_random_graph.png" target="_blank">See in better quality</a>
</p>




<p>Let's break down these benchmarks to several groups:</p>




<p>For selecting all records and counting them the obvious conclusion is that for partitioned tables the queries are slower: slightly slower for just selecting them and noticeably slower for counting them. For selecting all orders, the ratio of partitioned to not partitioned tables query times most likely decreases as the tables' size grow and for counting it is not clear: the data doesn't show any regular correlation, we could expect the ratio would also decrease for the larger amount of data, however, we can't really tell based on this benchmark, which even suggests it could be a constant value. Nevertheless, table partitioning isn't the best idea if the queries are primarily run across all the tables.</p>




<p>The results for selecting orders (queries for orders from years: 2016, 2018, 2020) only from specific date range which matches the constraints for children partitioned tabled look quite interesting: The more records we have, the better ratio (in favour of table of partitioning) we get. Table partitioning doesn't always yield better results when the child table is not specified (see: Partitioned (master table) To Not Partitioned Ratio), but there's a certain size of the tables when we get the ratio above 1, which means queries for partitioned tables (even without specifying a child table) are faster. When selecting from partitioned child table (see: Partitioned (child table) To Not Partitioned Ratio) the queries are faster for partitioned tables regardless of the size, which was expected. Depending on the size of the table, the difference can be quite significant, up to 28%. The data is not clear enough to be certain about the correlation with amount of orders / table size (substantial irregularity for orders from years 2020), but probably the bigger the tables are, the bigger difference of query time between partitioned and not partitioned tables, similarly to the case when the child table is not specified. The difference between explicitly running queries against a specific child table and running against a master table and relying on constraints exclusion it quite surprising: I was expecting only a slight difference, however, specifying a child table can make the queries up to 35% faster. There is a possibility this difference decreases slowly the more records there are in the tables, however, we would need more benchmarks to prove or disprove this hypothesis as there is another possibility of having costant ratio.</p>




<p>The general correlation for counting the records which can be put in the specific partitioned child tables is the same as for selecting the orders: the more records in the tables, the better performance table partitioning yields. When the child table is not specified, counting records can be faster for not partitioned tables until we reach a certain size where table partitioning seems to be a better choice performance-wise. For counting orders from all the years (2016, 2018, 2020) for 5 mln orders, the ratios are significantly different comparing to the values for higher amount of orders, which can't be easily explained. It's quite interesting that it happened for the queries for all the tables used in the benchmark, which might be worth investigating further, however, I would treat them as irrelevant in this case and not consider them at all. When the partitioned table is specified, the results are always better in favour of table partitioning - we can expect queries to be more than 2 times faster, even up to almost 3 times faster. Similarly to selecting the orders, the ratio of running queries against child table and master table is either a constant or slightly decreases as the amount of orders grows.</p>




<p>For selecting records form multiple children tables, the Partioned To Not Partitioned Ratio is lower than 1, which means that table partitioning would be a inferior choice for such queries, regardless of the size. However, the difference is not that significant. On the other hand, for counting the records it looks like table partitioning yields better performance, which is especially clear for 2018-2020 range, but we can't tell what's the correlation with the amount of orders based on the obtained results.</p>




<p>The performance for selecting records from last N months (here 3 and 6 accordingly) is quite similar for both partitioned and not partitioned strategies (ratio close to 1), which doesn't change when the amount of orders grows. However, counting records is significantly slower, but the ratio most likely remains constant as the table gets bigger.</p>




<p>Initially, there seems to be no difference in query time between selecting orders from partitioned and not-partitioned table, but as the amount of orders grows, the performance keeps getting worse considerably, which is expected as the constraints exclusion can't be applied in such case.</p>




<p>To sum up:</p>




<ul>
  <li>The larger amount of records, the better performance table partitioning yields</li>
  <li>Table partitioning is not optimal for all type of queries, it should be mostly used when querying only a subset of records covered by a particular child table</li>
  <li>Specifying exact child table yields much better peformance than querying master table and relying on constraint exclusion</li>
</ul>




<h2>Wrapping up</h2>




<p>Even though table partitioning requires some extra overhead and may be tricky to get started with, it is clear that the performance benefits of using it may outweight the costs when applying to the right queries. However, we need to be aware that it is not the perfect choice for all the queries and in some cases it can deteriorate the performance.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scaling Up Rails Applications With PostgreSQL Table Partitioning - Part 2]]></title>
    <link href="https://karolgalanciak.com/blog/2016/06/12/scaling-up-rails-applications-with-postgresql-table-partitioning-part-2/"/>
    <updated>2016-06-12T22:45:00+02:00</updated>
    <id>https://karolgalanciak.com/blog/2016/06/12/scaling-up-rails-applications-with-postgresql-table-partitioning-part-2</id>
    <content type="html"><![CDATA[<p>In the previous <a href="https://karolgalanciak.com/blog/2016/06/05/scaling-up-rails-applications-with-postgresql-table-partitioning-part-1/" target="_blank">blog post</a> we learned some basics about <strong>table partitioning</strong>: how it works and what kind of problems it solves. So far we've been discussing mostly basic concepts with raw <strong>SQL</strong> examples. But the essential question in our case would be: how to make it work inside <strong>Rails application</strong> then? Let's see what we can do about it.</p>




<!--more-->




<h2>Partitioning tables with <code>partitioned</code> gem</h2>




<p>It turns out there's no built-in support for table partitioning in ActiveRecord. Fortunately, there's a gem that makes it pretty straight-forward to apply this concept to your models: <a href="https://github.com/fiksu/partitioned" target="_blank">partitioned</a>. Not only does it have several strategies for partitioning (e.g. by foreign key or by yearly / weekly / monthly and you can easily create custom ones by subclassing base class and defining proper methods) making it easy to perform <strong>CRUD</strong> operations when dealing with multiple tables, but it also provides some methods to create and destroy infrastructure (separate schema for partitioned tables) and some helper methods for generating tables based on partitioning criteria, even with indexes and constraints! Let's get back to example from previous the blog post with orders. Firstly, add <code>partitioned</code> gem to the Gemfile. Unfortunately, there are some issues with compatibility with Rails 4.2 at the time I was experimenting with it, so it might be necessary to use some forks. The following combination should work with Rails 4.2.6:</p>


<p><code>
gem 'activerecord-redshift-adapter',  git: "git@github.com:arp/activerecord-redshift-adapter.git", branch: "rails4-compatibility"
gem 'partitioned', git: "git@github.com:dkhofer/partitioned.git", branch: "rails-4-2"
</code></p>

<p>and of course run <code>bundle install</code>. Now we can generate model:</p>


<p><code>
rails generate model Order
</code></p>

<p>Firstly, let's set up the partitioned Order model. To handle partitioning strategy for separate tables for every year based on <code>created_at</code> column, we could define the following base class:</p>


<p>``` ruby app/models/partitioned_by_created_at_yearly.rb
class PartitionedByCreatedAtYearly &lt; Partitioned::ByYearlyTimeField
  self.abstract_class = true</p>

<p>  def self.partition_time_field</p>

<pre><code>:created_at
</code></pre>

<p>  end</p>

<p>  partitioned do |partition|</p>

<pre><code>partition.index :id, unique: true
</code></pre>

<p>  end
end
```</p>

<p>This class inherits from <code>Partitioned::ByYearlyTimeField</code> to handle exactly the strategy we need for orders. We set this class to be an abstract one to make it clear it's not related to any table in the database. We also need to provide <code>partition_time_field</code>, in our case it's <code>created_at</code> column. In <code>partitioned</code> block we can define some extra constraints and indexes that will be used when creating children tables. The next thing would be to make it a parent class for <code>Order</code> model:</p>


<p><code>ruby app/models/order.rb
class Order &lt; PartitionedByCreatedAtYearly
end
</code></p>

<h2>Creating migration for partitioned tables</h2>




<p>Let's get back to our migration. What we want to do is to create <code>orders</code> table, a schema for children partitioned tables of orders and the tables themselves for the next several years. We could do it the following way:</p>


<p>``` sql
class CreateOrders &lt; ActiveRecord::Migration
  def up</p>

<pre><code>create_table :orders do |t|

  t.timestamps null: false
end

Order.create_infrastructure
dates = Order.partition_generate_range(Date.today, Date.today + 5.year)
Order.create_new_partition_tables(dates)
</code></pre>

<p>  end</p>

<p>  def down</p>

<pre><code>Order.delete_infrastructure
drop_table :orders
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>The gem also provides excellent helper method <code>partition_generate_range</code> to help with setting up new partition tables. That way we will generate tables handling orders from 2016 to 2021. Now you can simply run <code>rake db:migrate</code>.</p>




<h2>CRUD operations on partitioned tables</h2>




<p>So far we've managed to set up the database for handling table partitioning. But the essential question is: can our app handle management of these tables? Will it insert / update / delete records to and from proper tables? Let's play with some operations to find out:</p>


<p>```</p>

<blockquote><p>Order.create
   (0.1ms)  BEGIN
  SQL (11.7ms)  INSERT INTO &ldquo;orders_partitions&rdquo;.&ldquo;p2016&rdquo; (&ldquo;created_at&rdquo;, &ldquo;updated_at&rdquo;) VALUES ($1, $2) RETURNING &ldquo;id&rdquo;  [[&ldquo;created_at&rdquo;, &ldquo;2016-06-03 17:21:36.221268&rdquo;], [&ldquo;updated_at&rdquo;, &ldquo;2016-06-03 17:21:36.221268&rdquo;]]
   (5.9ms)  COMMIT
Order.create(created_at: 1.year.from_now)
   (0.1ms)  BEGIN
  SQL (0.8ms)  INSERT INTO &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo; (&ldquo;created_at&rdquo;, &ldquo;updated_at&rdquo;) VALUES ($1, $2) RETURNING &ldquo;id&rdquo;  [[&ldquo;created_at&rdquo;, &ldquo;2017-06-03 17:25:05.413114&rdquo;], [&ldquo;updated_at&rdquo;, &ldquo;2016-06-03 17:25:05.414208&rdquo;]]
   (121.4ms)  COMMIT
 => #<Order id: 2, created_at: "2017-06-03 17:25:05", updated_at: "2016-06-03 17:25:05">
Order.create(created_at: 2.years.from_now)
   (0.1ms)  BEGIN
  SQL (0.3ms)  INSERT INTO &ldquo;orders_partitions&rdquo;.&ldquo;p2018&rdquo; (&ldquo;created_at&rdquo;, &ldquo;updated_at&rdquo;) VALUES ($1, $2) RETURNING &ldquo;id&rdquo;  [[&ldquo;created_at&rdquo;, &ldquo;2018-06-03 17:25:11.634532&rdquo;], [&ldquo;updated_at&rdquo;, &ldquo;2016-06-03 17:25:11.635389&rdquo;]]
   (2.1ms)  COMMIT
 => #<Order id: 3, created_at: "2018-06-03 17:25:11", updated_at: "2016-06-03 17:25:11"></p>

<p>Order.all
  Order Load (0.6ms)  SELECT &ldquo;orders&rdquo;.<em> FROM &ldquo;orders&rdquo;
 => #&lt;ActiveRecord::Relation [#<Order id: 1, created_at: "2016-06-03 17:21:36", updated_at: "2016-06-03 17:21:36">, #<Order id: 2, created_at: "2017-06-03 17:25:05", updated_at: "2016-06-03 17:25:05">, #<Order id: 3, created_at: "2018-06-03 17:25:11", updated_at: "2016-06-03 17:25:11">]>
Order.all.count
   (0.6ms)  SELECT COUNT(</em>) FROM &ldquo;orders&rdquo;
 => 3</p>

<p>Order.find(1)
  Order Load (0.3ms)  SELECT  &ldquo;orders&rdquo;.* FROM &ldquo;orders&rdquo; WHERE &ldquo;orders&rdquo;.&ldquo;id&rdquo; = $1 LIMIT 1  [[&ldquo;id&rdquo;, 1]]
 => #<Order id: 1, created_at: "2016-06-03 17:21:36", updated_at: "2016-06-03 17:21:36"></p>

<p>Order.from_partition(Date.new(2017, 1, 1)).find(2)
  Order Load (0.3ms)  SELECT  &ldquo;orders&rdquo;.* FROM &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo; &ldquo;orders&rdquo; WHERE &ldquo;orders&rdquo;.&ldquo;id&rdquo; = $1 LIMIT 1  [[&ldquo;id&rdquo;, 2]]
 => #<Order id: 2, created_at: "2017-06-03 17:25:05", updated_at: "2016-06-03 17:25:05"></p>

<p>Order.from_partition(Date.new(2017, 1, 1)).find(2).update!(updated_at: 5.years.from_now)
  Order Load (0.3ms)  SELECT  &ldquo;orders&rdquo;.* FROM &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo; &ldquo;orders&rdquo; WHERE &ldquo;orders&rdquo;.&ldquo;id&rdquo; = $1 LIMIT 1  [[&ldquo;id&rdquo;, 2]]
   (0.1ms)  BEGIN
  SQL (0.2ms)  UPDATE &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo; SET &ldquo;updated_at&rdquo; = $1, &ldquo;created_at&rdquo; = $2 WHERE &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo;.&ldquo;id&rdquo; = 2  [[&ldquo;updated_at&rdquo;, &ldquo;2021-06-03 17:29:07.077931&rdquo;], [&ldquo;created_at&rdquo;, &ldquo;2017-06-03 17:25:05.413114&rdquo;]]
   (1.7ms)  COMMIT</p>

<p>Order.from_partition(Date.new(2018, 1, 1)).find(3).destroy
  Order Load (0.3ms)  SELECT  &ldquo;orders&rdquo;.* FROM &ldquo;orders_partitions&rdquo;.&ldquo;p2018&rdquo; &ldquo;orders&rdquo; WHERE &ldquo;orders&rdquo;.&ldquo;id&rdquo; = $1 LIMIT 1  [[&ldquo;id&rdquo;, 3]]
   (0.1ms)  BEGIN
  SQL (0.3ms)  DELETE FROM &ldquo;orders_partitions&rdquo;.&ldquo;p2018&rdquo; WHERE &ldquo;orders_partitions&rdquo;.&ldquo;p2018&rdquo;.&ldquo;id&rdquo; = $1  [[&ldquo;id&rdquo;, 3]]
   (1.7ms)  COMMIT</p>

<p>Order.from_partition(Date.new(2017, 1, 1)).update_all(updated_at: Time.zone.now)
  SQL (1.6ms)  UPDATE &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo; &ldquo;orders&rdquo; SET &ldquo;updated_at&rdquo; = &lsquo;2016-06-03 17:30:59.926682&rsquo;</p>

<p>Order.from_partition(Date.new(2017, 1, 1)).destroy_all
  Order Load (0.3ms)  SELECT &ldquo;orders&rdquo;.* FROM &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo; &ldquo;orders&rdquo;
   (0.1ms)  BEGIN
  SQL (0.2ms)  DELETE FROM &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo; WHERE &ldquo;orders_partitions&rdquo;.&ldquo;p2017&rdquo;.&ldquo;id&rdquo; = $1  [[&ldquo;id&rdquo;, 2]]
   (1.6ms)  COMMIT
```</p></blockquote>

<p>Awesome! Looks like all the CRUD operations work without any problems! We even have extremely helpful query method <code>from_partition</code> to scope queries to the specific child table.</p>




<h2>Wrapping up</h2>




<p>Table partitioning might a great solution to solve database performance issues. Even though it's not supported out-of-the-box by Rails, you can easily integrate it with your app thanks to <a href="https://github.com/fiksu/partitioned" target="_blank">partitioned</a> gem.</p>

]]></content>
  </entry>
  
</feed>
